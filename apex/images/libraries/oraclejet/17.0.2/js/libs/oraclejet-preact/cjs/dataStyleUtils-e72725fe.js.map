{"version":3,"file":"dataStyleUtils-e72725fe.js","sources":["../../src/utils/PRIVATE_chartUtils/accUtils.ts","../../src/utils/PRIVATE_chartUtils/navUtils.ts","../../src/utils/PRIVATE_visSVGUtils/areaUtils.ts","../../src/utils/PRIVATE_chartUtils/utils.ts","../../src/utils/PRIVATE_chartUtils/dataStyleUtils.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { generateAriaLabel } from '#utils/UNSAFE_visUtils/accUtils';\nimport { BundleType } from '../../resources/nls/bundle';\n\n/**\n * Returns the aria label for the chart item\n * @param translations The translations bundle.\n * @param series The series of the item.\n * @param group The group of the item.\n * @param value The value of the item.\n * @param isSelected Whether the item is selected.\n * @param isDrillable Whether the item is drillable.\n * @param accessibleLabel The accessible label of the item.\n * @returns\n */\nexport function getItemAriaLabel(\n  translations: BundleType,\n  series: string,\n  group: string,\n  value: number,\n  isSelectionEnabled: boolean,\n  isSelected: boolean,\n  isDrillable: boolean,\n  accessibleLabel?: string\n) {\n  const seriesLabel = translations.chart_labelSeries();\n  const groupLabel = translations.chart_labelGroup();\n  const valueLabel = translations.chart_labelValue();\n\n  const label =\n    accessibleLabel ||\n    `${seriesLabel}: ${series}, ${groupLabel}: ${group}, ${valueLabel}: ${value}`;\n\n  return generateAriaLabel(translations, label, {\n    isSelected: !isSelectionEnabled ? undefined : isSelected,\n    isDrillable\n  });\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { ChartItemData, ItemInfo, Info } from '../UNSAFE_visTypes/chart';\ntype isItemNavigableType = (seriesIndex: number, groupIndex: number) => boolean;\n\n/**\n * Returns the next navigable item in the same series.\n * @param seriesIndex\n * @param groupIndex\n * @param numOfGroups\n * @returns\n */\nexport function getNextItemInSeries(\n  info: ItemInfo,\n  viewportEndIndex: number,\n  isNavigable: isItemNavigableType\n): ItemInfo | undefined {\n  const { seriesIndex, groupIndex } = info;\n  const nextGroupIndex = groupIndex + 1;\n\n  if (nextGroupIndex > viewportEndIndex) {\n    return;\n  }\n\n  if (isNavigable(seriesIndex, nextGroupIndex)) {\n    return { seriesIndex, groupIndex: nextGroupIndex };\n  }\n\n  return getNextItemInSeries(\n    {\n      seriesIndex,\n      groupIndex: nextGroupIndex\n    },\n    viewportEndIndex,\n    isNavigable\n  );\n}\n\n/**\n * Returns the previous navigable item in the same series.\n * @param seriesIndex\n * @param itemIndex\n * @returns\n */\nexport function getPrevItemInSeries(\n  info: ItemInfo,\n  viewportStartIndex: number,\n  isNavigable: isItemNavigableType\n): ItemInfo | undefined {\n  const { seriesIndex, groupIndex } = info;\n  const prevGroupIndex = groupIndex - 1;\n\n  if (prevGroupIndex < viewportStartIndex) {\n    return;\n  }\n\n  if (isNavigable(seriesIndex, prevGroupIndex)) {\n    return { seriesIndex, groupIndex: prevGroupIndex };\n  }\n  if (prevGroupIndex === 0) {\n    return undefined;\n  }\n  return getPrevItemInSeries(\n    { seriesIndex, groupIndex: prevGroupIndex },\n    viewportStartIndex,\n    isNavigable\n  );\n}\n\n/**\n * Returns the previous navigable item in the same group.\n * @param seriesIndex\n * @param groupIndex\n * @param isNavigable\n */\nexport function getPrevItemInGroup(\n  info: ItemInfo,\n  isNavigable: isItemNavigableType\n): ItemInfo | undefined {\n  const { seriesIndex, groupIndex } = info;\n  const prevSeriesIndex = seriesIndex - 1;\n  if (prevSeriesIndex < 0) {\n    return;\n  }\n\n  if (isNavigable(prevSeriesIndex, groupIndex)) {\n    return { seriesIndex: prevSeriesIndex, groupIndex };\n  }\n\n  return getPrevItemInGroup(\n    {\n      seriesIndex: prevSeriesIndex,\n      groupIndex\n    },\n    isNavigable\n  );\n}\n\n/**\n * Returns the next navigable item in the same group.\n * @param seriesIndex\n * @param groupIndex\n * @param numOfSeries\n * @param numOfGroups\n */\nexport function getNextItemInGroup(\n  info: ItemInfo,\n  numOfSeries: number,\n  isNavigable: isItemNavigableType\n): ItemInfo | undefined {\n  const { seriesIndex, groupIndex } = info;\n  const nextSeriesIndex = seriesIndex + 1;\n\n  if (nextSeriesIndex >= numOfSeries) {\n    return;\n  }\n\n  if (isNavigable(nextSeriesIndex, groupIndex)) {\n    return { seriesIndex: nextSeriesIndex, groupIndex };\n  }\n\n  return getNextItemInGroup(\n    {\n      seriesIndex: nextSeriesIndex,\n      groupIndex\n    },\n    numOfSeries,\n    isNavigable\n  );\n}\n\n/**\n * Returns the next item in the group with higher value than the current item.\n * @param info The ItemInfo of current item.\n * @param numSeries The number of series in the group.\n * @param getDataItem The function that returns the chart data item.\n * @returns\n */\nexport function getNextHigherItemInGroup<K extends string | number, D extends ChartItemData<K>>(\n  info: ItemInfo,\n  numSeries: number,\n  getDataItem: (seriesIndex: number, groupIndex: number) => D | undefined,\n  isItemNavigable: isItemNavigableType\n) {\n  const { groupIndex, seriesIndex } = info;\n  const item = getDataItem(seriesIndex, groupIndex);\n  if (!item) {\n    return info;\n  }\n\n  let minValue = Number.MAX_VALUE;\n  let minIndex = seriesIndex;\n\n  for (let i = 0; i < numSeries; i++) {\n    const itemValue = getDataItem(i, groupIndex)?.value;\n    if (\n      !itemValue ||\n      itemValue < item.value ||\n      !isItemNavigable(i, groupIndex) ||\n      seriesIndex === i\n    ) {\n      continue;\n    }\n    if (itemValue < minValue) {\n      minValue = itemValue;\n      minIndex = i;\n    }\n  }\n  return { seriesIndex: minIndex, groupIndex };\n}\n\n/**\n * Returns the item info of the item in the group with lower value than the current item.\n * @param info The ItemInfo of the current item.\n * @param numSeries The number of series in the group.\n * @param getDataItem The function that returns the chart data item.\n * @returns\n */\nexport function getNextLowerItemInGroup<K extends string | number, D extends ChartItemData<K>>(\n  info: ItemInfo,\n  numSeries: number,\n  getDataItem: (seriesIndex: number, groupIndex: number) => D | undefined,\n  isItemNavigable: isItemNavigableType\n) {\n  const { groupIndex, seriesIndex } = info;\n  const item = getDataItem(seriesIndex, groupIndex);\n  if (!item) {\n    return info;\n  }\n\n  let maxValue = Number.MIN_VALUE;\n  let maxIndex = seriesIndex;\n\n  for (let i = 0; i < numSeries; i++) {\n    const itemValue = getDataItem(i, groupIndex)?.value;\n    if (\n      !itemValue ||\n      itemValue > item.value ||\n      !isItemNavigable(i, groupIndex) ||\n      seriesIndex === i\n    ) {\n      continue;\n    }\n\n    if (itemValue > maxValue) {\n      maxValue = itemValue;\n      maxIndex = i;\n    }\n  }\n  return { seriesIndex: maxIndex, groupIndex };\n}\n\nexport function getLineAreaChartNavUtil<K extends string | number, D extends ChartItemData<K>>(\n  getDataItem: (seriesIndex: number, groupIndex: number) => D | undefined,\n  numSeries: number,\n  viewportStartIndex: number,\n  viewportEndIndex: number,\n  isStacked: boolean,\n  isRtl: boolean,\n  isHoriz: boolean\n) {\n  const isItemNavigable = (seriesIndex: number, groupIndex: number) => {\n    const barItem = getDataItem(seriesIndex, groupIndex);\n    return Boolean(barItem);\n  };\n\n  const getNextChartItem = (\n    itemInfo: Info,\n    arrow: 'ArrowLeft' | 'ArrowRight' | 'ArrowDown' | 'ArrowUp'\n  ): Info => {\n    let newInfo: Info | undefined;\n\n    const info = {\n      groupIndex: itemInfo.groupIndex!,\n      seriesIndex: itemInfo.seriesIndex!\n    };\n\n    if (info.groupIndex < viewportStartIndex) {\n      info.groupIndex = viewportStartIndex;\n      return info;\n    } else if (info.groupIndex > viewportEndIndex) {\n      info.groupIndex = viewportEndIndex;\n      return info;\n    }\n\n    if (arrow === 'ArrowLeft') {\n      if (!isHoriz) {\n        newInfo = isRtl\n          ? getNextItemInSeries(info, viewportEndIndex, isItemNavigable)\n          : getPrevItemInSeries(info, viewportStartIndex, isItemNavigable);\n      } else {\n        newInfo = isRtl\n          ? getNextHigherItemInGroup<K, D>(info, numSeries, getDataItem, isItemNavigable)\n          : getNextLowerItemInGroup<K, D>(info, numSeries, getDataItem, isItemNavigable);\n      }\n    } else if (arrow === 'ArrowRight') {\n      if (!isHoriz) {\n        newInfo = isRtl\n          ? getPrevItemInSeries(info, viewportStartIndex, isItemNavigable)\n          : getNextItemInSeries(info, viewportEndIndex, isItemNavigable);\n      } else {\n        newInfo = !isRtl\n          ? getNextHigherItemInGroup<K, D>(info, numSeries, getDataItem, isItemNavigable)\n          : getNextLowerItemInGroup<K, D>(info, numSeries, getDataItem, isItemNavigable);\n      }\n    } else if (arrow === 'ArrowDown') {\n      if (isHoriz) {\n        newInfo = getNextItemInSeries(info, viewportEndIndex, isItemNavigable);\n      } else {\n        if (isStacked) {\n          newInfo = getPrevItemInGroup(info, isItemNavigable);\n        } else {\n          newInfo = getNextLowerItemInGroup<K, D>(info, numSeries, getDataItem, isItemNavigable);\n        }\n      }\n    } else {\n      if (isHoriz) {\n        newInfo = getPrevItemInSeries(info, viewportStartIndex, isItemNavigable);\n      } else {\n        if (isStacked) {\n          newInfo = getNextItemInGroup(info, numSeries, isItemNavigable);\n        } else {\n          newInfo = getNextHigherItemInGroup<K, D>(info, numSeries, getDataItem, isItemNavigable);\n        }\n      }\n    }\n    return newInfo || info;\n  };\n\n  return getNextChartItem;\n}\n","/**\n * @license\n * Copyright (c) 2008 %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { Point } from './lineUtils';\nimport { curveThroughPoints } from './pathUtils';\n\n/**\n * Returns a straight area path command.\n * @param {array} lineSegmentCoords Polyline top points array.\n * @param {array} bottomCoords Polyline bottom points array.\n * @return {string} Straight area path commands.\n */\nexport function getStraightAreaPath(lineSegmentCoords: Point[], bottomCoords: Point[]) {\n  // Create the path data string\n  let pathData;\n  if (lineSegmentCoords.length > 0) {\n    pathData =\n      lineSegmentCoords\n        .map((lineSegmentCoord, index) => {\n          return `${index === 0 ? 'M' : 'L'} ${lineSegmentCoord[0]} ${lineSegmentCoord[1]}`;\n        })\n        .join(' ') +\n      [...bottomCoords]\n        .reverse()\n        .map((bottomCoord) => {\n          return `L ${bottomCoord[0]} ${bottomCoord[1]}`;\n        })\n        .join(' ') +\n      'Z';\n  }\n  return pathData;\n}\n\n/**\n * Returns a curved area path command, based on cubic hermite splines, that goes through the points in the points array.\n * @param {array} lineSegmentCoords Polyline top points array.\n * @param {array} bottomCoords Polyline bottom points array.\n * @param {boolean} connectWithLine Whether the first point is reached using lineTo. Otherwise, moveTo is used.\n * @param {string} splineType The spline type.\n * @return {string} Curved area path commands.\n */\nexport function getCurveAreaPath(\n  lineSegmentCoords: Point[],\n  bottomCoords: Point[],\n  connectWithLine: boolean,\n  splineType: string,\n  isBottomSegmentCurved?: boolean\n) {\n  let pathData;\n  if (lineSegmentCoords.length > 0) {\n    if (!isBottomSegmentCurved) {\n      pathData =\n        curveThroughPoints(lineSegmentCoords, connectWithLine, splineType) +\n        [...bottomCoords]\n          .reverse()\n          .map((bottomCoord) => {\n            return `L ${bottomCoord[0]} ${bottomCoord[1]}`;\n          })\n          .join(' ') +\n        'Z';\n    } else {\n      pathData =\n        curveThroughPoints(lineSegmentCoords, false, splineType) +\n        ' ' +\n        curveThroughPoints([...bottomCoords].reverse(), true, splineType) +\n        ' Z';\n    }\n  }\n  return pathData;\n}\n","/**\n * @license\n * Copyright (c) 2008 %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { MarkerShapes } from '../UNSAFE_visTypes/common';\nimport { Point } from '../PRIVATE_visSVGUtils';\nimport { curveThroughPoints } from '../PRIVATE_visSVGUtils/pathUtils';\nimport { Scale, ChartItemData, Group } from '../UNSAFE_visTypes/chart';\nimport { ColorProps } from '../UNSAFE_interpolations/colors';\nimport { colorSchemeVars } from '../../Common/themes/themeContract.css';\nimport { rgb, rgba } from '../../UNSAFE_Theme';\nimport { getStraightAreaPath, getCurveAreaPath } from '../PRIVATE_visSVGUtils/areaUtils';\nimport { getGroupCenterCoord } from '../../utils/PRIVATE_chartUtils/layoutUtils';\nimport { LineAreaItem } from '../../UNSAFE_LineAreaChart/lineAreaChart.types';\n\nexport function getCmdsForArea(\n  lineSegmentCoords: Point[],\n  bottomCoords: Point[],\n  areaType: 'straight' | 'curved',\n  isHoriz: boolean,\n  isBottomSegmentCurved: boolean\n) {\n  if (areaType === 'straight') {\n    return getStraightAreaPath(lineSegmentCoords, bottomCoords);\n  }\n  return getCurveAreaPath(\n    lineSegmentCoords,\n    bottomCoords,\n    false,\n    isHoriz ? 'mh' : 'mv',\n    isBottomSegmentCurved\n  );\n}\n\nexport function getCmdsForLine(\n  lineSegmentCoords: Point[],\n  lineType: 'straight' | 'curved',\n  isHoriz: boolean\n) {\n  if (lineType === 'straight') {\n    return lineSegmentCoords.join(' ');\n  }\n  return curveThroughPoints(lineSegmentCoords, false, isHoriz ? 'mh' : 'mv');\n}\n/**\n * Returns the cumulative series for stacked chart.\n */\nexport function getCumulativeSeries<K extends string | number, D extends ChartItemData<K>>(\n  numSeries: number,\n  numGroups: number,\n  getDataItem: (seriesIndex: number, groupIndex: number) => D | undefined,\n  hiddenIds: Set<number | string>,\n  isLog: boolean\n) {\n  const series: number[][] = [];\n  for (let seriesIndex = 0; seriesIndex < numSeries; seriesIndex += 1) {\n    const currentSeries: number[] = [];\n    const prevSeries = series[seriesIndex - 1];\n    for (let groupIndex = 0; groupIndex < numGroups; groupIndex += 1) {\n      const item = getDataItem(seriesIndex, groupIndex);\n      if (!item || hiddenIds?.has(item.id) || (isLog && item.value <= 0)) {\n        continue;\n      }\n      if (seriesIndex) {\n        currentSeries[groupIndex] = item.value + prevSeries[groupIndex];\n      } else {\n        currentSeries[groupIndex] = item.value;\n      }\n    }\n    series.push(currentSeries);\n  }\n  return series;\n}\n\n/**\n * Returns the series data.\n */\nexport function getSeriesData<K extends string | number, D extends ChartItemData<K>>(\n  numSeries: number,\n  numGroups: number,\n  getDataItem: (seriesIndex: number, groupIndex: number) => D | undefined,\n  hiddenIds: Set<number | string>,\n  isLog: boolean\n) {\n  const series: number[][] = [];\n  for (let seriesIndex = 0; seriesIndex < numSeries; seriesIndex += 1) {\n    const currentSeries: number[] = [];\n    for (let groupIndex = 0; groupIndex < numGroups; groupIndex += 1) {\n      const item = getDataItem(seriesIndex, groupIndex);\n      if (!item || hiddenIds?.has(item.id) || (isLog && item.value <= 0)) {\n        continue;\n      }\n      currentSeries[groupIndex] = item.value;\n    }\n    series.push(currentSeries);\n  }\n  return series;\n}\n\n/**\n * Returns the markertype order.\n */\nexport function getMarkers(): MarkerShapes[] {\n  return ['square', 'circle', 'diamond', 'plus', 'triangleDown', 'triangleUp'];\n}\n\n/**\n * Returns the marker fill and stroke depending on the state.\n */\nexport function getMarkerFillAndStroke( // TODO : JET-62244 - Replace getMarkerFillAndStroke function with classes.\n  isMarkerDisplayed: boolean,\n  isSelectionEnabled: boolean,\n  isHovered: boolean,\n  isFocused: boolean,\n  isSelected: boolean,\n  seriesColor: ColorProps['color'],\n  itemColor?: ColorProps['color']\n) {\n  let fill;\n  let stroke;\n  let outerStroke;\n\n  if (isSelectionEnabled) {\n    if (isSelected) {\n      if (isMarkerDisplayed) {\n        // TODO: settle on one visual for selected markers: \n        // Selected effect when markers are turned on\n        fill = itemColor || seriesColor;\n        outerStroke = rgb(colorSchemeVars.palette.neutral[130]);\n        stroke = rgb(colorSchemeVars.palette.neutral[0]);\n      } else {\n        // Selected effect when markers are not turned on\n        fill = rgb(colorSchemeVars.palette.neutral[0]);\n        if (isHovered || isFocused) {\n          stroke = itemColor || seriesColor;\n        } else {\n          stroke = rgb(colorSchemeVars.palette.neutral[130]);\n        }\n      }\n    } else if (isHovered || isFocused) {\n      stroke = itemColor || seriesColor;\n      fill = rgb(colorSchemeVars.palette.neutral[0]);\n    } else {\n      if (isMarkerDisplayed) {\n        fill = itemColor || seriesColor;\n        stroke = rgb(colorSchemeVars.palette.neutral[0]);\n      } else {\n        fill = rgba(colorSchemeVars.palette.neutral[0], 0);\n        stroke = rgba(colorSchemeVars.palette.neutral[0], 0);\n      }\n    }\n  } else if (isMarkerDisplayed) {\n    fill = itemColor || seriesColor;\n    stroke = rgb(colorSchemeVars.palette.neutral[0]);\n  } else {\n    stroke = isFocused ? itemColor || seriesColor : rgba(colorSchemeVars.palette.neutral[0], 0);\n    fill = rgba(colorSchemeVars.palette.neutral[0], 0);\n  }\n  return { fill, stroke, outerStroke };\n}\n\n/**\n * Returns the coordinates of line or area based on orientation and size of the chart.\n */\nexport function getLineAreaSegments<K extends string | number, D extends LineAreaItem<K>>(\n  yScale: Scale,\n  xScale: Scale,\n  data: number[],\n  startIndex: number,\n  endIndex: number,\n  isHorizontal: boolean,\n  isLog: boolean,\n  groups: Group[],\n  seriesIndex: number,\n  getDataItem: (seriesIndex: number, groupIndex: number) => D | undefined,\n  timeAxisType?: 'enabled' | 'skipGaps' | 'mixedFrequency'\n): Point[][] {\n  const segments: Point[][] = [];\n  let currentPath: Point[] = [];\n\n  for (let groupIndex = startIndex; groupIndex < endIndex + 1; groupIndex += 1) {\n    const item = data[groupIndex];\n\n    if (item == null || (isLog && item <= 0)) {\n      segments.push(currentPath);\n      currentPath = [];\n      continue;\n    }\n    const x = isHorizontal\n      ? yScale.transform(item)\n      : getGroupCenterCoord<K, D>(\n          groups[groupIndex],\n          groupIndex,\n          xScale,\n          getDataItem(seriesIndex, groupIndex)!,\n          timeAxisType\n        );\n    const y = isHorizontal\n      ? getGroupCenterCoord<K, D>(\n          groups[groupIndex],\n          groupIndex,\n          xScale,\n          getDataItem(seriesIndex, groupIndex)!,\n          timeAxisType\n        )\n      : yScale.transform(item);\n    currentPath.push([x, y]);\n    if (groupIndex === endIndex) {\n      segments.push(currentPath);\n    }\n  }\n  return segments;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { getColorRamp } from '../../utils/UNSAFE_visUtils';\nimport { BarItemData, BarSeriesData } from '../../UNSAFE_BarChart/barChart.types';\nimport { LineAreaItem, LineAreaSeriesData } from '../../UNSAFE_LineAreaChart/lineAreaChart.types';\nimport { getMarkers } from './utils';\n\nexport function getItemColor<K, D>(\n  seriesIndex: number,\n  groupIndex: number,\n  series: (LineAreaSeriesData<K, D> | BarSeriesData<K, D>)[],\n  getDataItem: (\n    seriesIndex: number,\n    groupIndex: number\n  ) => LineAreaItem<K> | BarItemData<K> | undefined\n) {\n  const item = getDataItem(seriesIndex, groupIndex);\n  if (item?.color) {\n    return item.color;\n  }\n\n  if ((item as LineAreaItem<K>).markerColor) {\n    return (item as LineAreaItem<K>).markerColor;\n  }\n  const itemSeries = series[seriesIndex] as LineAreaSeriesData<K, D>;\n\n  const colors = getColorRamp();\n  return (\n    itemSeries.color ||\n    itemSeries.lineColor ||\n    itemSeries.areaColor ||\n    colors[seriesIndex % colors.length]\n  );\n}\n\nexport function getMarkerType<K>(\n  seriesIndex: number,\n  groupIndex: number,\n  chartType: 'bar' | 'lineWithArea',\n  getDataItem: (\n    seriesIndex: number,\n    groupIndex: number\n  ) => LineAreaItem<K> | BarItemData<K> | undefined\n) {\n  if (chartType === 'bar') {\n    return 'circle';\n  }\n  const item = getDataItem(seriesIndex, groupIndex);\n  if ((item as LineAreaItem<K>).markerType) {\n    return (item as LineAreaItem<K>).markerType;\n  }\n  const shapes = getMarkers();\n  return shapes[seriesIndex % shapes.length];\n}\n"],"names":["generateAriaLabel","curveThroughPoints","rgb","colorSchemeVars","rgba","getGroupCenterCoord","getColorRamp"],"mappings":"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"}