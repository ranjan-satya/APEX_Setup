{"version":3,"file":"useDetectHorizontalOverflow-9ae81c31.js","sources":["../../src/hooks/PRIVATE_useDetectHorizontalOverflow/useDetectHorizontalOverflow.ts"],"sourcesContent":["import { RefObject } from 'preact';\nimport { useState, useEffect } from 'preact/hooks';\n\ntype ElemDim<K extends string | number> = {\n  itemKey: K | undefined;\n  cumulativeWidth: number | undefined;\n};\n\ntype CallBack<K extends string | number> = (key: K) => number;\nexport type useDetectOverflowProps<K extends string | number> = {\n  rootRef: RefObject<HTMLDivElement>;\n  getWidth: CallBack<K>;\n  keysArray: (K | undefined)[];\n};\n\n/**\n * Implements overflow detection and calculation\n */\nexport function useDetectHorizontalOverflow<K extends string | number>(\n  options: useDetectOverflowProps<K>\n) {\n  const { rootRef, getWidth, keysArray } = options;\n  const [visibleItemKeys, setVisibleItemKeys] = useState<(K | undefined)[]>(keysArray);\n  const [overflowItemKeys, setOverflowingItemKeys] = useState<(K | undefined)[]>();\n\n  useEffect(() => {\n    let resizeObserver: ResizeObserver;\n    if (rootRef.current && keysArray && keysArray.length > 0) {\n      const itemDimensions: ElemDim<K>[] = [];\n      let sumofItemsWidth = 0;\n      keysArray.forEach((itemKey) => {\n        sumofItemsWidth += getWidth(itemKey as K);\n        const elemDimension = {\n          itemKey: itemKey,\n          cumulativeWidth: sumofItemsWidth\n        };\n        itemDimensions.push(elemDimension as ElemDim<K>);\n      });\n\n      resizeObserver = new ResizeObserver(() => {\n        const container = rootRef.current;\n        const arr = itemDimensions?.map((item) => item.cumulativeWidth) as number[];\n        if (\n          container &&\n          arr &&\n          (container.clientWidth < arr[arr.length - 1] ||\n            container.clientWidth < container.scrollWidth)\n        ) {\n          const { closestEntry, closestIndex } = searchClosest(arr, container?.clientWidth);\n          if (closestEntry && closestIndex) {\n            setVisibleItemKeys(keysArray.slice(0, closestIndex));\n            setOverflowingItemKeys(keysArray?.slice(closestIndex));\n          }\n        } else {\n          setVisibleItemKeys(keysArray);\n          setOverflowingItemKeys([]);\n        }\n      });\n      resizeObserver.observe(rootRef?.current as Element);\n    }\n\n    return () => {\n      if (resizeObserver) {\n        resizeObserver.disconnect();\n      }\n    };\n  }, [keysArray, getWidth, rootRef]);\n\n  return {\n    visibleItemKeys,\n    overflowItemKeys\n  } as const;\n}\n\nconst searchClosest = (\n  arr: number[] | undefined,\n  searchValue: number | undefined | null\n): { closestEntry: number | null; closestIndex: number | null } => {\n  {\n    if (arr != null && searchValue != null) {\n      let left = 0;\n      let right = arr.length - 1;\n      let closestEntry: number | null = null;\n      let closestIndex: number | null = null;\n      while (left <= right && left < arr.length && right > -1) {\n        const mid = Math.floor((left + right) / 2);\n        const midEntry = arr[mid];\n        if (midEntry === searchValue) {\n          return { closestEntry: midEntry!, closestIndex: mid! };\n        } else if (midEntry < searchValue) {\n          left = mid + 1;\n        } else {\n          right = mid - 1;\n        }\n\n        if (\n          !closestEntry ||\n          Math.abs(searchValue - midEntry) < Math.abs(searchValue - closestEntry)\n        ) {\n          closestEntry = midEntry as number;\n          closestIndex = mid as number;\n        }\n      }\n      return { closestEntry: closestEntry!, closestIndex: closestIndex! };\n    } else return { closestEntry: null, closestIndex: null };\n  }\n};\n"],"names":["searchClosest","arr","searchValue","left","right","length","closestEntry","closestIndex","mid","Math","floor","midEntry","abs","options","rootRef","getWidth","keysArray","visibleItemKeys","setVisibleItemKeys","useState","overflowItemKeys","setOverflowingItemKeys","useEffect","resizeObserver","current","itemDimensions","sumofItemsWidth","forEach","itemKey","elemDimension","cumulativeWidth","push","ResizeObserver","container","map","item","clientWidth","scrollWidth","slice","observe","disconnect"],"mappings":"8DA0EA,MAAMA,EAAgB,CACpBC,EACAC,KAGE,GAAW,MAAPD,GAA8B,MAAfC,EAAqB,CACtC,IAAIC,EAAO,EACPC,EAAQH,EAAII,OAAS,EACrBC,EAA8B,KAC9BC,EAA8B,KAClC,KAAOJ,GAAQC,GAASD,EAAOF,EAAII,QAAUD,GAAS,GAAG,CACvD,MAAMI,EAAMC,KAAKC,OAAOP,EAAOC,GAAS,GAClCO,EAAWV,EAAIO,GACrB,GAAIG,IAAaT,EACf,MAAO,CAAEI,aAAcK,EAAWJ,aAAcC,GACvCG,EAAWT,EACpBC,EAAOK,EAAM,EAEbJ,EAAQI,EAAM,IAIbF,GACDG,KAAKG,IAAIV,EAAcS,GAAYF,KAAKG,IAAIV,EAAcI,MAE1DA,EAAeK,EACfJ,EAAeC,EAElB,CACD,MAAO,CAAEF,aAAcA,EAAeC,aAAcA,EACrD,CAAM,MAAO,CAAED,aAAc,KAAMC,aAAc,KACnD,gCAvFG,SACJM,GAEA,MAAMC,QAAEA,EAAOC,SAAEA,EAAQC,UAAEA,GAAcH,GAClCI,EAAiBC,GAAsBC,EAAQA,SAAoBH,IACnEI,EAAkBC,GAA0BF,EAAQA,WA6C3D,OA3CAG,EAAAA,WAAU,KACR,IAAIC,EACJ,GAAIT,EAAQU,SAAWR,GAAaA,EAAUX,OAAS,EAAG,CACxD,MAAMoB,EAA+B,GACrC,IAAIC,EAAkB,EACtBV,EAAUW,SAASC,IACjBF,GAAmBX,EAASa,GAC5B,MAAMC,EAAgB,CACpBD,QAASA,EACTE,gBAAiBJ,GAEnBD,EAAeM,KAAKF,EAA4B,IAGlDN,EAAiB,IAAIS,gBAAe,KAClC,MAAMC,EAAYnB,EAAQU,QACpBvB,EAAMwB,GAAgBS,KAAKC,GAASA,EAAKL,kBAC/C,GACEG,GACAhC,IACCgC,EAAUG,YAAcnC,EAAIA,EAAII,OAAS,IACxC4B,EAAUG,YAAcH,EAAUI,aACpC,CACA,MAAM/B,aAAEA,EAAYC,aAAEA,GAAiBP,EAAcC,EAAKgC,GAAWG,aACjE9B,GAAgBC,IAClBW,EAAmBF,EAAUsB,MAAM,EAAG/B,IACtCc,EAAuBL,GAAWsB,MAAM/B,IAE3C,MACCW,EAAmBF,GACnBK,EAAuB,GACxB,IAEHE,EAAegB,QAAQzB,GAASU,QACjC,CAED,MAAO,KACDD,GACFA,EAAeiB,YAChB,CACF,GACA,CAACxB,EAAWD,EAAUD,IAElB,CACLG,kBACAG,mBAEJ"}