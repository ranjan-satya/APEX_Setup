{"version":3,"file":"useCellNavigation-37e0539a.js","sources":["../../src/UNSAFE_DatePicker/useFocusableCell.ts","../../src/UNSAFE_DatePicker/useCellNavigation.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { useTabbableMode } from '#hooks/UNSAFE_useTabbableMode';\nimport { useLayoutEffect, useRef } from 'preact/compat';\n\ntype UseFocusableCellProps = {\n  /**\n   * Specifies if this cell is the one that will be focused when\n   * one tabs into the grid view.\n   */\n  isFocusable: boolean;\n\n  /**\n   * Specifies whether or not the cell is currently focused.\n   */\n  isFocused: boolean;\n};\n\n/**\n * A custom hook that handles focus for a month or year cell.\n */\nexport const useFocusableCell = <T extends HTMLElement = HTMLElement>({\n  isFocusable,\n  isFocused\n}: UseFocusableCellProps) => {\n  const cellRef = useRef<T>(null);\n  const { isTabbable } = useTabbableMode();\n\n  // Using layout effect here to set the focus as we want to focus the element\n  // before the browser has a chance to paint. This way the browser don't have to\n  // repaint the focused state.\n  useLayoutEffect(() => {\n    if (isFocusable && isFocused) {\n      cellRef.current?.focus();\n    }\n  }, [isFocusable, isFocused]);\n\n  return { ref: cellRef, tabIndex: isFocusable && isTabbable ? 0 : -1 };\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { useUser } from '#hooks/UNSAFE_useUser';\nimport { useCallback } from 'preact/compat';\n\ntype SupportedKeyBindings =\n  | 'ArrowLeft'\n  | 'ArrowRight'\n  | 'ArrowUp'\n  | 'ArrowDown'\n  | 'End'\n  | 'Home'\n  | 'PageUp'\n  | 'PageDown'\n  | 'ShiftPageUp'\n  | 'ShiftPageDown'\n  | 'CtrlAltT';\ntype NavigationValue<T extends string> = T | { ltr: T; rtl: T };\ntype NavigationMap<T extends string> = Partial<Record<SupportedKeyBindings, NavigationValue<T>>>;\n\ntype UseCellNavigationProps<Payload extends object, Navigation extends string> = {\n  /**\n   * Payload for the callbacks from this cell.\n   */\n  payload: Payload;\n\n  /**\n   * An object that maps the key codes to the direction of navigation. The onNavigation\n   * callback will be invoked only for the key codes provided in the map and specifies the\n   * direction as provided in the value.\n   */\n  navigationMap: NavigationMap<Navigation>;\n\n  /**\n   * A callback that will be invoked when a selection action is performed on the DatePicker cell.\n   * @param payload The provided payload.\n   */\n  onAction: (payload: Payload) => void;\n\n  /**\n   * A callback that will be invoked when a navigation action is performed on the DatePicker cell.\n   * @param details The object specifying the direction of the navigation performed and the payload.\n   */\n  onNavigation: (details: { direction: Navigation } & Payload) => void;\n};\n\n/**\n * A custom hook that handles navigation for a DatePicker cell.\n */\nexport const useCellNavigation = <T extends object, U extends string>({\n  navigationMap,\n  payload,\n  onAction,\n  onNavigation\n}: UseCellNavigationProps<T, U>) => {\n  const { direction } = useUser();\n  const handleSelection = useCallback(() => {\n    onAction(payload);\n  }, [payload, onAction]);\n\n  const handleKeyDown = useCallback<NonNullable<GlobalEventHandlers['onkeydown']>>(\n    (event) => {\n      const killEvent = () => {\n        event.preventDefault();\n        event.stopPropagation();\n      };\n\n      if (['Enter', 'Space'].includes(event.code)) {\n        // since we are handling the event, we need to kill the event here\n        // so that no other action is performed\n        killEvent();\n        handleSelection();\n        return;\n      }\n\n      // Handle Ctrl + Alt + T\n      if (event.code === 'KeyT' && event.ctrlKey && event.altKey) {\n        const navigationDirection = navigationMap['CtrlAltT'];\n        if (navigationDirection !== undefined) {\n          // since we are handling the event, we need to kill the event here\n          // so that no other action is performed\n          killEvent();\n          onNavigation({\n            direction: getLogicalValue(navigationDirection, direction),\n            ...payload\n          });\n        }\n      }\n\n      const { key, shiftKey } = event;\n\n      switch (key) {\n        // since we are handling the event, we need to kill the event here\n        // so that no other action is performed\n        case 'ArrowLeft':\n        case 'ArrowRight':\n        case 'ArrowUp':\n        case 'ArrowDown':\n        case 'End':\n        case 'Home':\n        case 'PageUp':\n        case 'PageDown':\n          const mapKey: SupportedKeyBindings =\n            shiftKey && (key === 'PageUp' || key === 'PageDown') ? `Shift${key}` : key;\n          if (navigationMap[mapKey] !== undefined) {\n            killEvent();\n            const navigationDirection = navigationMap[mapKey]!;\n            onNavigation({\n              direction: getLogicalValue(navigationDirection, direction),\n              ...payload\n            });\n          }\n      }\n    },\n    [direction, handleSelection, navigationMap, onNavigation, payload]\n  );\n\n  return {\n    onClick: handleSelection,\n    onKeyDown: handleKeyDown\n  };\n};\n\n/**\n * Determines the logical value for the navigation direction.\n * @param value The value representing the navigation direction\n * @param dir The reading direction from the user preferences\n * @returns The logical navigation direction\n */\nconst getLogicalValue = <T extends string>(value: NavigationValue<T>, dir: 'ltr' | 'rtl') =>\n  typeof value === 'string' ? value : value[dir];\n"],"names":["getLogicalValue","value","dir","navigationMap","payload","onAction","onNavigation","direction","useUser","handleSelection","useCallback","handleKeyDown","event","killEvent","preventDefault","stopPropagation","includes","code","ctrlKey","altKey","navigationDirection","undefined","key","shiftKey","mapKey","onClick","onKeyDown","isFocusable","isFocused","cellRef","useRef","isTabbable","useTabbableMode","useLayoutEffect","current","focus","ref","tabIndex"],"mappings":"wJA0Ba,MC4GPA,EAAkB,CAAmBC,EAA2BC,IACnD,iBAAVD,EAAqBA,EAAQA,EAAMC,uBAjFX,EAC/BC,gBACAC,UACAC,WACAC,mBAEA,MAAMC,UAAEA,GAAcC,EAAAA,UAChBC,EAAkBC,EAAAA,aAAY,KAClCL,EAASD,EAAQ,GAChB,CAACA,EAASC,IAEPM,EAAgBD,eACnBE,IACC,MAAMC,EAAY,KAChBD,EAAME,iBACNF,EAAMG,iBAAiB,EAGzB,GAAI,CAAC,QAAS,SAASC,SAASJ,EAAMK,MAKpC,OAFAJ,SACAJ,IAKF,GAAmB,SAAfG,EAAMK,MAAmBL,EAAMM,SAAWN,EAAMO,OAAQ,CAC1D,MAAMC,EAAsBjB,EAAwB,cACxBkB,IAAxBD,IAGFP,IACAP,EAAa,CACXC,UAAWP,EAAgBoB,EAAqBb,MAC7CH,IAGR,CAED,MAAMkB,IAAEA,EAAGC,SAAEA,GAAaX,EAE1B,OAAQU,GAGN,IAAK,YACL,IAAK,aACL,IAAK,UACL,IAAK,YACL,IAAK,MACL,IAAK,OACL,IAAK,SACL,IAAK,WACH,MAAME,GACJD,GAAqB,WAARD,GAA4B,aAARA,EAAsCA,EAAhB,QAAQA,IACjE,QAA8BD,IAA1BlB,EAAcqB,GAAuB,CACvCX,IACA,MAAMO,EAAsBjB,EAAcqB,GAC1ClB,EAAa,CACXC,UAAWP,EAAgBoB,EAAqBb,MAC7CH,GAEN,EACJ,GAEH,CAACG,EAAWE,EAAiBN,EAAeG,EAAcF,IAG5D,MAAO,CACLqB,QAAShB,EACTiB,UAAWf,EACZ,qBDnG6B,EAC9BgB,cACAC,gBAEA,MAAMC,EAAUC,SAAU,OACpBC,WAAEA,GAAeC,EAAAA,kBAWvB,OANAC,EAAAA,iBAAgB,KACVN,GAAeC,GACjBC,EAAQK,SAASC,OAClB,GACA,CAACR,EAAaC,IAEV,CAAEQ,IAAKP,EAASQ,SAAUV,GAAeI,EAAa,GAAK,EAAG"}