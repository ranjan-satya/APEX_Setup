{"version":3,"file":"LineAreaChart-2057f8b4.js","sources":["../../src/UNSAFE_LineAreaChart/AreaSeries.tsx","../../src/PRIVATE_Chart/Markers.tsx","../../src/UNSAFE_LineAreaChart/LineSeries.tsx","../../src/UNSAFE_LineAreaChart/LineAreaChart.tsx"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { ColorProps } from '../utils/UNSAFE_interpolations/colors';\nimport { getCmdsForArea } from '../utils/PRIVATE_chartUtils/utils';\nimport { Point } from '../utils/PRIVATE_visSVGUtils';\nimport { Scale } from '../utils/UNSAFE_visTypes/chart';\nimport { dvtVars } from '../Common/themes/themeContract.css';\n\ntype AreaSeriesProps = {\n  yScale: Scale;\n  color: ColorProps['color'];\n  lineType?: 'straight' | 'curved';\n  isHorizontal: boolean;\n  isLog: boolean;\n  areaColorOpacity: number;\n  lineSegmentCoords: Point[][];\n  bottomCoords?: Point[];\n  isHighlighted: boolean;\n  isBottomSegmentCurved: boolean;\n  seriesIndex: number;\n};\n\nexport function AreaSeries({\n  yScale,\n  lineType = 'straight',\n  color,\n  isHorizontal,\n  isLog,\n  areaColorOpacity,\n  lineSegmentCoords,\n  bottomCoords,\n  isHighlighted,\n  isBottomSegmentCurved,\n  seriesIndex\n}: AreaSeriesProps) {\n  const style = {\n    fill: color,\n    opacity: isHighlighted\n      ? areaColorOpacity\n      : `calc(${dvtVars.dimmedOpacity} * ${areaColorOpacity})`\n  };\n\n  return (\n    <>\n      {lineSegmentCoords.map((lineSegmentCoords: Point[]) => {\n        let baseCoords;\n        if (bottomCoords) {\n          // custom bottom coords. eg: top of last series in stacked area\n          baseCoords = bottomCoords;\n        } else {\n          // TODO: make this more generic when we support apps setting baseline\n          // for log assume domain min is the baseline, otherwise use 0 baseline\n          const baselineCoord = yScale.transform(isLog ? yScale.domain()[0] : 0);\n          baseCoords = isHorizontal\n            ? ([\n                [baselineCoord, lineSegmentCoords[0][1]],\n                [baselineCoord, lineSegmentCoords[lineSegmentCoords.length - 1][1]]\n              ] as Point[])\n            : ([\n                [lineSegmentCoords[0][0], baselineCoord],\n                [lineSegmentCoords[lineSegmentCoords.length - 1][0], baselineCoord]\n              ] as Point[]);\n        }\n        const cmds = getCmdsForArea(\n          lineSegmentCoords,\n          baseCoords,\n          lineType,\n          isHorizontal,\n          isBottomSegmentCurved\n        );\n        return (\n          <path d={cmds} style={style} data-oj-series-index={seriesIndex} data-oj-object={'area'} />\n        );\n      })}\n    </>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { ColorProps } from '../utils/UNSAFE_interpolations/colors';\nimport { LineAreaItem } from '../UNSAFE_LineAreaChart/lineAreaChart.types';\nimport { Marker, MARKER_PADDING } from '../PRIVATE_SvgShapes';\nimport { MarkerShapes } from '../utils/UNSAFE_visTypes/common';\nimport { getGroupCenterCoord } from '../utils/PRIVATE_chartUtils/layoutUtils';\nimport { ChartSeriesData, Scale, Group } from '../utils/UNSAFE_visTypes/chart';\nimport { getMarkerFillAndStroke } from '../utils/PRIVATE_chartUtils/utils';\nimport { useTranslationBundle } from '../hooks/UNSAFE_useTranslationBundle';\nimport type { BundleType } from '../resources/nls/bundle';\nimport { getItemAriaLabel } from '../utils/PRIVATE_chartUtils/accUtils';\nimport { supportsMobileScreenReader } from '../utils/UNSAFE_visUtils';\n\nconst MARKER_DEFAULT_SIZE = 10;\ntype MarkersProps<K, D> = {\n  yScale: Scale;\n  xScale: Scale;\n  startIndex: number;\n  endIndex: number;\n  seriesIndex: number;\n  series: ChartSeriesData<K, D>;\n  markerType: MarkerShapes;\n  data: number[];\n  color: ColorProps['color'];\n  groups: Group[];\n  focusedItemIndex?: number;\n  isSelectionEnabled: boolean;\n  hoveredItemIndex?: number;\n  selectedIds?: Set<string | number>;\n  hiddenIds?: Set<string | number>;\n  activeId?: string;\n  orientation: 'horizontal' | 'vertical';\n  isDrillEnabled: boolean;\n  isLog: boolean;\n  isPointInsideMarquee: ((id: K, point: { x: number; y: number }) => boolean) | undefined;\n  getDataItem: (seriesIndex: number, groupIndex: number) => D | undefined;\n  timeAxisType?: 'enabled' | 'skipGaps' | 'mixedFrequency';\n};\n\nexport function Markers<K extends string | number, D extends LineAreaItem<K>>({\n  yScale,\n  xScale,\n  color,\n  seriesIndex,\n  startIndex,\n  endIndex,\n  hiddenIds,\n  selectedIds,\n  orientation,\n  isLog,\n  data,\n  markerType,\n  getDataItem,\n  focusedItemIndex,\n  hoveredItemIndex,\n  isDrillEnabled,\n  activeId,\n  isSelectionEnabled,\n  timeAxisType,\n  isPointInsideMarquee,\n  series,\n  groups\n}: MarkersProps<K, D>) {\n  const isHoriz = orientation === 'horizontal';\n  const items = [];\n\n  const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\n\n  for (let groupIndex = startIndex; groupIndex < endIndex + 1; groupIndex++) {\n    const item = getDataItem(seriesIndex, groupIndex);\n    const value = data[groupIndex];\n    if (!item || value == null || hiddenIds?.has(item.id) || (isLog && value <= 0)) {\n      continue;\n    }\n    const x = isHoriz\n      ? yScale.transform(value)\n      : getGroupCenterCoord<K, D>(groups[groupIndex], groupIndex, xScale, item, timeAxisType);\n    const y = isHoriz\n      ? getGroupCenterCoord<K, D>(groups[groupIndex], groupIndex, xScale, item, timeAxisType)\n      : yScale.transform(value);\n    const isFocused = focusedItemIndex === groupIndex;\n    const isHovered = hoveredItemIndex === groupIndex;\n    const isSelected = !!(selectedIds?.has(item.id!) || isPointInsideMarquee?.(item.id, { x, y }));\n    const isDrillable = item.drilling === 'on' || (item.drilling != 'off' && isDrillEnabled);\n    const { fill, stroke, outerStroke } = getMarkerFillAndStroke(\n      !!item.isMarkerDisplayed,\n      isSelectionEnabled,\n      isHovered,\n      isFocused,\n      isSelected,\n      color,\n      item.markerColor\n    );\n    const itemMarkerType = item.isMarkerDisplayed ? item.markerType || markerType : markerType;\n    const isActive = isFocused || isHovered;\n    const ariaLabel =\n      supportsMobileScreenReader || isActive\n        ? getItemAriaLabel(\n            translations,\n            series.name || series.id.toString(),\n            groups[groupIndex].name || groups[groupIndex].id,\n            item.value,\n            isSelectionEnabled,\n            isSelected,\n            isDrillable,\n            item.accessibleLabel\n          )\n        : undefined;\n\n    const dataInfo = {\n      'data-oj-series-index': seriesIndex,\n      'data-oj-group-index': groupIndex,\n      'data-oj-object': 'item',\n      id: isActive ? activeId : undefined,\n      role: ariaLabel ? 'img' : undefined,\n      'aria-label': ariaLabel\n    };\n\n    const markerSize = (item.markerSize || MARKER_DEFAULT_SIZE) + 2 * MARKER_PADDING;\n    items.push(\n      <Marker\n        type={itemMarkerType}\n        tx={x}\n        ty={y}\n        isInteractive={isDrillable || isSelectionEnabled}\n        scale={1}\n        fill={fill}\n        stroke={stroke}\n        outerStroke={outerStroke}\n        width={markerSize}\n        height={markerSize}\n        dataInfo={dataInfo}\n        preserveRectAspectRatio\n      />\n    );\n  }\n  return <>{items}</>;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { ColorProps } from '../utils/UNSAFE_interpolations/colors';\nimport { getCmdsForLine } from '../utils/PRIVATE_chartUtils/utils';\nimport { Point } from '../utils/PRIVATE_visSVGUtils';\nimport { rgba } from '../UNSAFE_Theme';\nimport { colorSchemeVars } from '../Common/themes/themeContract.css';\nimport { styles } from '../PRIVATE_Chart/themes/ChartStyles.css';\nimport { Property } from 'csstype';\n\ntype LineSeriesProps = {\n  color: ColorProps['color'];\n  lineStyle?: 'dotted' | 'dashed' | 'solid';\n  lineColor?: Property.Color;\n  lineWidth?: number;\n  lineType?: 'straight' | 'curved';\n  isHorizontal: boolean;\n  lineSegmentCoords: Point[][];\n  isHighlighted: boolean;\n  seriesIndex: number;\n};\n\nexport function LineSeries({\n  color,\n  isHorizontal,\n  lineType = 'straight',\n  lineColor,\n  lineStyle,\n  lineWidth = 3,\n  isHighlighted,\n  lineSegmentCoords,\n  seriesIndex\n}: LineSeriesProps) {\n  const style = {\n    stroke: lineColor || color,\n    strokeDasharray: lineStyle === 'dotted' ? 3 : lineStyle === 'dashed' ? 6 : undefined,\n    strokeWidth: lineWidth,\n    fill: rgba(colorSchemeVars.palette.neutral[0], 0)\n  };\n\n  return (\n    <>\n      {lineSegmentCoords.map((value: Point[]) => {\n        const cmds = getCmdsForLine(value, lineType, isHorizontal);\n        return lineType === 'straight' ? (\n          <polyline\n            points={cmds}\n            style={style}\n            className={isHighlighted ? undefined : styles.dimmed}\n            data-oj-series-index={seriesIndex}\n            data-oj-object={'line'}\n          />\n        ) : (\n          <path\n            d={cmds}\n            style={style}\n            className={isHighlighted ? undefined : styles.dimmed}\n            data-oj-series-index={seriesIndex}\n            data-oj-object={'line'}\n          />\n        );\n      })}\n    </>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { LineAreaChartProps, LineAreaItem } from './lineAreaChart.types';\nimport { findNearestDataPoint } from '../utils/PRIVATE_chartUtils/layoutUtils';\nimport { AreaSeries } from './AreaSeries';\nimport { getCumulativeSeries, getMarkers, getSeriesData } from '../utils/PRIVATE_chartUtils/utils';\nimport { Markers } from '../PRIVATE_Chart/Markers';\nimport { getLineAreaChartNavUtil } from '../utils/PRIVATE_chartUtils/navUtils';\nimport { Chart } from '../PRIVATE_Chart';\nimport { Scale, TimeAxisProps } from '../utils/UNSAFE_visTypes/chart';\nimport { useUser } from '../hooks/UNSAFE_useUser';\nimport { getColorRamp } from '../utils/UNSAFE_visUtils';\nimport { LineSeries } from './LineSeries';\nimport { Point } from '../utils/PRIVATE_visSVGUtils';\nimport { getLineAreaSegments } from '../utils/PRIVATE_chartUtils/utils';\nimport { colorSchemeVars } from '../Common/themes/themeContract.css';\nimport { getItemColor, getMarkerType } from '../utils/PRIVATE_chartUtils/dataStyleUtils';\n\nconst AXIS_OFFSET = 0.2;\n\n/**\n * The LineAreaChart displays information graphically using lines and filled areas, making relationships among the data easier to understand.\n */\nexport function LineAreaChart<K extends string | number, D extends LineAreaItem<K>>({\n  width,\n  height,\n  selectedIds = [],\n  hiddenIds = [],\n  highlightedIds,\n  hideAndShowBehavior = 'none',\n  orientation = 'vertical',\n  yAxis,\n  series,\n  groups,\n  isStacked = false,\n  getDataItem,\n  selectionMode = 'none',\n  drilling = 'off',\n  type = 'line',\n  ...props\n}: LineAreaChartProps<K, D>) {\n  const { direction } = useUser();\n  const isRtl = direction === 'rtl';\n  const isLog = yAxis?.scale === 'log';\n  const timeAxisType = (props.xAxis as TimeAxisProps)?.timeAxisType;\n  const hiddenSet = new Set(hiddenIds);\n  const selectedSet = new Set(selectedIds);\n  const highlightedSet = new Set(highlightedIds);\n  const isHoriz = orientation === 'horizontal';\n  const colors = getColorRamp();\n  const renderedSeries = isStacked\n    ? getCumulativeSeries(series.length, groups.length, getDataItem, hiddenSet, isLog)\n    : getSeriesData<K, D>(series?.length, groups?.length, getDataItem, hiddenSet, isLog);\n\n  const renderedGetDataItem = (seriesIndex: number, groupIndex: number): D | undefined => {\n    if (!isStacked) return getDataItem(seriesIndex, groupIndex);\n    return {\n      ...getDataItem(seriesIndex, groupIndex),\n      value: renderedSeries[seriesIndex][groupIndex]\n    } as D;\n  };\n\n  const getGapRatio = () => {\n    return 1;\n  };\n\n  const getNextChartItemFunc = (startIndex: number, endIndex: number) => {\n    return getLineAreaChartNavUtil<K, D>(\n      getDataItem,\n      series.length,\n      startIndex,\n      endIndex,\n      isStacked,\n      isRtl,\n      isHoriz\n    );\n  };\n\n  const getDataItemPos = (xScale: Scale, yScale: Scale) => {\n    return (seriesIndex: number, groupIndex: number) => {\n      const value = renderedSeries[seriesIndex][groupIndex];\n      let xVal = groupIndex;\n      if (timeAxisType) {\n        const val =\n          timeAxisType === 'mixedFrequency'\n            ? getDataItem(seriesIndex, groupIndex)?.x\n            : groups[groupIndex].id;\n        xVal = new Date(val!).getTime();\n      }\n      const x = isHoriz ? yScale.transform(value) : xScale.transform(xVal);\n      const y = isHoriz ? xScale.transform(xVal) : yScale.transform(value);\n      return { x, y, height: 0, width: 0 };\n    };\n  };\n\n  const getMarkerColorAndType = (seriesIndex: number, groupIndex: number) => {\n    return {\n      color: getItemColor<K, D>(seriesIndex, groupIndex, series, getDataItem),\n      type: getMarkerType<K>(seriesIndex, groupIndex, 'lineWithArea', getDataItem)\n    };\n  };\n\n  const findNearest = (xScale: Scale, yScale: Scale) => {\n    const getSeriesDataInfo = () => {\n      return {\n        offset: 0,\n        dataWidth: 0\n      };\n    };\n\n    const getYCoord = (value: number, yScale: Scale) => {\n      return yScale.transform(value);\n    };\n\n    return findNearestDataPoint<K, D>(\n      series,\n      groups,\n      xScale,\n      yScale,\n      renderedGetDataItem,\n      isStacked,\n      getSeriesDataInfo,\n      getYCoord,\n      isLog,\n      0,\n      hiddenSet,\n      timeAxisType\n    );\n  };\n  const markers = getMarkers();\n  const areaOpacity = type === 'lineWithArea' ? 0.5 : 1;\n  const isAreaRendered = type === 'area' || type === 'lineWithArea';\n  const isContrastLineNeeded = type === 'area';\n  const allLineSegmentCoords: Point[][] = [];\n  return (\n    <Chart\n      width={width}\n      height={height}\n      selectedIds={selectedSet}\n      hiddenIds={hiddenIds}\n      hideAndShowBehavior={hideAndShowBehavior}\n      orientation={orientation}\n      yAxis={yAxis}\n      series={series}\n      groups={groups}\n      selectionMode={selectionMode}\n      drilling={drilling}\n      isStacked={isStacked}\n      getDataItem={getDataItem}\n      findNearest={findNearest}\n      getDataItemPos={getDataItemPos}\n      getMarkerInfo={getMarkerColorAndType}\n      renderGridLinesInFront={isAreaRendered}\n      getNavUtil={getNextChartItemFunc}\n      getGapRatio={getGapRatio}\n      offset={AXIS_OFFSET}\n      isRtl={isRtl}\n      {...props}>\n      {({\n        xStartIndex,\n        xEndIndex,\n        xScale,\n        yScale,\n        activeId,\n        focusedItemInfo,\n        hoveredItemInfo,\n        isPointInsideMarquee\n      }) => {\n        return (\n          <>\n            {renderedSeries.map((lineAreaSeries, index) => {\n              if (lineAreaSeries.length === 0) {\n                /* TODO: need a better way to handle when a series is hidden. */\n                return;\n              }\n              const seriesItem = series[index];\n              const lineSegmentCoords: Point[][] = getLineAreaSegments<K, D>(\n                yScale,\n                xScale,\n                lineAreaSeries,\n                xStartIndex,\n                xEndIndex,\n                isHoriz,\n                isLog,\n                groups,\n                index,\n                renderedGetDataItem,\n                timeAxisType\n              );\n              allLineSegmentCoords[index] = lineSegmentCoords[0];\n              const isBottomSegmentCurved =\n                seriesItem.lineType === 'curved' &&\n                isStacked &&\n                renderedSeries.length > 1 &&\n                index > 0;\n\n              const isHighlighted =\n                highlightedIds === undefined || highlightedSet.has(seriesItem.id);\n              return (\n                <>\n                  {isAreaRendered && (\n                    <AreaSeries\n                      yScale={yScale}\n                      lineType={seriesItem.lineType}\n                      color={seriesItem.areaColor || colors[index % colors.length]}\n                      isHorizontal={isHoriz}\n                      areaColorOpacity={areaOpacity}\n                      isBottomSegmentCurved={isBottomSegmentCurved}\n                      bottomCoords={\n                        isStacked && index != 0 ? allLineSegmentCoords[index - 1] : undefined\n                      }\n                      lineSegmentCoords={lineSegmentCoords}\n                      isLog={isLog}\n                      isHighlighted={isHighlighted}\n                      seriesIndex={index}\n                    />\n                  )}\n                  <LineSeries\n                    lineType={seriesItem.lineType}\n                    /* TODO: confirm with UX if this is contrastLine (changes depending on dark/light mode) or always white. \n                        It's always white in legacy.*/\n                    lineColor={\n                      isContrastLineNeeded ? colorSchemeVars.dvt.contrastLine : seriesItem.lineColor\n                    }\n                    /* The area generated in legacy are bit apart and not touching when stacked. Preact areas are a bit closer than legacy when curved. \n                      Increased the contrast linewidth (to 2.5 from legacy 1.25) to give legacy visual treatment.\n                      TODO: investivage why legacy areas are not touching. maybe we want to do the same in preact svg utils that\n                      generates this curve.\n                     */\n                    lineWidth={\n                      isContrastLineNeeded ? (isStacked ? 2.5 : 1.25) : seriesItem.lineWidth\n                    }\n                    lineStyle={seriesItem.lineStyle}\n                    color={seriesItem.lineColor || colors[index % colors.length]}\n                    lineSegmentCoords={lineSegmentCoords}\n                    isHorizontal={isHoriz}\n                    isHighlighted={isHighlighted}\n                    seriesIndex={index}\n                  />\n                  {\n                    /*for non stacked charts, markers should render in the order of series.\n                     some markers might get hidden behind area but this preserves the legacy behavior. */\n                    !isStacked && (\n                      <Markers\n                        yScale={yScale}\n                        xScale={xScale}\n                        groups={groups}\n                        series={seriesItem}\n                        timeAxisType={timeAxisType}\n                        data={lineAreaSeries}\n                        color={\n                          seriesItem.lineColor ||\n                          seriesItem.areaColor ||\n                          colors[\n                            index % colors.length\n                          ] /* TODO : make this use getItemColor function from dataStyleUtils. */\n                        }\n                        seriesIndex={index}\n                        startIndex={xStartIndex}\n                        endIndex={xEndIndex}\n                        markerType={markers[index % markers.length]}\n                        orientation={orientation}\n                        isLog={isLog}\n                        activeId={activeId}\n                        getDataItem={getDataItem}\n                        isPointInsideMarquee={isPointInsideMarquee}\n                        selectedIds={selectedSet}\n                        focusedItemIndex={\n                          focusedItemInfo.seriesIndex === index &&\n                          focusedItemInfo.isFocusVisible &&\n                          !(props.isDataCursorEnabled && props.dataCursorStyle?.isMarkerDisplayed)\n                            ? focusedItemInfo.groupIndex\n                            : undefined\n                        }\n                        hoveredItemIndex={\n                          hoveredItemInfo?.isCurrent && hoveredItemInfo.seriesIndex === index\n                            ? hoveredItemInfo.groupIndex\n                            : undefined\n                        }\n                        isSelectionEnabled={\n                          selectionMode === 'single' || selectionMode === 'multiple'\n                        }\n                        isDrillEnabled={drilling === 'on'}\n                      />\n                    )\n                  }\n                </>\n              );\n            })}\n            {isStacked &&\n              renderedSeries.map((lineAreaSeries, index) => {\n                if (lineAreaSeries.length === 0) {\n                  /* TODO: need a better way to handle when a series is hidden.*/\n                  return;\n                }\n                const seriesItem = series[index];\n                return (\n                  <Markers\n                    yScale={yScale}\n                    series={series[index]}\n                    xScale={xScale}\n                    groups={groups}\n                    timeAxisType={timeAxisType}\n                    data={lineAreaSeries}\n                    color={\n                      seriesItem.lineColor || seriesItem.areaColor || colors[index % colors.length]\n                    }\n                    seriesIndex={index}\n                    isPointInsideMarquee={isPointInsideMarquee}\n                    startIndex={xStartIndex}\n                    endIndex={xEndIndex}\n                    markerType={markers[index % markers.length]}\n                    orientation={orientation}\n                    isLog={isLog}\n                    activeId={activeId}\n                    getDataItem={getDataItem}\n                    selectedIds={selectedSet}\n                    focusedItemIndex={\n                      focusedItemInfo.seriesIndex === index && focusedItemInfo.isFocusVisible\n                        ? focusedItemInfo.groupIndex\n                        : undefined\n                    }\n                    hoveredItemIndex={\n                      hoveredItemInfo?.isCurrent && hoveredItemInfo.seriesIndex === index\n                        ? hoveredItemInfo.groupIndex\n                        : undefined\n                    }\n                    isSelectionEnabled={selectionMode === 'single' || selectionMode === 'multiple'}\n                    isDrillEnabled={drilling === 'on'}\n                  />\n                );\n              })}\n          </>\n        );\n      }}\n    </Chart>\n  );\n}\n"],"names":["AreaSeries","yScale","lineType","color","isHorizontal","isLog","areaColorOpacity","lineSegmentCoords","bottomCoords","isHighlighted","isBottomSegmentCurved","seriesIndex","style","fill","opacity","dvtVars","dimmedOpacity","_jsx","map","baseCoords","baselineCoord","transform","domain","length","cmds","getCmdsForArea","d","MARKER_DEFAULT_SIZE","Markers","xScale","startIndex","endIndex","hiddenIds","selectedIds","orientation","data","markerType","getDataItem","focusedItemIndex","hoveredItemIndex","isDrillEnabled","activeId","isSelectionEnabled","timeAxisType","isPointInsideMarquee","series","groups","isHoriz","items","translations","useTranslationBundle","groupIndex","item","value","has","id","x","getGroupCenterCoord","y","isFocused","isHovered","isSelected","isDrillable","drilling","stroke","outerStroke","getMarkerFillAndStroke","isMarkerDisplayed","markerColor","itemMarkerType","isActive","ariaLabel","supportsMobileScreenReader","getItemAriaLabel","name","toString","accessibleLabel","undefined","dataInfo","role","markerSize","MARKER_PADDING","push","jsx","Marker","type","tx","ty","isInteractive","scale","width","height","preserveRectAspectRatio","_Fragment","Fragment","children","LineSeries","lineColor","lineStyle","lineWidth","strokeDasharray","strokeWidth","rgba","colorSchemeVars","palette","neutral","getCmdsForLine","points","className","styles","dimmed","highlightedIds","hideAndShowBehavior","yAxis","isStacked","selectionMode","props","direction","useUser","isRtl","xAxis","hiddenSet","Set","selectedSet","highlightedSet","colors","getColorRamp","renderedSeries","getCumulativeSeries","getSeriesData","renderedGetDataItem","markers","getMarkers","areaOpacity","isAreaRendered","isContrastLineNeeded","allLineSegmentCoords","Chart","findNearest","findNearestDataPoint","offset","dataWidth","getDataItemPos","xVal","val","Date","getTime","getMarkerInfo","getItemColor","getMarkerType","renderGridLinesInFront","getNavUtil","getLineAreaChartNavUtil","getGapRatio","xStartIndex","xEndIndex","focusedItemInfo","hoveredItemInfo","_jsxs","jsxs","lineAreaSeries","index","seriesItem","getLineAreaSegments","areaColor","dvt","contrastLine","isFocusVisible","isDataCursorEnabled","dataCursorStyle","isCurrent"],"mappings":"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"}