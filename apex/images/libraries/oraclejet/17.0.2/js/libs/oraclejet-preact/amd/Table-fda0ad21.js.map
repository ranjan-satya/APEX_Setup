{"version":3,"file":"Table-fda0ad21.js","sources":["../../src/PRIVATE_Table/TableColGroup.tsx","../../src/PRIVATE_Table/TableSkeletonRow.tsx","../../src/PRIVATE_Table/TableCell.tsx","../../src/PRIVATE_Table/TableRow.tsx","../../src/PRIVATE_Table/TableNoData.tsx","../../src/PRIVATE_Table/TableBody.tsx","../../src/PRIVATE_Table/TableHeaderCell.tsx","../../src/PRIVATE_Table/TableHeader.tsx","../../src/PRIVATE_Table/TableFooterCell.tsx","../../src/PRIVATE_Table/TableFooter.tsx","../../src/PRIVATE_Table/TableDragIndicator.tsx","../../src/PRIVATE_Table/utils/TableDomUtils.ts","../../src/PRIVATE_Table/utils/TableScrollUtils.ts","../../src/PRIVATE_Table/utils/TableNavigationUtils.ts","../../src/PRIVATE_Table/hooks/useFocusHandling.ts","../../src/PRIVATE_Table/utils/TableActionUtils.ts","../../src/PRIVATE_Table/utils/TableSelectionUtils.ts","../../src/PRIVATE_Table/utils/TableSizingUtils.ts","../../src/PRIVATE_Table/hooks/usePointerHandling.ts","../../src/PRIVATE_Table/hooks/useInteractionManager.ts","../../src/PRIVATE_Table/hooks/useKeyboardHandling.ts","../../src/PRIVATE_Table/hooks/useScrollHandling.ts","../../src/PRIVATE_Table/utils/TableLayoutUtils.ts","../../src/PRIVATE_Table/Table.tsx"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\n/**\n * Props for the TableColGroup Component\n */\nexport type TableColGroupProps = {\n  tableId: string;\n  columnWidthsArray: (number | undefined)[];\n};\n\n/**\n * The internal component used to render a single colgroup in Table.\n */\nexport function TableColGroup({ tableId, columnWidthsArray }: TableColGroupProps) {\n  const getColStyle = (columnWidth?: number) => {\n    return columnWidth == null ? '' : `width: ${columnWidth}px;`;\n  };\n\n  return (\n    <colgroup>\n      {columnWidthsArray.map((columnWidth?: number) => {\n        return <col style={getColStyle(columnWidth)} data-oj-table-col={tableId} />;\n      })}\n    </colgroup>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { useState, useEffect } from 'preact/hooks';\nimport { LOADMORE_STYLE_CLASS } from '../PRIVATE_LoadMoreCollection';\nimport { tableSkeletonBarContainerStyles, tableSkeletonCellStyles } from './themes/Table.css';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { Skeleton } from '../UNSAFE_Skeleton';\n\ntype SkeletonRowProps = {\n  /**\n   * Total number of columns to span\n   */\n  colspan: number;\n  /**\n   * The preact key value\n   */\n  preactKey: any;\n  /**\n   * Allows to specify number of skeletons to be rendered on initial load\n   **/\n  minimumCount?: number;\n};\n\n/**\n * Allows to specify the time delay for rendering the component\n **/\nconst _timerValue = 50;\n\n/**\n * TableSkeletonRow renders 'minimumCount' number of skeletons\n * of the variant specified from its child element - Skeleton's prop after\n * 'timerValue' ms delay\n **/\nexport function TableSkeletonRow({ colspan, preactKey, minimumCount = 1 }: SkeletonRowProps) {\n  const [isVisible, setIsVisible] = useState(false);\n\n  useEffect(() => {\n    setTimeout(() => {\n      setIsVisible(true);\n    }, _timerValue);\n  }, []);\n\n  const cellClasses = classNames([tableSkeletonCellStyles.base]);\n\n  return (\n    <tr class={LOADMORE_STYLE_CLASS} key={preactKey}>\n      {isVisible ? (\n        <td class={cellClasses} colSpan={colspan} role=\"presentation\">\n          {[...Array(minimumCount)].map((_element) => (\n            <div class={tableSkeletonBarContainerStyles.base}>\n              <Skeleton height=\"4x\" />\n            </div>\n          ))}\n        </td>\n      ) : null}\n    </tr>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { ComponentChildren } from 'preact';\nimport { Text } from '../UNSAFE_Text';\nimport { CurrentRowVariant, TableRendererContext } from '../UNSAFE_TableView';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { useId } from '../hooks/UNSAFE_useId';\nimport { TableCellVariantOptions } from './themes/TableCellStyles.css';\nimport { TableCellRedwoodTheme } from './themes/redwood/TableCellTheme';\nimport { useComponentTheme } from '../hooks/UNSAFE_useComponentTheme';\n\n/**\n * Props for the TableCell Component\n */\nexport type TableCellProps<K, D, C> = {\n  tableId: string;\n  rowData: D;\n  columnKey: C;\n  columnIndex: number;\n  rowKey: K;\n  rowIndex: number;\n  isFinalRowIndex: boolean;\n  isFinalColumnIndex: boolean;\n  hasVerticalGridlines: boolean;\n  hasHorizontalGridlines: boolean;\n  isRowSelected: boolean;\n  isPreviousRowSelected: boolean;\n  isColumnSelected: boolean;\n  isPreviousColumnSelected: boolean;\n  isShowFocusRing: boolean;\n  isStickyStartEdge: boolean;\n  isStickyEndEdge: boolean;\n  isRtl: boolean;\n  isRowHeader: boolean;\n  isRowSelectionEnabled: boolean;\n  isRowSingleSelection: boolean;\n  applyActiveStyle: boolean;\n  applyHoverStyle: boolean;\n  applyPseudoHoverStyle: boolean;\n  field?: keyof D;\n  stickyColumn?: 'start' | 'end' | 'none';\n  renderer?: (context: TableRendererContext<K, D, C>) => ComponentChildren;\n  selectorRenderer?: () => ComponentChildren;\n  variant?: CurrentRowVariant;\n};\n\nfunction _defaultCellRenderer<K, D, C>({ rowData, field }: TableRendererContext<K, D, C>) {\n  return field != null ? (\n    <Text truncation=\"ellipsis\" variant=\"primary\" size=\"md\">\n      {String(rowData[field])}\n    </Text>\n  ) : null;\n}\n\n/**\n * The internal component used to render a single cell in a TableRow.\n */\nexport function TableCell<K, D, C>({\n  tableId,\n  rowData,\n  field,\n  columnKey,\n  columnIndex,\n  rowKey,\n  rowIndex,\n  isFinalRowIndex,\n  isFinalColumnIndex,\n  hasVerticalGridlines,\n  hasHorizontalGridlines,\n  isRowSelected,\n  isPreviousRowSelected,\n  isColumnSelected,\n  isPreviousColumnSelected,\n  isShowFocusRing,\n  isRowHeader,\n  stickyColumn = 'none',\n  renderer = _defaultCellRenderer,\n  selectorRenderer,\n  isRowSelectionEnabled,\n  isRowSingleSelection,\n  variant,\n  applyActiveStyle,\n  applyHoverStyle,\n  applyPseudoHoverStyle,\n  isStickyStartEdge,\n  isStickyEndEdge,\n  isRtl\n}: TableCellProps<K, D, C>) {\n  const hasRenderer = renderer !== _defaultCellRenderer;\n  const { classes: themeClasses } = useComponentTheme<TableCellVariantOptions>(\n    TableCellRedwoodTheme,\n    {\n      defaultRenderer: !hasRenderer ? 'isDefaultRenderer' : 'notDefaultRenderer',\n      firstRow: rowIndex === 0 ? 'isFirstRow' : 'notFirstRow',\n      lastRow: isFinalRowIndex ? 'isLastRow' : 'notLastRow',\n      firstColumn: columnIndex === 0 ? 'isFirstColumn' : 'notFirstColumn',\n      lastColumn: isFinalColumnIndex ? 'isLastColumn' : 'notLastColumn',\n      borderTopSpacer:\n        !(isRowSingleSelection && (isRowSelected || isPreviousRowSelected)) &&\n        (!hasHorizontalGridlines || rowIndex === 0)\n          ? 'isBorderTopSpacer'\n          : 'notBorderTopSpacer',\n      borderBottomSpacer:\n        isFinalRowIndex && !((isRowSingleSelection && isRowSelected) || hasHorizontalGridlines)\n          ? 'isBorderBottomSpacer'\n          : 'notBorderBottomSpacer',\n      borderStartSpacer:\n        !(isPreviousColumnSelected || isColumnSelected) &&\n        (!hasVerticalGridlines || columnIndex === 0)\n          ? 'isBorderStartSpacer'\n          : 'notBorderStartSpacer',\n      borderEndSpacer:\n        isFinalColumnIndex && !isColumnSelected ? 'isBorderEndSpacer' : 'notBorderEndSpacer',\n      verticalGrid: hasVerticalGridlines ? 'isVerticalGrid' : 'notVerticalGrid',\n      horizontalGrid: hasHorizontalGridlines ? 'isHorizontalGrid' : 'notHorizontalGrid',\n      rowSingleSelection: isRowSingleSelection ? 'isRowSingleSelection' : 'notRowSingleSelection',\n      rowSelectable: isRowSelectionEnabled ? 'isRowSelectable' : 'notRowSelectable',\n      rowSelected: isRowSelected ? 'isRowSelected' : 'notRowSelected',\n      previousRowSelected: isPreviousRowSelected\n        ? 'isPreviousRowSelected'\n        : 'notPreviousRowSelected',\n      columnSelected: isColumnSelected ? 'isColumnSelected' : 'notColumnSelected',\n      previousColumnSelected: isPreviousColumnSelected\n        ? 'isPreviousColumnSelected'\n        : 'notPreviousColumnSelected',\n      stickyStartColumn: stickyColumn === 'start' ? 'isStickyStartColumn' : 'notStickyStartColumn',\n      stickyEndColumn: stickyColumn === 'end' ? 'isStickyEndColumn' : 'notStickyEndColumn',\n      stickyStartEdge: isStickyStartEdge ? 'isStickyStartEdge' : 'notStickyStartEdge',\n      stickyEndEdge: isStickyEndEdge ? 'isStickyEndEdge' : 'notStickyEndEdge',\n      rowHighlight: variant === 'highlight' ? 'isRowHighlight' : 'notRowHighlight',\n      showFocusRing: isShowFocusRing ? 'isShowFocusRing' : 'notShowFocusRing',\n      active: applyActiveStyle ? 'isActive' : 'notActive',\n      hover: applyHoverStyle ? 'isHover' : 'notHover',\n      pseudoHover: applyPseudoHoverStyle ? 'isPseudoHover' : 'notPseudoHover',\n      rtl: isRtl ? 'isRtl' : 'notRtl'\n    }\n  );\n\n  const cellClasses = classNames([themeClasses]);\n\n  const cellRendererProps = {\n    rowData: rowData,\n    rowKey: rowKey,\n    field: field,\n    columnKey: columnKey,\n    selector: selectorRenderer\n  };\n\n  return (\n    <td\n      aria-colindex={columnIndex + 1}\n      class={cellClasses}\n      id={useId()}\n      tabIndex={-1}\n      role={isRowHeader ? 'rowheader' : 'gridcell'}\n      data-oj-cell-type={'data'}\n      data-oj-column-key={columnKey}\n      data-oj-table-focusable={tableId}\n      data-oj-table-data-cell={tableId}\n      {...(typeof columnKey === 'number' && { 'data-oj-column-key-type': 'number' })}>\n      {renderer(cellRendererProps)}\n    </td>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { memo } from 'preact/compat';\nimport { SelectionDetail } from '../UNSAFE_Collection';\nimport { Selector } from '../UNSAFE_Selector';\nimport { CurrentRowVariant, TableSelectionDetail } from '../UNSAFE_TableView';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { Keys, containsKey, isSameKey } from '../utils/UNSAFE_keys';\nimport { TableColumn } from './Table';\nimport { TableCell } from './TableCell';\nimport { TableRowVariantOptions } from './themes/TableRowStyles.css';\nimport { TableRowRedwoodTheme } from './themes/redwood/TableRowTheme';\nimport { BundleType } from '../resources/nls/bundle';\nimport { useComponentTheme } from '../hooks/UNSAFE_useComponentTheme';\nimport { useInteractionStyle } from '../hooks/UNSAFE_useInteractionStyle';\nimport { useTranslationBundle } from '../hooks/UNSAFE_useTranslationBundle';\n\n/**\n * Props for the TableRow Component\n */\nexport type TableRowProps<K, D, C> = {\n  tableId: string;\n  rowKey: K;\n  rowData: D;\n  rowIndex: number;\n  isFinalRow: boolean;\n  columnsArray: TableColumn<K, D, C>[];\n  rowHeaderColumnKeys: Set<C>;\n  hasVerticalGridlines: boolean;\n  hasHorizontalGridlines: boolean;\n  isSelected: boolean;\n  isPreviousSelected: boolean;\n  isRowSelectionEnabled: boolean;\n  isSingleRowSelectionEnabled: boolean;\n  isRtl: boolean;\n  selectedRowKeys?: Keys<K>;\n  focusRingColumnKey?: C;\n  selectedColumnKeys?: Keys<C>;\n  variant?: CurrentRowVariant;\n  onSelectionChange?: (detail: TableSelectionDetail<K, C>, isExtendableSelection: boolean) => void;\n  startStickyEdge?: number;\n  endStickyEdge?: number;\n};\n\n/**\n * The internal component used to render a single row in Table.\n */\nfunction TableRow<K, D, C>({\n  tableId,\n  rowKey,\n  rowData,\n  rowIndex,\n  isFinalRow,\n  columnsArray,\n  rowHeaderColumnKeys,\n  hasVerticalGridlines,\n  hasHorizontalGridlines,\n  isSelected,\n  isPreviousSelected,\n  isRowSelectionEnabled,\n  isSingleRowSelectionEnabled,\n  selectedRowKeys = { all: false, keys: new Set<K>() },\n  focusRingColumnKey,\n  selectedColumnKeys = { all: false, keys: new Set<C>() },\n  variant,\n  onSelectionChange,\n  startStickyEdge,\n  endStickyEdge,\n  isRtl\n}: TableRowProps<K, D, C>) {\n  const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\n  const { interactionProps, applyActiveStyle, applyHoverStyle, applyPseudoHoverStyle } =\n    useInteractionStyle();\n\n  const { classes: themeClasses } = useComponentTheme<TableRowVariantOptions>(\n    TableRowRedwoodTheme,\n    { lastRow: isFinalRow ? 'isLastRow' : 'notLastRow' }\n  );\n\n  const classes = classNames([themeClasses]);\n\n  const accessibleRowName = (rowIndex + 2).toString();\n  const handleRowSelectorChange = (detail: SelectionDetail<K>) => {\n    if (onSelectionChange != null) {\n      onSelectionChange(\n        { value: { row: detail.value, column: selectedColumnKeys }, target: detail.target },\n        false\n      );\n    }\n  };\n  const selectorRenderer =\n    isRowSelectionEnabled && !isSingleRowSelectionEnabled\n      ? () => {\n          // conversion from 0-based index and adding the header row as it is always rendered\n          return (\n            <Selector\n              aria-label={translations.collection_selectRow({ ROW_NAME: accessibleRowName })}\n              onChange={handleRowSelectorChange}\n              rowKey={rowKey}\n              selectedKeys={selectedRowKeys}\n            />\n          );\n        }\n      : undefined;\n\n  let isPreviousColumnSelected = false;\n  return (\n    <tr\n      aria-rowindex={rowIndex + 1}\n      class={classes}\n      role={'row'}\n      data-oj-key={rowKey}\n      data-oj-table-data-row={tableId}\n      {...(isRowSelectionEnabled\n        ? isSelected\n          ? { 'aria-selected': true }\n          : { 'aria-selected': false }\n        : {})}\n      {...(typeof rowKey === 'number' && { 'data-oj-key-type': 'number' })}\n      {...(isRowSelectionEnabled && interactionProps)}>\n      {columnsArray.map((column: TableColumn<K, D, C>, columnIndex: number) => {\n        const columnKey = column.key;\n        const isColumnSelected = containsKey(selectedColumnKeys, columnKey);\n        const cellProps = {\n          tableId: tableId,\n          rowData: rowData,\n          field: column.value.field,\n          stickyColumn: column.value.stickyEdge,\n          columnKey: columnKey,\n          columnIndex: columnIndex,\n          rowKey: rowKey,\n          rowIndex: rowIndex,\n          isFinalRowIndex: isFinalRow,\n          isFinalColumnIndex: columnIndex === columnsArray.length - 1,\n          hasVerticalGridlines: hasVerticalGridlines,\n          hasHorizontalGridlines: hasHorizontalGridlines,\n          isRowSelected: isSelected,\n          isPreviousRowSelected: isPreviousSelected,\n          isColumnSelected: isColumnSelected,\n          isPreviousColumnSelected: isPreviousColumnSelected,\n          isShowFocusRing: column.key === focusRingColumnKey,\n          isRowHeader: rowHeaderColumnKeys.has(column.key),\n          renderer: column.value.renderer,\n          selectorRenderer: selectorRenderer,\n          isRowSelectionEnabled: isRowSelectionEnabled,\n          variant: variant,\n          isRowSingleSelection: isSingleRowSelectionEnabled,\n          applyActiveStyle: applyActiveStyle,\n          applyHoverStyle: applyHoverStyle,\n          applyPseudoHoverStyle: applyPseudoHoverStyle,\n          isStickyStartEdge: columnIndex === startStickyEdge,\n          isStickyEndEdge: columnIndex === endStickyEdge,\n          isRtl: isRtl\n        };\n        isPreviousColumnSelected = isColumnSelected;\n        return <TableCell {...cellProps} />;\n      })}\n    </tr>\n  );\n}\n\nconst _areStringSetsEquivalent = (set1?: Set<string>, set2?: Set<string>) => {\n  if (set1 == null) {\n    return set2 == null;\n  }\n  if (set2 == null) {\n    return false;\n  }\n  return set1.size === set2.size && [...set1].every((x) => set2.has(x));\n};\n\nconst _areColumnsArraysEquivalent = (\n  columnsArray1: TableColumn<string | number, any, string>[],\n  columnsArray2: TableColumn<string | number, any, string>[]\n) => {\n  if (columnsArray1.length === columnsArray2.length) {\n    for (let i = 0; i < columnsArray1.length; i++) {\n      if (\n        columnsArray1[i].key !== columnsArray2[i].key ||\n        columnsArray1[i].value !== columnsArray2[i].value\n      ) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return false;\n};\n\nexport const MemoizeTableRow = memo(TableRow, (prev: any, next: any) => {\n  if (prev && next) {\n    return (\n      prev.tableId === next.tableId &&\n      prev.rowKey === next.rowKey &&\n      prev.rowData === next.rowData &&\n      prev.rowIndex === next.rowIndex &&\n      prev.isFinalRow === next.isFinalRow &&\n      _areColumnsArraysEquivalent(prev.columnsArray, next.columnsArray) &&\n      prev.horizontalGridlines === next.horizontalGridlines &&\n      prev.verticalGridlines === next.verticalGridlines &&\n      _areStringSetsEquivalent(prev.rowHeaderColumnKeys, next.rowHeaderColumnKeys) &&\n      prev.isSelected === next.isSelected &&\n      prev.isPreviousSelected === next.isPreviousSelected &&\n      prev.isRowSelectionEnabled === next.isRowSelectionEnabled &&\n      prev.isSingleRowSelectionEnabled === next.isSingleRowSelectionEnabled &&\n      (prev.isRowSelectionEnabled && !prev.isSingleRowSelectionEnabled\n        ? isSameKey(prev.selectedRowKeys, next.selectedRowKeys)\n        : true) &&\n      isSameKey(prev.selectedColumnKeys, next.selectedColumnKeys) &&\n      prev.focusRingColumnKey === next.focusRingColumnKey &&\n      prev.variant === next.variant &&\n      prev.onSelectionChange === next.onSelectionChange &&\n      prev.startStickyEdge === next.startStickyEdge &&\n      prev.endStickyEdge === next.endStickyEdge &&\n      prev.isRtl === next.isRtl\n    );\n  }\n  return false;\n});\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { ComponentChildren } from 'preact';\nimport { Text } from '../UNSAFE_Text';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { useId } from '../hooks/UNSAFE_useId';\nimport { tableRowStyles } from './themes/TableRowStyles.css';\nimport { TableNoDataVariantOptions } from './themes/TableNoDataStyles.css';\nimport { TableNoDataRedwoodTheme } from './themes/redwood/TableNoDataTheme';\nimport { useComponentTheme } from '../hooks/UNSAFE_useComponentTheme';\nimport { BundleType } from '../resources/nls/bundle';\nimport { useTranslationBundle } from '../hooks/UNSAFE_useTranslationBundle';\n\n/**\n * Props for the TableCell Component\n */\nexport type TableNoDataProps = {\n  tableId: string;\n  columnsCount: number;\n  isShowFocusRing: boolean;\n  renderer?: () => ComponentChildren;\n};\n\n/**\n * The internal component used to render a single cell in a TableRow.\n */\nexport function TableNoData({\n  tableId,\n  columnsCount,\n  isShowFocusRing,\n  renderer\n}: TableNoDataProps) {\n  const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\n\n  const rowClasses = classNames([tableRowStyles.base]);\n\n  const { classes: themeClasses } = useComponentTheme<TableNoDataVariantOptions>(\n    TableNoDataRedwoodTheme,\n    {\n      defaultRenderer: renderer == null ? 'isDefaultRenderer' : 'notDefaultRenderer',\n      showFocusRing: isShowFocusRing ? 'isShowFocusRing' : 'notShowFocusRing'\n    }\n  );\n\n  const cellClasses = classNames([themeClasses]);\n\n  function defaultContentRenderer() {\n    return (\n      <Text truncation=\"ellipsis\" variant=\"primary\" size=\"md\">\n        {translations.collection_noData()}\n      </Text>\n    );\n  }\n\n  const contentRenderer = renderer != null ? renderer : defaultContentRenderer;\n\n  return (\n    <tr aria-rowindex={2} class={rowClasses} role={'row'}>\n      <td\n        aria-colindex={1}\n        class={cellClasses}\n        id={useId()}\n        tabIndex={-1}\n        role={'gridcell'}\n        colSpan={columnsCount}\n        data-oj-cell-type={'noData'}\n        data-oj-table-focusable={tableId}\n        data-oj-table-nodata-cell={tableId}>\n        {contentRenderer()}\n      </td>\n    </tr>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { useCallback, useRef } from 'preact/hooks';\nimport { LoadMoreCollection } from '../PRIVATE_LoadMoreCollection';\nimport { TableColumn } from './Table';\nimport { TableSkeletonRow } from './TableSkeletonRow';\nimport { MemoizeTableRow } from './TableRow';\nimport { ItemContext } from '../UNSAFE_Collection';\nimport {\n  Cell,\n  CurrentRowVariant,\n  TableSelectionDetail,\n  TableRowContext\n} from '../UNSAFE_TableView';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { collectionStyles } from './themes/Table.css';\nimport { Keys, containsKey } from '../utils/UNSAFE_keys';\nimport { ViewportConfig } from '../hooks/UNSAFE_useViewportIntersect';\nimport { TableNoData } from './TableNoData';\nimport { ComponentChildren } from 'preact';\n\n/**\n * Props for the TableBody Component\n */\nexport type TableBodyProps<K, D, C> = {\n  tableId: string;\n  getAccessibleRowHeaders: (context: TableRowContext<K, D>) => Set<C>;\n  data: D[] | null;\n  columnsArray: TableColumn<K, D, C>[];\n  hasVerticalGridlines: boolean;\n  hasHorizontalGridlines: boolean;\n  isShowFocusRing: boolean;\n  getRowKey: (data: D) => K;\n  hasMore: boolean;\n  isRtl: boolean;\n  onLoadMore: () => void;\n  viewportConfig: ViewportConfig;\n  currentCell?: Cell<K, C>;\n  currentRowVariant?: CurrentRowVariant;\n  selected: { row?: Keys<K>; column?: Keys<C> };\n  isRowSelectionEnabled: boolean;\n  isSingleRowSelectionEnabled: boolean;\n  onSelectionChange?: (detail: TableSelectionDetail<K, C>, isExtendableSelection: boolean) => void;\n  noDataRenderer?: () => ComponentChildren;\n  startStickyEdge?: number;\n  endStickyEdge?: number;\n};\n\n/**\n * The internal component used to render a single cell in a TableRow.\n */\nexport function TableBody<K, D, C>({\n  tableId,\n  getAccessibleRowHeaders,\n  data,\n  columnsArray,\n  hasVerticalGridlines,\n  hasHorizontalGridlines,\n  isShowFocusRing,\n  getRowKey,\n  hasMore,\n  onLoadMore,\n  viewportConfig,\n  currentCell,\n  currentRowVariant,\n  selected,\n  isRowSelectionEnabled,\n  isSingleRowSelectionEnabled,\n  onSelectionChange,\n  noDataRenderer,\n  startStickyEdge,\n  endStickyEdge,\n  isRtl\n}: TableBodyProps<K, D, C>) {\n  // track the empty loading state and generate a new key when it changes to avoid\n  // issues with skeleton animations becoming out of sync when more are added\n  const loadIndicatorKeyRef = useRef<number>(new Date().getTime());\n  const isShowEmptyLoadingRef = useRef<boolean>();\n\n  const collectionClasses = classNames([collectionStyles.base]);\n\n  // returns a TableRowContext based on ItemContext (added key)\n  const getRowContext = useCallback(\n    (context: ItemContext<{ data: D }>) => {\n      return {\n        index: context.index,\n        data: context.data.data,\n        key: getRowKey(context.data.data)\n      };\n    },\n    [getRowKey]\n  );\n\n  let isPreviousSelected = false;\n  const collectionChildrenFunc = (context: ItemContext<{ data: D }>) => {\n    const tableRowContext = getRowContext(context);\n    const rowKey = tableRowContext.key;\n    const containsCurrentCell = currentCell?.rowKey === rowKey;\n    const focusRingColumnKey =\n      containsCurrentCell && isShowFocusRing ? currentCell.columnKey : undefined;\n    const isSelected = containsKey(selected.row, rowKey);\n    const rowProps = {\n      tableId: tableId,\n      columnsArray: columnsArray,\n      rowHeaderColumnKeys: getAccessibleRowHeaders(tableRowContext),\n      hasVerticalGridlines: hasVerticalGridlines,\n      hasHorizontalGridlines: hasHorizontalGridlines,\n      isSelected: isSelected,\n      isPreviousSelected: isPreviousSelected,\n      onSelectionChange: onSelectionChange,\n      isRowSelectionEnabled: isRowSelectionEnabled,\n      isSingleRowSelectionEnabled: isSingleRowSelectionEnabled,\n      variant: containsCurrentCell ? currentRowVariant : 'none',\n      focusRingColumnKey: focusRingColumnKey,\n      selectedRowKeys: selected.row,\n      selectedColumnKeys: selected.column,\n      rowIndex: tableRowContext.index,\n      rowKey: rowKey,\n      rowData: tableRowContext.data,\n      isFinalRow: tableRowContext.index === (data != null ? data.length - 1 : -1),\n      startStickyEdge: startStickyEdge,\n      endStickyEdge: endStickyEdge,\n      isRtl: isRtl\n    };\n    isPreviousSelected = isSelected;\n    return <MemoizeTableRow {...rowProps} />;\n  };\n\n  const getNoDataProps = () => {\n    return {\n      tableId: tableId,\n      columnsCount: columnsArray.length,\n      isShowFocusRing: isShowFocusRing && currentCell?.type === 'noData',\n      renderer: noDataRenderer\n    };\n  };\n\n  const collectionData =\n    data != null\n      ? data.map((d: D) => {\n          const key = getRowKey(d);\n          return { data: d, metadata: key };\n        })\n      : [];\n\n  const isShowEmptyLoading = data != null && data.length === 0 && hasMore;\n  const isShowNoData = data == null || (data.length === 0 && !hasMore);\n  const prevIsEmpty = isShowEmptyLoadingRef.current;\n  if (prevIsEmpty !== isShowEmptyLoading) {\n    loadIndicatorKeyRef.current = new Date().getTime();\n  }\n  isShowEmptyLoadingRef.current = isShowEmptyLoading;\n\n  return (\n    <tbody class={collectionClasses}>\n      {isShowNoData ? (\n        <TableNoData {...getNoDataProps()} />\n      ) : (\n        <LoadMoreCollection\n          data={collectionData}\n          loadMoreIndicator={\n            <TableSkeletonRow\n              colspan={columnsArray.length}\n              preactKey={loadIndicatorKeyRef.current}\n              minimumCount={isShowEmptyLoading ? 25 : 3}\n            />\n          }\n          hasMore={hasMore}\n          onLoadMore={onLoadMore}\n          viewportConfig={viewportConfig}>\n          {collectionChildrenFunc}\n        </LoadMoreCollection>\n      )}\n    </tbody>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { ComponentChildren } from 'preact';\nimport { useCallback } from 'preact/hooks';\nimport { SelectionDetail } from '../UNSAFE_Collection';\nimport { SelectorAll } from '../UNSAFE_SelectorAll';\nimport { Text } from '../UNSAFE_Text';\nimport {\n  TableHeaderRendererContext,\n  TableSelectionDetail,\n  SortCriterionDetail\n} from '../UNSAFE_TableView';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { Keys, isSameKey } from '../utils/UNSAFE_keys';\nimport { useId } from '../hooks/UNSAFE_useId';\nimport { tableHeaderCellTextStyles, tableHeaderSortContainerStyles } from './themes/Table.css';\nimport { TableHeaderCellVariantOptions } from './themes/TableHeaderCellStyles.css';\nimport { TableHeaderCellRedwoodTheme } from './themes/redwood/TableHeaderCellTheme';\nimport { useComponentTheme } from '../hooks/UNSAFE_useComponentTheme';\nimport { BundleType } from '../resources/nls/bundle';\nimport { useInteractionStyle } from '../hooks/UNSAFE_useInteractionStyle';\nimport { useTranslationBundle } from '../hooks/UNSAFE_useTranslationBundle';\nimport { EmbeddedIconButton } from '../PRIVATE_EmbeddedIconButton';\nimport { SortAscendingIcon } from '../PRIVATE_ThemedIcons/SortAscendingIcon';\nimport { SortDefaultIcon } from '../PRIVATE_ThemedIcons/SortDefaultIcon';\nimport { SortDescendingIcon } from '../PRIVATE_ThemedIcons/SortDescendingIcon';\n\n/**\n * Props for the TableHeaderCell Component\n */\nexport type TableHeaderCellProps<K, C> = {\n  tableId: string;\n  columnKey: C;\n  columnIndex: number;\n  isFinalColumnIndex: boolean;\n  hasVerticalGridlines: boolean;\n  isSelected: boolean;\n  isPreviousSelected: boolean;\n  isColumnSelectable: boolean;\n  isRowSelectionEnabled: boolean;\n  isShowFocusRing: boolean;\n  isStickyStartEdge: boolean;\n  isStickyEndEdge: boolean;\n  isRtl: boolean;\n  headerText?: string;\n  selectedColumnKeys?: Keys<C>;\n  selectedRowKeys?: Keys<K>;\n  stickyColumn?: 'start' | 'end' | 'none';\n  renderer?: (context: TableHeaderRendererContext<C>) => ComponentChildren;\n  onSelectionChange?: (detail: TableSelectionDetail<K, C>, isExtendableSelection: boolean) => void;\n  sortable?: 'enabled' | 'disabled';\n  sortDirection?: 'ascending' | 'descending';\n  onSortCriterionChange?: (detail: SortCriterionDetail<C>) => void;\n};\n\n/**\n * The internal component used to render a single cell in a TableHeaderRow.\n */\nexport function TableHeaderCell<K, C>({\n  tableId,\n  columnKey,\n  columnIndex,\n  isFinalColumnIndex,\n  hasVerticalGridlines,\n  isSelected,\n  isPreviousSelected,\n  isColumnSelectable,\n  isRowSelectionEnabled,\n  selectedColumnKeys = { all: false, keys: new Set<C>() },\n  selectedRowKeys = { all: false, keys: new Set<K>() },\n  isShowFocusRing,\n  headerText,\n  stickyColumn = 'none',\n  renderer,\n  onSelectionChange,\n  sortable = 'disabled',\n  sortDirection,\n  onSortCriterionChange,\n  isStickyStartEdge,\n  isStickyEndEdge,\n  isRtl\n}: TableHeaderCellProps<K, C>) {\n  const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\n\n  const { interactionProps, applyActiveStyle, applyHoverStyle, applyPseudoHoverStyle } =\n    useInteractionStyle();\n\n  const hasRenderer = renderer != null;\n  const { classes: themeClasses } = useComponentTheme<TableHeaderCellVariantOptions>(\n    TableHeaderCellRedwoodTheme,\n    {\n      defaultRenderer: !hasRenderer ? 'isDefaultRenderer' : 'notDefaultRenderer',\n      firstColumn: columnIndex === 0 ? 'isFirstColumn' : 'notFirstColumn',\n      lastColumn: isFinalColumnIndex ? 'isLastColumn' : 'notLastColumn',\n      borderStartSpacer:\n        !(isPreviousSelected || isSelected) && (!hasVerticalGridlines || columnIndex === 0)\n          ? 'isBorderStartSpacer'\n          : 'notBorderStartSpacer',\n      borderEndSpacer:\n        isFinalColumnIndex && !isSelected ? 'isBorderEndSpacer' : 'notBorderEndSpacer',\n      verticalGrid: hasVerticalGridlines ? 'isVerticalGrid' : 'notVerticalGrid',\n      columnSelectable: isColumnSelectable ? 'isColumnSelectable' : 'notColumnSelectable',\n      columnSelected: isSelected ? 'isColumnSelected' : 'notColumnSelected',\n      previousColumnSelected: isPreviousSelected\n        ? 'isPreviousColumnSelected'\n        : 'notPreviousColumnSelected',\n      stickyStartColumn: stickyColumn === 'start' ? 'isStickyStartColumn' : 'notStickyStartColumn',\n      stickyEndColumn: stickyColumn === 'end' ? 'isStickyEndColumn' : 'notStickyEndColumn',\n      stickyStartEdge: isStickyStartEdge ? 'isStickyStartEdge' : 'notStickyStartEdge',\n      stickyEndEdge: isStickyEndEdge ? 'isStickyEndEdge' : 'notStickyEndEdge',\n      showFocusRing: isShowFocusRing ? 'isShowFocusRing' : 'notShowFocusRing',\n      active: applyActiveStyle ? 'isActive' : 'notActive',\n      hover: applyHoverStyle ? 'isHover' : 'notHover',\n      pseudoHover: applyPseudoHoverStyle ? 'isPseudoHover' : 'notPseudoHover',\n      rtl: isRtl ? 'isRtl' : 'notRtl'\n    }\n  );\n\n  const cellClasses = classNames([themeClasses]);\n\n  let selectorAllState: 'all' | 'none' | 'partial' | 'partial-all';\n  if (isSameKey(selectedRowKeys, { all: true, deletedKeys: new Set<K>() })) {\n    selectorAllState = 'all';\n  } else if (isSameKey(selectedRowKeys, { all: false, keys: new Set<K>() })) {\n    selectorAllState = 'none';\n  } else {\n    selectorAllState = 'partial';\n  }\n\n  const handleSelectorChange = (detail: SelectionDetail<K>) => {\n    if (onSelectionChange != null) {\n      onSelectionChange(\n        { value: { row: detail.value, column: selectedColumnKeys }, target: detail.target },\n        false\n      );\n    }\n  };\n\n  const selectorRenderer = isRowSelectionEnabled\n    ? () => (\n        <SelectorAll\n          aria-label={translations.collection_selectAllRows()}\n          onChange={handleSelectorChange}\n          selected={selectorAllState}\n        />\n      )\n    : undefined;\n\n  const sortIconRenderer =\n    sortable === 'enabled' || sortDirection != null\n      ? () => (\n          <EmbeddedIconButton\n            aria-label={\n              sortable === 'enabled'\n                ? translations.collection_sortEnabled()\n                : translations.collection_sortDisabled()\n            }\n            isDisabled={sortable !== 'enabled'}\n            onAction={handleSortGesture}>\n            {sortDirection === 'ascending' ? (\n              <SortAscendingIcon />\n            ) : sortDirection === 'descending' ? (\n              <SortDescendingIcon />\n            ) : (\n              <SortDefaultIcon />\n            )}\n          </EmbeddedIconButton>\n        )\n      : undefined;\n\n  const headerCellRendererProps = {\n    key: columnKey,\n    headerText: headerText,\n    sortable: sortable,\n    sortDirection: sortDirection,\n    selector: selectorRenderer,\n    sortControl: sortIconRenderer\n  };\n\n  const handleSortGesture = useCallback(() => {\n    if (onSortCriterionChange != null) {\n      const newDirection = sortDirection === 'ascending' ? 'descending' : 'ascending';\n      onSortCriterionChange([{ key: columnKey, sortDirection: newDirection }]);\n    }\n  }, [columnKey, sortDirection, onSortCriterionChange]);\n\n  const getHeaderCellRenderer = useCallback(() => {\n    if (renderer != null) {\n      return renderer;\n    }\n    return ({ headerText, sortControl }: TableHeaderRendererContext<C>) => {\n      const text =\n        headerText != null ? (\n          <div class={tableHeaderCellTextStyles.base}>\n            <Text overflowWrap=\"normal\" lineClamp={2} variant=\"primary\" size=\"md\">\n              {headerText}\n            </Text>\n          </div>\n        ) : null;\n      if (sortControl != null) {\n        return (\n          <div class={tableHeaderSortContainerStyles.base}>\n            {text}\n            {sortControl()}\n          </div>\n        );\n      }\n      return text;\n    };\n  }, [renderer]);\n\n  const getAriaSelected = () => {\n    if (isSelected) {\n      return { 'aria-selected': true };\n    }\n    return isColumnSelectable ? { 'aria-selected': false } : undefined;\n  };\n\n  const getAriaSort = () => {\n    if (sortDirection === 'ascending' || sortDirection === 'descending') {\n      return { 'aria-sort': sortDirection };\n    }\n    return undefined;\n  };\n\n  return (\n    <th\n      aria-colindex={columnIndex + 1}\n      {...getAriaSelected()}\n      {...getAriaSort()}\n      class={cellClasses}\n      id={useId()}\n      tabIndex={-1}\n      role={'columnheader'}\n      data-oj-cell-type={'header'}\n      data-oj-column-key={columnKey}\n      data-oj-table-focusable={tableId}\n      data-oj-table-header-cell={tableId}\n      {...(typeof columnKey === 'number' && { 'data-oj-column-key-type': 'number' })}\n      {...(isColumnSelectable && interactionProps)}>\n      {getHeaderCellRenderer()(headerCellRendererProps)}\n    </th>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { Keys, containsKey } from '../utils/UNSAFE_keys';\nimport { TableSelectionDetail, SortCriterionDetail } from '../UNSAFE_TableView';\nimport { TableColumn } from './Table';\nimport { TableHeaderCell } from './TableHeaderCell';\nimport { tableHeaderRowStyles, tableHeaderRowContainerStyles } from './themes/Table.css';\n\n/**\n * Props for the TableHeader Component\n */\nexport type TableHeaderProps<K, D, C> = {\n  tableId: string;\n  columnsArray: TableColumn<K, D, C>[];\n  hasVerticalGridlines: boolean;\n  focusedKey?: C;\n  isShowFocusRing: boolean;\n  selectedColumnKeys?: Keys<C>;\n  selectedRowKeys?: Keys<K>;\n  isColumnSelectionEnabled: boolean;\n  isRowSelectionEnabled: boolean;\n  isResizeHover: boolean;\n  isRtl: boolean;\n  onSelectionChange?: (detail: TableSelectionDetail<K, C>, isExtendableSelection: boolean) => void;\n  sortCriterion?: { key: C; sortDirection: 'ascending' | 'descending' }[];\n  onSortCriterionChange?: (detail: SortCriterionDetail<C>) => void;\n  startStickyEdge?: number;\n  endStickyEdge?: number;\n};\n\n/**\n * The internal component used to render a header region in Table.\n */\nexport function TableHeader<K, D, C>({\n  tableId,\n  columnsArray,\n  hasVerticalGridlines,\n  focusedKey,\n  isShowFocusRing,\n  selectedColumnKeys,\n  selectedRowKeys,\n  isColumnSelectionEnabled,\n  isRowSelectionEnabled,\n  onSelectionChange,\n  sortCriterion,\n  onSortCriterionChange,\n  startStickyEdge,\n  endStickyEdge,\n  isResizeHover,\n  isRtl\n}: TableHeaderProps<K, D, C>) {\n  const rowClasses = classNames([tableHeaderRowStyles.base]);\n  const containerClasses = classNames([tableHeaderRowContainerStyles.base]);\n\n  const getStyle = () => {\n    return isResizeHover ? 'cursor: col-resize;' : '';\n  };\n\n  let isPreviousSelected = false;\n  return (\n    <thead class={containerClasses}>\n      <tr class={rowClasses} role={'row'} style={getStyle()} data-oj-table-header-row={tableId}>\n        {columnsArray.map((column: TableColumn<K, D, C>, columnIndex: number) => {\n          const columnKey = column.key;\n          let sortDirection;\n          if (sortCriterion != null) {\n            for (const criterion of sortCriterion) {\n              if (criterion.key === columnKey) {\n                sortDirection = criterion.sortDirection;\n                break;\n              }\n            }\n          }\n          const isSelected = containsKey(selectedColumnKeys, columnKey);\n          const headerCellProps = {\n            tableId: tableId,\n            hasVerticalGridlines: hasVerticalGridlines,\n            columnKey: columnKey,\n            columnIndex: columnIndex,\n            isFinalColumnIndex: columnIndex === columnsArray.length - 1,\n            stickyColumn: column.value.stickyEdge,\n            isSelected: isSelected,\n            isPreviousSelected: isPreviousSelected,\n            selectedColumnKeys: selectedColumnKeys,\n            selectedRowKeys: selectedRowKeys,\n            isColumnSelectable: isColumnSelectionEnabled && column.value.selectable !== 'disabled',\n            isRowSelectionEnabled: isRowSelectionEnabled,\n            isShowFocusRing: isShowFocusRing && columnKey === focusedKey,\n            headerText: column.value.headerText,\n            renderer: column.value.headerRenderer,\n            onSelectionChange: onSelectionChange,\n            sortable: column.value.sortable,\n            sortDirection: sortDirection,\n            onSortCriterionChange: onSortCriterionChange,\n            isStickyStartEdge: columnIndex === startStickyEdge,\n            isStickyEndEdge: columnIndex === endStickyEdge,\n            isRtl: isRtl\n          };\n          isPreviousSelected = isSelected;\n          return <TableHeaderCell {...headerCellProps} />;\n        })}\n      </tr>\n    </thead>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { ComponentChildren } from 'preact';\nimport { Text } from '../UNSAFE_Text';\nimport { TableFooterRendererContext } from '../UNSAFE_TableView';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { useId } from '../hooks/UNSAFE_useId';\nimport { TableFooterCellVariantOptions } from './themes/TableFooterCellStyles.css';\nimport { TableFooterCellRedwoodTheme } from './themes/redwood/TableFooterCellTheme';\nimport { useComponentTheme } from '../hooks/UNSAFE_useComponentTheme';\nimport { useInteractionStyle } from '../hooks/UNSAFE_useInteractionStyle';\n\n/**\n * Props for the TableFooterCell Component\n */\nexport type TableFooterCellProps<C> = {\n  tableId: string;\n  columnKey: C;\n  columnIndex: number;\n  isFinalColumnIndex: boolean;\n  hasVerticalGridlines: boolean;\n  isSelected: boolean;\n  isPreviousSelected: boolean;\n  isColumnSelectable: boolean;\n  isShowFocusRing: boolean;\n  isStickyStartEdge: boolean;\n  isStickyEndEdge: boolean;\n  isRtl: boolean;\n  footerText?: string;\n  stickyColumn?: 'start' | 'end' | 'none';\n  renderer?: (context: TableFooterRendererContext<C>) => ComponentChildren;\n};\n\nfunction _defaultFooterCellRenderer<C>({ footerText }: TableFooterRendererContext<C>) {\n  return footerText != null ? (\n    <Text truncation=\"ellipsis\" variant=\"primary\" size=\"md\">\n      {footerText}\n    </Text>\n  ) : null;\n}\n\n/**\n * The internal component used to render a single cell in a TableFooterRow.\n */\nexport function TableFooterCell<C>({\n  tableId,\n  columnKey,\n  columnIndex,\n  isFinalColumnIndex,\n  hasVerticalGridlines,\n  isSelected,\n  isPreviousSelected,\n  isColumnSelectable,\n  isShowFocusRing,\n  stickyColumn = 'none',\n  footerText,\n  renderer = _defaultFooterCellRenderer,\n  isStickyStartEdge,\n  isStickyEndEdge,\n  isRtl\n}: TableFooterCellProps<C>) {\n  const { interactionProps, applyActiveStyle, applyHoverStyle, applyPseudoHoverStyle } =\n    useInteractionStyle();\n\n  const hasRenderer = renderer !== _defaultFooterCellRenderer;\n  const { classes: themeClasses } = useComponentTheme<TableFooterCellVariantOptions>(\n    TableFooterCellRedwoodTheme,\n    {\n      defaultRenderer: !hasRenderer ? 'isDefaultRenderer' : 'notDefaultRenderer',\n      firstColumn: columnIndex === 0 ? 'isFirstColumn' : 'notFirstColumn',\n      lastColumn: isFinalColumnIndex ? 'isLastColumn' : 'notLastColumn',\n      borderStartSpacer:\n        !(isPreviousSelected || isSelected) && (!hasVerticalGridlines || columnIndex === 0)\n          ? 'isBorderStartSpacer'\n          : 'notBorderStartSpacer',\n      borderEndSpacer:\n        isFinalColumnIndex && !isSelected ? 'isBorderEndSpacer' : 'notBorderEndSpacer',\n      verticalGrid: hasVerticalGridlines ? 'isVerticalGrid' : 'notVerticalGrid',\n      columnSelectable: isColumnSelectable ? 'isColumnSelectable' : 'notColumnSelectable',\n      columnSelected: isSelected ? 'isColumnSelected' : 'notColumnSelected',\n      previousColumnSelected: isPreviousSelected\n        ? 'isPreviousColumnSelected'\n        : 'notPreviousColumnSelected',\n      stickyStartColumn: stickyColumn === 'start' ? 'isStickyStartColumn' : 'notStickyStartColumn',\n      stickyEndColumn: stickyColumn === 'end' ? 'isStickyEndColumn' : 'notStickyEndColumn',\n      stickyStartEdge: isStickyStartEdge ? 'isStickyStartEdge' : 'notStickyStartEdge',\n      stickyEndEdge: isStickyEndEdge ? 'isStickyEndEdge' : 'notStickyEndEdge',\n      showFocusRing: isShowFocusRing ? 'isShowFocusRing' : 'notShowFocusRing',\n      active: applyActiveStyle ? 'isActive' : 'notActive',\n      hover: applyHoverStyle ? 'isHover' : 'notHover',\n      pseudoHover: applyPseudoHoverStyle ? 'isPseudoHover' : 'notPseudoHover',\n      rtl: isRtl ? 'isRtl' : 'notRtl'\n    }\n  );\n\n  const cellClasses = classNames([themeClasses]);\n\n  const footerCellRendererProps = { key: columnKey, footerText: footerText };\n\n  return (\n    <td\n      aria-colindex={columnIndex + 1}\n      {...(isSelected\n        ? { 'aria-selected': true }\n        : isColumnSelectable\n        ? { 'aria-selected': false }\n        : {})}\n      class={cellClasses}\n      id={useId()}\n      tabIndex={-1}\n      role={'gridcell'}\n      data-oj-cell-type={'footer'}\n      data-oj-column-key={columnKey}\n      data-oj-table-focusable={tableId}\n      data-oj-table-footer-cell={tableId}\n      {...(typeof columnKey === 'number' && { 'data-oj-column-key-type': 'number' })}\n      {...(isColumnSelectable && interactionProps)}>\n      {renderer(footerCellRendererProps)}\n    </td>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { Keys, containsKey } from '../utils/UNSAFE_keys';\nimport { TableColumn } from './Table';\nimport { TableFooterCell } from './TableFooterCell';\nimport { tableFooterRowStyles, tableFooterRowContainerStyles } from './themes/Table.css';\n\n/**\n * Props for the TableFooter Component\n */\nexport type TableFooterProps<K, D, C> = {\n  tableId: string;\n  isRendered: boolean;\n  columnsArray: TableColumn<K, D, C>[];\n  hasVerticalGridlines: boolean;\n  focusedKey?: C;\n  isShowFocusRing: boolean;\n  isRtl: boolean;\n  selectedKeys?: Keys<C>;\n  isColumnSelectionEnabled: boolean;\n  startStickyEdge?: number;\n  endStickyEdge?: number;\n};\n\n/**\n * The internal component used to render a footer region in Table.\n */\nexport function TableFooter<K, D, C>({\n  tableId,\n  isRendered,\n  columnsArray,\n  hasVerticalGridlines,\n  focusedKey,\n  isShowFocusRing,\n  selectedKeys,\n  isColumnSelectionEnabled,\n  startStickyEdge,\n  endStickyEdge,\n  isRtl\n}: TableFooterProps<K, D, C>) {\n  const rowClasses = classNames([tableFooterRowStyles.base]);\n  const containerClasses = classNames([tableFooterRowContainerStyles.base]);\n\n  let isPreviousSelected = false;\n  return isRendered ? (\n    <tfoot class={containerClasses}>\n      <tr class={rowClasses} role={'row'} data-oj-table-footer-row={tableId}>\n        {columnsArray.map((column: TableColumn<K, D, C>, columnIndex: number) => {\n          const columnKey = column.key;\n          const isSelected = containsKey(selectedKeys, columnKey);\n          const footerCellProps = {\n            tableId: tableId,\n            columnKey: columnKey,\n            columnIndex: columnIndex,\n            isFinalColumnIndex: columnIndex === columnsArray.length - 1,\n            hasVerticalGridlines: hasVerticalGridlines,\n            stickyColumn: column.value.stickyEdge,\n            isSelected: isSelected,\n            isPreviousSelected: isPreviousSelected,\n            isColumnSelectable: isColumnSelectionEnabled && column.value.selectable !== 'disabled',\n            isShowFocusRing: isShowFocusRing && columnKey === focusedKey,\n            footerText: column.value.footerText,\n            renderer: column.value.footerRenderer,\n            isStickyStartEdge: columnIndex === startStickyEdge,\n            isStickyEndEdge: columnIndex === endStickyEdge,\n            isRtl: isRtl\n          };\n          isPreviousSelected = isSelected;\n          return <TableFooterCell {...footerCellProps} />;\n        })}\n      </tr>\n    </tfoot>\n  ) : null;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { tableDragIndicatorStyles } from './themes/Table.css';\n\n/**\n * Props for the TableDragIndicator Component\n */\nexport type TableDragIndicatorProps = {\n  isRtl: boolean;\n  position?: number;\n};\n\n/**\n * The internal component used to render a drag indicator line in the Table.\n */\nexport function TableDragIndicator({ position, isRtl }: TableDragIndicatorProps) {\n  const tableDragIndicatorClasses = classNames([tableDragIndicatorStyles.base]);\n\n  const getDragIndicatorStyle = () => {\n    if (position != null) {\n      return isRtl\n        ? `right:${position}px;cursor:col-resize;`\n        : `left:${position}px;cursor:col-resize;`;\n    }\n    return `display:none;`;\n  };\n\n  return <div class={tableDragIndicatorClasses} style={getDragIndicatorStyle()} />;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { keyExtractor } from '../../utils/PRIVATE_collectionUtils';\nimport { FocusableElement } from '../../utils/PRIVATE_tabbableUtils';\nimport { Cell } from '../../UNSAFE_TableView';\n\n/**\n * Returns the cell type for the given cell element\n */\nexport const getCellType = (element: FocusableElement) => {\n  return element.dataset['ojCellType'];\n};\n\n/**\n * Returns the row key for the given row element\n */\nexport const getRowKey = (element: HTMLElement) => {\n  return element.dataset['ojKeyType'] === 'number'\n    ? Number(element.dataset['ojKey'])\n    : element.dataset['ojKey'];\n};\n\n/**\n * Returns the key for the row at the given index\n */\nexport const getRowKeyForRowIndex = (root: HTMLElement, tableId: string, index: number) => {\n  if (root != null) {\n    const rowElements = root.querySelectorAll(`[data-oj-table-data-row='${tableId}']`);\n    if (rowElements.length > index) {\n      return getRowKey(rowElements[index] as HTMLElement);\n    }\n  }\n  return null;\n};\n\n/**\n * Returns the index of the given row element\n */\nexport const getRowIndexForRowElement = (\n  root: HTMLElement,\n  tableId: string,\n  rowElement: HTMLElement\n) => {\n  if (root != null) {\n    const rowElements = root.querySelectorAll(`[data-oj-table-data-row='${tableId}']`);\n    const index = Array.prototype.indexOf.call(rowElements, rowElement);\n    if (index > -1) {\n      return index;\n    }\n  }\n  return null;\n};\n\n/**\n * Returns the index of the row for the given key.\n */\nexport function getRowIndexForRowKey<K>(root: HTMLElement, tableId: string, rowKey: K) {\n  if (root != null) {\n    const rowElements = root.querySelectorAll(`[data-oj-table-data-row='${tableId}']`);\n    for (let i = 0; i < rowElements.length; i++) {\n      if (rowKey === getRowKey(rowElements[i] as HTMLElement)) {\n        return i;\n      }\n    }\n  }\n  return null;\n}\n\n/**\n * Returns the column key for the given cell element\n */\nexport const getColumnKey = (element: HTMLElement) => {\n  return element.dataset['ojColumnKeyType'] === 'number'\n    ? Number(element.dataset['ojColumnKey'])\n    : element.dataset['ojColumnKey'];\n};\n\n/**\n * Returns the key for the column at the given index\n */\nexport const getColumnKeyForColumnIndex = (root: HTMLElement, tableId: string, index: number) => {\n  if (root != null) {\n    const headerElements = root.querySelectorAll(`[data-oj-table-header-cell='${tableId}']`);\n    if (headerElements.length > index) {\n      return getColumnKey(headerElements[index] as HTMLElement);\n    }\n  }\n  return null;\n};\n\n/**\n * Returns the index of the given column header element or footer element\n */\nexport const getColumnIndexForHeaderFooterElement = (\n  root: HTMLElement,\n  tableId: string,\n  cellElement: HTMLElement,\n  isHeader: boolean\n) => {\n  if (root != null) {\n    const columnElements = root.querySelectorAll(\n      isHeader\n        ? `[data-oj-table-header-cell='${tableId}']`\n        : `[data-oj-table-footer-cell='${tableId}']`\n    );\n    const index = Array.prototype.indexOf.call(columnElements, cellElement);\n    if (index > -1) {\n      return index;\n    }\n  }\n  return null;\n};\n\n/**\n * Helper method to get the cell key definition from an element\n */\nexport function logicalCellExtractor<K, C>(\n  element: HTMLElement,\n  tableId: string,\n  cellSelector: string,\n  onlyAncestors?: boolean\n): Cell<K, C> | null {\n  const startingElement = onlyAncestors ? element.parentElement : element;\n  if (startingElement != null) {\n    const cellElement = startingElement.closest(cellSelector) as HTMLElement;\n    if (cellElement != null) {\n      const cellType = getCellType(cellElement);\n      if (cellType === 'data') {\n        return {\n          rowKey: keyExtractor(cellElement, `[data-oj-table-data-row='${tableId}']`) as K,\n          columnKey: getColumnKey(cellElement) as C,\n          type: cellType\n        };\n      } else if (cellType === 'header' || cellType === 'footer') {\n        return {\n          columnKey: getColumnKey(cellElement) as C,\n          type: cellType\n        };\n      } else if (cellType === 'noData') {\n        return {\n          type: cellType\n        };\n      }\n    }\n  }\n  return null;\n}\n\n/**\n * Helper method to get an element from a cell descriptor\n */\nexport function getElementFromCell<K, C>(\n  root: HTMLElement,\n  tableId: string,\n  cell: Cell<K, C>\n): HTMLElement | null {\n  if (cell.type === 'header') {\n    // header case\n    const headerElements = root.querySelectorAll(`[data-oj-table-header-cell='${tableId}']`);\n    for (const headerElement of headerElements) {\n      if (cell.columnKey === getColumnKey(headerElement as HTMLElement)) {\n        return headerElement as HTMLElement;\n      }\n    }\n  } else if (cell.type === 'footer') {\n    // footer case\n    const footerElements = root.querySelectorAll(`[data-oj-table-footer-cell='${tableId}']`);\n    for (const footerElement of footerElements) {\n      if (cell.columnKey === getColumnKey(footerElement as HTMLElement)) {\n        return footerElement as HTMLElement;\n      }\n    }\n  } else if (cell.type === 'data') {\n    // data body case\n    const rowElements = root.querySelectorAll(`[data-oj-table-data-row='${tableId}']`);\n    for (const rowElement of rowElements) {\n      if (cell.rowKey === getRowKey(rowElement as HTMLElement)) {\n        const cellElements = rowElement.querySelectorAll(`[data-oj-table-focusable='${tableId}']`);\n        for (const cellElement of cellElements) {\n          if (cell.columnKey === getColumnKey(cellElement as HTMLElement)) {\n            return cellElement as HTMLElement;\n          }\n        }\n      }\n    }\n  } else if (cell.type === 'noData') {\n    // no data case\n    return root.querySelector(`[data-oj-table-nodata-cell='${tableId}']`) as HTMLElement;\n  }\n  return null;\n}\n\n/**\n * Helper method to get the top scroller offset of the Table\n */\nexport const getScrollerTopOffset = (root: HTMLElement, tableId: string) => {\n  const headerRowElement = root.querySelector(\n    `[data-oj-table-header-row='${tableId}']`\n  ) as HTMLElement;\n  return headerRowElement != null ? headerRowElement.getBoundingClientRect().height : 0;\n};\n\n/**\n * Helper method to get the bottom scroller offset of the Table\n */\nexport const getScrollerBottomOffset = (root: HTMLElement, tableId: string) => {\n  const footerRowElement = root.querySelector(\n    `[data-oj-table-footer-row='${tableId}']`\n  ) as HTMLElement;\n  return footerRowElement != null ? footerRowElement.getBoundingClientRect().height : 0;\n};\n\n/**\n * Returns the key of the first focusable row in the Table\n */\nexport const getFirstFocusableRowKey = (root: HTMLElement, tableId: string) => {\n  if (root != null) {\n    const firstRowElement = root.querySelector(`[data-oj-table-data-row='${tableId}']`);\n    if (firstRowElement != null) {\n      return getRowKey(firstRowElement as HTMLElement);\n    }\n  }\n  return null;\n};\n\n/**\n * Returns the key of the last focusable row in the Table\n */\nexport const getLastFocusableRowKey = (root: HTMLElement, tableId: string) => {\n  const rowElements = root.querySelectorAll(`[data-oj-table-data-row='${tableId}']`);\n  const rowCount = rowElements.length;\n  if (rowCount > 0) {\n    return getRowKey(rowElements[rowCount - 1] as HTMLElement);\n  }\n  return null;\n};\n\n/**\n * Returns the cell definition of the first rendered cell in the Table\n */\nexport const getFirstFocusableCell = (root: HTMLElement, tableId: string) => {\n  if (root != null) {\n    const firstCellElement = root.querySelector(\n      `[data-oj-table-focusable='${tableId}']`\n    ) as HTMLElement;\n    if (firstCellElement != null) {\n      const firstCellType = getCellType(firstCellElement);\n      if (firstCellType === 'header' || firstCellType === 'footer') {\n        return { columnKey: getColumnKey(firstCellElement), type: firstCellType };\n      } else if (firstCellType === 'noData') {\n        return { type: 'noData' };\n      }\n      return {\n        rowKey: getRowKey(firstCellElement),\n        columnKey: getColumnKey(firstCellElement),\n        type: 'data'\n      };\n    }\n  }\n  return null;\n};\n\n/**\n * Helper method to determine if the no data cell is present in the Table\n */\nexport const hasNoDataCell = (root: HTMLElement, tableId: string) => {\n  if (root != null) {\n    return root.querySelectorAll(`[data-oj-table-nodata-cell='${tableId}']`).length > 0;\n  }\n  return false;\n};\n\n/**\n * Helper method to determine if footer cells are present in the Table\n */\nexport const hasFooterCells = (root: HTMLElement, tableId: string) => {\n  if (root != null) {\n    return root.querySelectorAll(`[data-oj-table-footer-row='${tableId}']`).length > 0;\n  }\n  return false;\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { RefObject } from 'preact';\nimport { ScrollDetail, SizingInfo, TableColumn } from '../Table';\nimport { TableHorizontalScrollPosition, TableVerticalScrollPosition } from '../../UNSAFE_TableView';\nimport { ViewportConfig } from '../../hooks/UNSAFE_useViewportIntersect';\nimport { findElementByKey } from '../../utils/PRIVATE_collectionUtils';\nimport {\n  getColumnKey,\n  getElementFromCell,\n  getRowKey,\n  getRowKeyForRowIndex,\n  getScrollerBottomOffset,\n  getScrollerTopOffset\n} from './TableDomUtils';\n\n/**\n * A helper function to make sure specified elem is visible in the specified container\n */\nfunction _scrollColumnIntoView<K, D, C>(\n  columnElement: HTMLElement,\n  scrollerElement: HTMLElement,\n  columnsArray: TableColumn<K, D, C>[],\n  scrollbarWidth: number,\n  isRtl: boolean,\n  fullColumnWidths?: number[],\n  location?: 'inView' | 'start' | 'end'\n) {\n  const columnKey = getColumnKey(columnElement);\n\n  let columnIndex;\n  for (let i = 0; i < columnsArray.length; i++) {\n    if (columnsArray[i].key === columnKey) {\n      columnIndex = i;\n      break;\n    }\n  }\n  if (columnIndex != null && fullColumnWidths != null) {\n    let startOffset = 0;\n    let endOffset = 0;\n\n    const stickyStartColumns = getStickyColumnIndicies(columnsArray, true);\n    for (let i = 0; i < stickyStartColumns.length; i++) {\n      const stickyIndex = stickyStartColumns[i];\n      if (stickyIndex < columnIndex) {\n        startOffset += fullColumnWidths[stickyIndex];\n      } else {\n        break;\n      }\n    }\n    const stickyEndColumns = getStickyColumnIndicies(columnsArray, false);\n    for (let i = stickyEndColumns.length - 1; i > -1; i--) {\n      const stickyIndex = stickyEndColumns[i];\n      if (stickyIndex > columnIndex) {\n        endOffset += fullColumnWidths[stickyIndex];\n      } else {\n        break;\n      }\n    }\n\n    const horizontalOverflowDiff = _getHorizontalOverflowDiff(\n      columnElement,\n      scrollerElement,\n      startOffset,\n      endOffset,\n      scrollbarWidth,\n      isRtl\n    );\n    const leftOverflowDiff = horizontalOverflowDiff.left;\n    const hasLeftOverflow = leftOverflowDiff >= 0;\n    const rightOverflowDiff = horizontalOverflowDiff.right;\n    const hasRightOverflow = rightOverflowDiff >= 0;\n\n    // don't adjust scroll position if row has overflow in both directions\n    if (hasLeftOverflow && hasRightOverflow) {\n      return;\n    }\n\n    if (location == null || location === 'inView') {\n      // if column fits fully in viewport, scroll overflow side into view\n      // otherwise, scroll the shortest amount to fill viewport with column\n      if (hasLeftOverflow) {\n        if (Math.abs(rightOverflowDiff) > Math.abs(leftOverflowDiff)) {\n          scrollerElement.scrollLeft = _roundScrollValue(\n            scrollerElement.scrollLeft - leftOverflowDiff,\n            false\n          );\n        } else {\n          scrollerElement.scrollLeft = _roundScrollValue(\n            scrollerElement.scrollLeft + rightOverflowDiff,\n            true\n          );\n        }\n      } else if (hasRightOverflow) {\n        if (Math.abs(leftOverflowDiff) > Math.abs(rightOverflowDiff)) {\n          scrollerElement.scrollLeft = _roundScrollValue(\n            scrollerElement.scrollLeft + rightOverflowDiff,\n            true\n          );\n        } else {\n          scrollerElement.scrollLeft = _roundScrollValue(\n            scrollerElement.scrollLeft - leftOverflowDiff,\n            false\n          );\n        }\n      }\n    } else if (location === 'start') {\n      scrollerElement.scrollLeft = _roundScrollValue(\n        scrollerElement.scrollLeft - leftOverflowDiff,\n        false\n      );\n    } else {\n      scrollerElement.scrollLeft = _roundScrollValue(\n        scrollerElement.scrollLeft + rightOverflowDiff,\n        true\n      );\n    }\n  }\n}\n\n/**\n * A helper function to make sure specified elem is visible in the specified container\n */\nconst _scrollRowIntoView = (\n  root: HTMLDivElement,\n  tableId: string,\n  rowElement: HTMLElement,\n  scrollerElement: HTMLElement,\n  scrollbarHeight: number,\n  location?: 'inView' | 'top' | 'bottom'\n) => {\n  const topOffset = getScrollerTopOffset(root, tableId);\n  const bottomOffset = getScrollerBottomOffset(root, tableId);\n  const verticalOverflowDiff = _getVerticalOverflowDiff(\n    rowElement,\n    scrollerElement,\n    topOffset,\n    bottomOffset,\n    scrollbarHeight\n  );\n  const topOverflowDiff = verticalOverflowDiff.top;\n  const hasTopOverflow = topOverflowDiff >= 0;\n  const bottomOverflowDiff = verticalOverflowDiff.bottom;\n  const hasBottomOverflow = bottomOverflowDiff >= 0;\n\n  // don't adjust scroll position if row has overflow in both directions\n  if (hasTopOverflow && hasBottomOverflow) {\n    return;\n  }\n  if (location == null || location === 'inView') {\n    // if row fits fully in viewport, scroll overflow side into view\n    // otherwise, scroll the shortest amount to fill viewport with row\n    if (hasBottomOverflow) {\n      if (Math.abs(topOverflowDiff) > Math.abs(bottomOverflowDiff)) {\n        scrollerElement.scrollTop = _roundScrollValue(\n          scrollerElement.scrollTop + bottomOverflowDiff,\n          true\n        );\n      } else {\n        scrollerElement.scrollTop = _roundScrollValue(\n          scrollerElement.scrollTop - topOverflowDiff,\n          false\n        );\n      }\n    } else if (hasTopOverflow) {\n      if (Math.abs(bottomOverflowDiff) > Math.abs(topOverflowDiff)) {\n        scrollerElement.scrollTop = _roundScrollValue(\n          scrollerElement.scrollTop - topOverflowDiff,\n          false\n        );\n      } else {\n        scrollerElement.scrollTop = _roundScrollValue(\n          scrollerElement.scrollTop + bottomOverflowDiff,\n          true\n        );\n      }\n    }\n  } else if (location === 'top') {\n    scrollerElement.scrollTop = _roundScrollValue(\n      scrollerElement.scrollTop - topOverflowDiff,\n      false\n    );\n  } else {\n    scrollerElement.scrollTop = _roundScrollValue(\n      scrollerElement.scrollTop + bottomOverflowDiff,\n      true\n    );\n  }\n};\n\n/**\n * Helper method to round a desired scrollTop or scrollLeft value to the nearest valid value\n * depending on the client browser.\n */\nconst _roundScrollValue = (value: number, isOver: boolean) => {\n  // use Math.floor() and Math.ceil() to ensure we round to nearest containing valid\n  // pixel value in either direction as valid scrollTop values are only integers\n  return isOver ? Math.ceil(value) : Math.floor(value);\n};\n\n/**\n * A helper to get the horizontal overflow diff of the given element\n */\nconst _getHorizontalOverflowDiff = (\n  element: HTMLElement,\n  scrollerElement: HTMLElement,\n  startOffset: number,\n  endOffset: number,\n  scrollbarWidth: number,\n  isRtl: boolean\n) => {\n  const elementRect = element.getBoundingClientRect();\n  const scrollerRect = scrollerElement.getBoundingClientRect();\n\n  if (isRtl) {\n    return {\n      left: scrollerRect.left - elementRect.left + endOffset + scrollbarWidth,\n      right: elementRect.right - scrollerRect.right + startOffset\n    };\n  } else {\n    return {\n      left: scrollerRect.left - elementRect.left + startOffset,\n      right: elementRect.right - scrollerRect.right + endOffset + scrollbarWidth\n    };\n  }\n};\n\n/**\n * A helper to get the vertical overflow diff of the given element\n */\nexport const _getVerticalOverflowDiff = (\n  element: HTMLElement,\n  scrollerElement: HTMLElement,\n  topOffset: number,\n  bottomOffset: number,\n  scrollbarHeight: number\n) => {\n  const elementRect = element.getBoundingClientRect();\n  const scrollerRect = scrollerElement.getBoundingClientRect();\n\n  return {\n    top: scrollerRect.top - elementRect.top + topOffset,\n    bottom: elementRect.bottom - scrollerRect.bottom + bottomOffset + scrollbarHeight\n  };\n};\n\n/**\n * Helper to set the horizontal scroll position on the Table.\n */\nexport function setHorizontalScrollPosition<K, D, C>(\n  root: HTMLDivElement,\n  columnsArray: TableColumn<K, D, C>[],\n  fullColumnWidths: number[],\n  isRtl: boolean,\n  horizontalScrollPosition?: TableHorizontalScrollPosition<C>\n) {\n  const x = _getScrollLeftFromScrollPosition(\n    root,\n    columnsArray,\n    fullColumnWidths,\n    horizontalScrollPosition\n  );\n  root.scrollLeft = x != null ? (isRtl ? -x : x) : 0;\n}\n\n/**\n * Helper to set the vertical scroll position on the Table.\n */\nexport function setVerticalScrollPosition<K>(\n  root: HTMLDivElement,\n  tableId: string,\n  verticalScrollPosition?: TableVerticalScrollPosition<K>\n) {\n  const y = _getScrollTopFromScrollPosition(root, tableId, verticalScrollPosition);\n  root.scrollTop = y != null ? y : 0;\n}\n\n/**\n * Helper to determine the 'x' value of a given scroll position.\n */\nfunction _getScrollLeftFromScrollPosition<K, D, C>(\n  root: HTMLDivElement,\n  columnsArray: TableColumn<K, D, C>[],\n  fullColumnWidths: number[],\n  scrollPosition?: TableHorizontalScrollPosition<C>\n) {\n  if (scrollPosition != null) {\n    let columnKey;\n    let useColumn = false;\n    if (scrollPosition.columnKey != null) {\n      // columnKey takes precedence over everything else\n      useColumn = true;\n      columnKey = scrollPosition.columnKey;\n    } else if (scrollPosition.offsetX != null && scrollPosition.x == null) {\n      // offsetX can be used on its own if it is the only horizontal aspect provided\n      useColumn = true;\n      const currentHorizontalScrollPosition = getHorizontalScrollPosition(\n        root,\n        columnsArray,\n        fullColumnWidths\n      );\n      columnKey = currentHorizontalScrollPosition.columnKey;\n    }\n    if (useColumn) {\n      if (columnKey != null) {\n        let x = 0;\n        for (let i = 0; i < fullColumnWidths.length; i++) {\n          if (columnsArray[i].key === columnKey) {\n            return x + (scrollPosition.offsetX != null ? scrollPosition.offsetX : 0);\n          }\n          if (columnsArray[i].value.stickyEdge !== 'start') {\n            x += fullColumnWidths[i];\n          }\n        }\n      }\n    } else if (scrollPosition.x != null) {\n      return scrollPosition.x;\n    }\n  }\n  // either nothing was provided, or what was provided was invalid\n  return undefined;\n}\n\n/**\n * Helper to determine the 'y' value of a given scroll position.\n */\nfunction _getScrollTopFromScrollPosition<K>(\n  root: HTMLDivElement,\n  tableId: string,\n  scrollPosition?: TableVerticalScrollPosition<K>\n) {\n  if (scrollPosition != null) {\n    let rowKey;\n    let useRow = false;\n    if (scrollPosition.rowKey != null) {\n      // rowKey takes precedence over everything else\n      useRow = true;\n      rowKey = scrollPosition.rowKey;\n    } else if (scrollPosition.offsetY != null && scrollPosition.y == null) {\n      // offsetY can be used on its own if it is the only vertical aspect provided\n      useRow = true;\n      rowKey = getVerticalScrollPosition(root, tableId).rowKey;\n    }\n    if (useRow) {\n      if (rowKey != null) {\n        let y = 0;\n        const rowElements = root.querySelectorAll(`[data-oj-table-data-row='${tableId}']`);\n        for (let i = 0; i < rowElements.length; i++) {\n          if (rowKey === getRowKey(rowElements[i] as HTMLElement)) {\n            return y + (scrollPosition.offsetY != null ? scrollPosition.offsetY : 0);\n          }\n          y += rowElements[i].getBoundingClientRect().height;\n        }\n      }\n    } else if (scrollPosition.y != null) {\n      return scrollPosition.y;\n    }\n  }\n  // either nothing was provided, or what was provided was invalid\n  return undefined;\n}\n\n/**\n * Helper to get the logical scroll position for the given scrollLeft value. If no scrollLeft value is given,\n * it will use the current scrollLeft value of the Table.\n */\nexport function getHorizontalScrollPosition<K, D, C>(\n  root: HTMLDivElement,\n  columnsArray: TableColumn<K, D, C>[],\n  fullColumnWidths: number[],\n  newScrollLeft?: number\n) {\n  // ensure scroll position x value is initialized\n  const scrollLeft = Math.abs(newScrollLeft == null ? root.scrollLeft : newScrollLeft);\n\n  const scrollPosition: TableHorizontalScrollPosition<C> = {\n    x: scrollLeft,\n    columnKey: undefined,\n    offsetX: undefined\n  };\n\n  let columnEnd = 0;\n  if (columnsArray.length > 0) {\n    if (scrollLeft === 0) {\n      scrollPosition.columnKey = columnsArray[0].key;\n      scrollPosition.offsetX = 0;\n      return scrollPosition;\n    }\n  }\n  for (let i = 0; i < columnsArray.length; i++) {\n    if (columnsArray[i].value.stickyEdge !== 'start') {\n      columnEnd += fullColumnWidths[i];\n    }\n    if (scrollLeft < columnEnd) {\n      scrollPosition.columnKey = columnsArray[i].key;\n      scrollPosition.offsetX = fullColumnWidths[i] + scrollLeft - columnEnd;\n      break;\n    }\n  }\n  return scrollPosition;\n}\n\n/**\n * Helper to get the logical scroll position for the given scrollTop value. If no scrollTop value is given,\n * it will use the current scrollTop value of the Table.\n */\nexport function getVerticalScrollPosition<K>(\n  root: HTMLDivElement,\n  tableId: string,\n  newScrollTop?: number\n) {\n  // ensure scroll position y value is initialized\n  const scrollTop = Math.abs(newScrollTop == null ? root.scrollTop : newScrollTop);\n\n  const scrollPosition: TableVerticalScrollPosition<K> = {\n    y: scrollTop,\n    rowKey: undefined,\n    offsetY: undefined\n  };\n\n  let rowBottom = 0;\n  const rowElements = root.querySelectorAll(`[data-oj-table-data-row='${tableId}']`);\n  if (rowElements.length > 0) {\n    if (scrollTop === 0) {\n      scrollPosition.rowKey = getRowKeyForRowIndex(root, tableId, 0) as K;\n      scrollPosition.offsetY = 0;\n      return scrollPosition;\n    }\n  }\n  for (let i = 0; i < rowElements.length; i++) {\n    const rowHeight = rowElements[i].getBoundingClientRect().height;\n    rowBottom += rowHeight;\n    if (scrollTop < rowBottom) {\n      scrollPosition.rowKey = getRowKeyForRowIndex(root, tableId, i) as K;\n      scrollPosition.offsetY = rowHeight + scrollTop - rowBottom;\n      break;\n    }\n  }\n  return scrollPosition;\n}\n\nexport function applyScrollDetail<K extends string | number, D, C>(\n  root: HTMLDivElement,\n  tableId: string,\n  columnsArray: TableColumn<K, D, C>[],\n  sizingInfo: SizingInfo,\n  scrollDetail: ScrollDetail<K, C>,\n  isRtl: boolean,\n  fullColumnWidths?: number[],\n  viewportConfig?: ViewportConfig\n) {\n  const scroller = viewportConfig?.scroller() || root;\n  if (scrollDetail.cell.type === 'data') {\n    const rowElement = findElementByKey(\n      root,\n      scrollDetail.cell.rowKey,\n      `[data-oj-table-data-row='${tableId}']`\n    ) as HTMLElement;\n    if (rowElement != null) {\n      _scrollRowIntoView(\n        root,\n        tableId,\n        rowElement,\n        scroller,\n        sizingInfo.boxHeight! - sizingInfo.contentHeight!,\n        scrollDetail.locationY\n      );\n    }\n  }\n  const cellElement = getElementFromCell(root, tableId, scrollDetail.cell);\n  if (cellElement != null) {\n    _scrollColumnIntoView(\n      cellElement,\n      scroller,\n      columnsArray,\n      sizingInfo.boxWidth! - sizingInfo.contentWidth!,\n      isRtl,\n      fullColumnWidths,\n      scrollDetail.locationX\n    );\n  }\n}\n\n/**\n * Helper function to update the 'left' and 'right' values of all sticky columns to correspond\n * to the given sizing information.\n */\nexport function updateStickyColumns<K, D, C>(\n  root: HTMLDivElement,\n  tableId: string,\n  isRtl: boolean,\n  columnsArray: TableColumn<K, D, C>[],\n  fullColumnWidths: number[],\n  stickyEdgesState: { start?: number; end?: number },\n  setStickyEdgesState: (stickyEdgesState: { start?: number; end?: number }) => void\n) {\n  let stickyIndex;\n  let stickyStartOffset = 0;\n  let stickyEndOffset = 0;\n\n  const stickyStartIndicies = getStickyColumnIndicies(columnsArray, true);\n  for (let i = 0; i < stickyStartIndicies.length; i++) {\n    stickyIndex = stickyStartIndicies[i];\n    _applyStickyColumnOffset(root, tableId, isRtl, stickyIndex, stickyStartOffset, true);\n    stickyStartOffset += fullColumnWidths[stickyIndex];\n  }\n  const stickyEndIndicies = getStickyColumnIndicies(columnsArray, false);\n  for (let i = stickyEndIndicies.length - 1; i > -1; i--) {\n    stickyIndex = stickyEndIndicies[i];\n    _applyStickyColumnOffset(root, tableId, isRtl, stickyIndex, stickyEndOffset, false);\n    stickyEndOffset += fullColumnWidths[stickyIndex];\n  }\n\n  updateStickyEdges(root, columnsArray, fullColumnWidths, stickyEdgesState, setStickyEdgesState);\n}\n\n/**\n * Helper function to get the column indicies corresponding to the given edge.\n */\nexport const getStickyColumnIndicies = <K, D, C>(\n  columnsArray: TableColumn<K, D, C>[],\n  isStart: boolean\n) => {\n  const stickyColumns = [];\n  const edge = isStart ? 'start' : 'end';\n  for (let i = 0; i < columnsArray.length; i++) {\n    if (columnsArray[i].value.stickyEdge === edge) {\n      stickyColumns.push(i);\n    }\n  }\n  return stickyColumns;\n};\n\n/**\n * Helper function to update the 'left' and 'right' values of a specific column.\n */\nconst _applyStickyColumnOffset = (\n  root: HTMLDivElement,\n  tableId: string,\n  isRtl: boolean,\n  columnIndex: number,\n  stickyOffset: number,\n  isStart: boolean\n) => {\n  const styleProperty = (isStart && !isRtl) || (!isStart && isRtl) ? 'left' : 'right';\n  const styleValue = `${stickyOffset}px`;\n\n  const headerElements = root.querySelectorAll(`[data-oj-table-header-cell='${tableId}']`);\n  const headerElement = headerElements[columnIndex] as HTMLElement;\n  headerElement.style[styleProperty] = styleValue;\n\n  const rowElements = root.querySelectorAll(`[data-oj-table-data-row='${tableId}']`);\n  for (let j = 0; j < rowElements.length; j++) {\n    const rowElement = rowElements[j] as HTMLElement;\n    const cellElements = rowElement.querySelectorAll(`[data-oj-table-data-cell='${tableId}']`);\n    const cellElement = cellElements[columnIndex] as HTMLElement;\n    cellElement.style[styleProperty] = styleValue;\n  }\n\n  const footerElements = root.querySelectorAll(`[data-oj-table-footer-cell='${tableId}']`);\n  if (footerElements.length > 0) {\n    const footerElement = footerElements[columnIndex] as HTMLElement;\n    footerElement.style[styleProperty] = styleValue;\n  }\n};\n\n/**\n * Helper function to update the sticky edges based on the given scrollLeft value.\n */\nexport function updateStickyEdges<K, D, C>(\n  root: HTMLDivElement,\n  columnsArray: TableColumn<K, D, C>[],\n  fullColumnWidths: number[],\n  stickyEdgesState: { start?: number; end?: number },\n  setStickyEdgesState: (stickyEdgesState: { start?: number; end?: number }) => void,\n  scrollLeft?: number\n) {\n  if (columnsArray.length > 0) {\n    let i;\n    let currentScrollIndex;\n    const newScrollPosition = getHorizontalScrollPosition(\n      root,\n      columnsArray,\n      fullColumnWidths,\n      scrollLeft\n    );\n    for (i = 0; i < columnsArray.length; i++) {\n      if (columnsArray[i].key === newScrollPosition.columnKey) {\n        currentScrollIndex = i;\n        break;\n      }\n    }\n\n    let startIndex;\n    // browser zoom levels cause rounding issues where the start scroll\n    // position may never be reached, but it should always be within 1\n    if (newScrollPosition.x! >= 1) {\n      const stickyStartIndicies = getStickyColumnIndicies(columnsArray, true);\n      for (i = 0; i < stickyStartIndicies.length; i++) {\n        const currentIndex = stickyStartIndicies[i];\n        if (currentIndex < currentScrollIndex!) {\n          startIndex = currentIndex;\n        } else {\n          break;\n        }\n      }\n    }\n\n    let endIndex;\n    let currentWidth = 0;\n    const maxScrollPos = root.scrollWidth - root.clientWidth;\n    const endOverflow = maxScrollPos - newScrollPosition.x!;\n    // browser zoom levels cause rounding issues where the max scroll\n    // position may never be reached, but it should always be within 1\n    if (endOverflow >= 1) {\n      const stickyEndIndicies = getStickyColumnIndicies(columnsArray, false);\n      for (let i = columnsArray.length - 1; i > -1; i--) {\n        if (stickyEndIndicies.indexOf(i) !== -1) {\n          endIndex = i;\n        } else {\n          currentWidth += fullColumnWidths[i];\n          if (currentWidth > endOverflow) {\n            break;\n          }\n        }\n      }\n    }\n    if (stickyEdgesState.start != startIndex || stickyEdgesState.end != endIndex) {\n      setStickyEdgesState({ start: startIndex, end: endIndex });\n    }\n  }\n}\n\n/**\n * Helper function to get the viewport config. TODO: this needs help for table still\n */\nexport const getViewportConfig = (\n  outerTableRef: RefObject<HTMLElement>,\n  config?: ViewportConfig\n) => {\n  return (\n    config ?? {\n      scroller: () => {\n        return outerTableRef.current;\n      }\n    }\n  );\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { MutableRef } from 'preact/hooks';\nimport { SizingInfo, TableColumn } from '../Table';\nimport {\n  getFirstFocusableRowKey,\n  getLastFocusableRowKey,\n  getRowKey,\n  hasFooterCells,\n  hasNoDataCell,\n  getScrollerBottomOffset,\n  getRowKeyForRowIndex,\n  getRowIndexForRowKey\n} from './TableDomUtils';\nimport { applyScrollDetail, getVerticalScrollPosition } from './TableScrollUtils';\nimport { Cell, CurrentCellDetail } from '../../UNSAFE_TableView';\nimport { findElementByKey } from '../../utils/PRIVATE_collectionUtils';\n\n/**\n * Helper function to compare two given cell descriptors.\n */\nexport function cellComparator<K, C>(cell1?: Cell<K, C> | null, cell2?: Cell<K, C> | null) {\n  if (cell1 == null) {\n    return cell2 == null;\n  }\n  if (cell2 == null) {\n    return false;\n  }\n  return (\n    cell1?.rowKey === cell2?.rowKey &&\n    cell1?.columnKey === cell2?.columnKey &&\n    cell1?.type === cell2?.type\n  );\n}\n\n/**\n * Helper function to handle an 'Up' or 'Down' arrow key press.\n * Up - Moves to the same cell in the previous row (including headers and footers). No op if already on the first row.\n * Down - Moves to the same cell in the next row (including headers and footers). No op if already on the last row.\n */\nexport function handleAdjacentRowGesture<K extends string | number, D, C>(\n  root: HTMLDivElement,\n  tableId: string,\n  columnsArray: TableColumn<K, D, C>[],\n  initialCell: Cell<K, C>,\n  onCurrentCellChanged: (detail: CurrentCellDetail<K, C>) => void,\n  isPrevious: boolean\n) {\n  let newCurrentCell;\n  const cellType = initialCell.type;\n  if (cellType !== 'noData') {\n    const columnKey = initialCell.columnKey;\n    if (cellType === 'data') {\n      const currentRowKey = initialCell.rowKey;\n      const currentRowElement = findElementByKey(\n        root,\n        currentRowKey as string | number,\n        `[data-oj-table-data-row='${tableId}']`\n      );\n      if (currentRowElement != null) {\n        const adjacentRowElement = isPrevious\n          ? (currentRowElement.previousElementSibling as HTMLElement)\n          : (currentRowElement.nextElementSibling as HTMLElement);\n        if (adjacentRowElement != null) {\n          const rowKey = getRowKey(adjacentRowElement) as K;\n          if (rowKey != null) {\n            newCurrentCell = { rowKey: rowKey, columnKey: columnKey, type: 'data' } as Cell<K, C>;\n            onCurrentCellChanged({ value: newCurrentCell });\n          }\n        } else if (isPrevious) {\n          newCurrentCell = { columnKey: initialCell.columnKey, type: 'header' } as Cell<K, C>;\n          onCurrentCellChanged({ value: newCurrentCell });\n        } else if (hasFooterCells(root, tableId)) {\n          newCurrentCell = { columnKey: initialCell.columnKey, type: 'footer' } as Cell<K, C>;\n          onCurrentCellChanged({ value: newCurrentCell });\n        }\n      }\n    } else if (cellType === 'header' && !isPrevious) {\n      const rowKey = getFirstFocusableRowKey(root, tableId) as K;\n      if (rowKey != null) {\n        newCurrentCell = { rowKey: rowKey, columnKey: columnKey, type: 'data' } as Cell<K, C>;\n        onCurrentCellChanged({ value: newCurrentCell });\n      } else if (hasNoDataCell(root, tableId)) {\n        newCurrentCell = { type: 'noData' } as Cell<K, C>;\n        onCurrentCellChanged({ value: newCurrentCell });\n      } else if (hasFooterCells(root, tableId)) {\n        newCurrentCell = { columnKey: initialCell.columnKey, type: 'footer' } as Cell<K, C>;\n        onCurrentCellChanged({ value: newCurrentCell });\n      }\n    } else if (cellType === 'footer' && isPrevious) {\n      const rowKey = getLastFocusableRowKey(root, tableId) as K;\n      if (rowKey != null) {\n        newCurrentCell = { rowKey: rowKey, columnKey: columnKey, type: 'data' } as Cell<K, C>;\n        onCurrentCellChanged({ value: newCurrentCell });\n      } else if (hasNoDataCell(root, tableId)) {\n        newCurrentCell = { type: 'noData' } as Cell<K, C>;\n        onCurrentCellChanged({ value: newCurrentCell });\n      } else {\n        newCurrentCell = { columnKey: initialCell.columnKey, type: 'header' } as Cell<K, C>;\n        onCurrentCellChanged({ value: newCurrentCell });\n      }\n    }\n  } else {\n    const newColumnKey = _getBoundaryColumnKey(columnsArray, true);\n    if (isPrevious) {\n      newCurrentCell = { columnKey: newColumnKey, type: 'header' } as Cell<K, C>;\n      onCurrentCellChanged({ value: newCurrentCell });\n    } else if (hasFooterCells(root, tableId)) {\n      newCurrentCell = { columnKey: newColumnKey, type: 'footer' } as Cell<K, C>;\n      onCurrentCellChanged({ value: newCurrentCell });\n    }\n  }\n}\n\n/**\n * Helper function to handle a 'PageUp' or 'PageDown' arrow key press.\n * PageUp - Moves to the same cell in the first visible row in the current viewport,\n * and scrolls the Table so it becomes the last visible row in the viewport when able.\n * PageDown - Moves to the same cell in the last visible row in the current viewport,\n * and scrolls the Table so it becomes the first visible row in the viewport when able.\n */\nexport function handlePageRowGesture<K extends string | number, D, C>(\n  root: HTMLDivElement,\n  tableId: string,\n  columnsArray: TableColumn<K, D, C>[],\n  sizingInfoRef: MutableRef<SizingInfo>,\n  initialCell: Cell<K, C>,\n  onCurrentCellChanged: (detail: CurrentCellDetail<K, C>) => void,\n  isPrevious: boolean,\n  isRtl: boolean,\n  fullColumnWidths?: number[]\n) {\n  const rowElements = root.querySelectorAll(`[data-oj-table-data-row='${tableId}']`);\n  if (rowElements.length > 0) {\n    const verticalScrollPosition = getVerticalScrollPosition(root, tableId);\n    const verticalRowIndex = getRowIndexForRowKey(root, tableId, verticalScrollPosition.rowKey!);\n    let targetRowIndex;\n    if (isPrevious) {\n      if (verticalScrollPosition.offsetY === 0) {\n        targetRowIndex = Math.max(verticalRowIndex! - 1, 0);\n      } else {\n        targetRowIndex = verticalRowIndex!;\n      }\n    } else {\n      const scrollerRect = root.getBoundingClientRect();\n      const scrollbarHeight =\n        sizingInfoRef.current.boxHeight! - sizingInfoRef.current.contentHeight!;\n      const scrollerBottom =\n        scrollerRect.bottom + getScrollerBottomOffset(root, tableId) + scrollbarHeight;\n      targetRowIndex = verticalRowIndex!;\n      while (rowElements.length > targetRowIndex + 1) {\n        targetRowIndex += 1;\n        const elementBottom = rowElements[targetRowIndex].getBoundingClientRect().bottom;\n        if (elementBottom > scrollerBottom) {\n          break;\n        }\n      }\n    }\n    const newRowKey = getRowKeyForRowIndex(root, tableId, targetRowIndex) as K;\n    if (newRowKey != null) {\n      const newCurrentCell = {\n        rowKey: newRowKey,\n        columnKey: initialCell.columnKey,\n        type: 'data'\n      } as Cell<K, C>;\n      if (newRowKey !== initialCell.rowKey) {\n        onCurrentCellChanged({ value: newCurrentCell });\n      }\n      applyScrollDetail(\n        root,\n        tableId,\n        columnsArray,\n        sizingInfoRef.current,\n        { cell: newCurrentCell, locationX: 'inView', locationY: isPrevious ? 'bottom' : 'top' },\n        isRtl,\n        fullColumnWidths\n      );\n    }\n  }\n}\n\n/**\n * Helper function to get the column key next to the given column key in the specified direction. Returns\n * null if there is no adjacent column in the direction specified.\n */\nfunction _getAdjacentColumnKey<K, D, C>(\n  initialKey: C,\n  columnsArray: TableColumn<K, D, C>[],\n  isPrevious: boolean\n) {\n  let currentIndex = -1;\n  const columnsCount = columnsArray.length;\n  for (let i = 0; i < columnsCount; i++) {\n    if (columnsArray[i].key === initialKey) {\n      currentIndex = i;\n      break;\n    }\n  }\n  if (isPrevious && currentIndex !== 0) {\n    return columnsArray[currentIndex - 1].key;\n  } else if (!isPrevious && currentIndex !== columnsCount - 1) {\n    return columnsArray[currentIndex + 1].key;\n  }\n  return null;\n}\n\n/**\n * Helper function to handle a 'Previous' or 'Next' arrow key press.\n * Previous - Moves to the previous cell in the current row. No op if already on the first cell in that row.\n * Next - Moves to the next cell in the current row. No op if already on the last cell in that row.\n */\nexport function handleAdjacentColumnGesture<K extends string | number, D, C>(\n  columnsArray: TableColumn<K, D, C>[],\n  initialCell: Cell<K, C>,\n  onCurrentCellChanged: (detail: CurrentCellDetail<K, C>) => void,\n  isPrevious: boolean\n) {\n  let newCurrentCell;\n  const cellType = initialCell.type;\n  if (cellType !== 'noData') {\n    const initialKey = initialCell.columnKey;\n    const newKey = _getAdjacentColumnKey(initialKey, columnsArray, isPrevious);\n    if (newKey != null) {\n      if (cellType === 'data') {\n        newCurrentCell = { rowKey: initialCell.rowKey, columnKey: newKey, type: cellType };\n        onCurrentCellChanged({ value: newCurrentCell });\n      } else {\n        newCurrentCell = { columnKey: newKey, type: cellType };\n        onCurrentCellChanged({ value: newCurrentCell });\n      }\n    }\n  }\n}\n\n/**\n * Helper function to get the first or last column key.\n */\nfunction _getBoundaryColumnKey<K, D, C>(columnsArray: TableColumn<K, D, C>[], isFirst: boolean) {\n  if (isFirst) {\n    return columnsArray[0].key;\n  }\n  return columnsArray[columnsArray.length - 1].key;\n}\n\n/**\n * Helper function to handle a 'Home' or 'End' key press.\n * Home - Jumps to the first cell in the current row. No op if already on the first cell in that row.\n * Ctrl/Cmd + Home - Jumps to the first cell in the first data row. If no data rows are present,\n * jumps to the first cell in the current region (header or footer). No op if already on that cell.\n * End - Jumps to the last cell in the current row. No op if already on the last cell in that row.\n * Ctrl/Cmd + End - Jumps to the last cell in the last data row. If no data rows are present,\n * jumps to the last cell in the current region (header or footer). No op if already on that cell.\n */\nexport function handleJumpColumnGesture<K extends string | number, D, C>(\n  root: HTMLDivElement,\n  tableId: string,\n  columnsArray: TableColumn<K, D, C>[],\n  initialCell: Cell<K, C>,\n  onCurrentCellChanged: (detail: CurrentCellDetail<K, C>) => void,\n  isPrevious: boolean,\n  includeRows: boolean\n) {\n  let newCurrentCell;\n  const cellType = initialCell.type;\n  if (cellType !== 'noData') {\n    const initialKey = initialCell.columnKey;\n    const newKey = _getBoundaryColumnKey(columnsArray, isPrevious);\n    if (includeRows) {\n      if (hasNoDataCell(root, tableId)) {\n        newCurrentCell = {\n          type: 'noData'\n        } as Cell<K, C>;\n        if (!cellComparator(newCurrentCell, initialCell)) {\n          onCurrentCellChanged({ value: newCurrentCell });\n        }\n      } else {\n        const newRowKey = isPrevious\n          ? (getFirstFocusableRowKey(root, tableId) as K)\n          : (getLastFocusableRowKey(root, tableId) as K);\n        if (newRowKey != null) {\n          newCurrentCell = {\n            rowKey: newRowKey,\n            columnKey: newKey,\n            type: 'data'\n          } as Cell<K, C>;\n          if (!cellComparator(newCurrentCell, initialCell)) {\n            onCurrentCellChanged({ value: newCurrentCell });\n          }\n        }\n      }\n    } else if (newKey !== initialKey) {\n      if (cellType === 'data') {\n        newCurrentCell = { rowKey: initialCell.rowKey, columnKey: newKey, type: cellType };\n        onCurrentCellChanged({ value: newCurrentCell });\n      } else {\n        newCurrentCell = { columnKey: newKey, type: cellType };\n        onCurrentCellChanged({ value: newCurrentCell });\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { useCallback, useEffect, useMemo, useRef, useState, MutableRef, Ref } from 'preact/hooks';\nimport {\n  getElementContainsFunc,\n  handleEnterActionableMode,\n  handleWrapActionableFocus\n} from '../../utils/PRIVATE_collectionUtils';\nimport {\n  FocusableElement,\n  allTabbableElements,\n  getActiveElement,\n  getBodyElement,\n  isTabbableElement\n} from '../../utils/PRIVATE_tabbableUtils';\nimport { SizingInfo, TableColumn } from '../Table';\nimport {\n  getCellType,\n  getElementFromCell,\n  getFirstFocusableCell,\n  logicalCellExtractor\n} from '../utils/TableDomUtils';\nimport { cellComparator } from '../utils/TableNavigationUtils';\nimport { applyScrollDetail } from '../utils/TableScrollUtils';\nimport { Cell, CurrentCellDetail } from '../../UNSAFE_TableView';\n\ntype UseFocusHandlingProps<K, D, C extends string> = {\n  outerTableRef: Ref<HTMLDivElement>;\n  tableId: string;\n  isRtl: boolean;\n  columnsArray: TableColumn<K, D, C>[];\n  sizingInfoRef: MutableRef<SizingInfo>;\n  selectionExtensionElementRef: MutableRef<HTMLElement | undefined>;\n  cellSupportsTabbable: (cell: Cell<K, C>) => boolean;\n  fullColumnWidths?: number[];\n  currentCellOverride?: Cell<K, C>;\n  onPersistCurrentCell?: (detail: CurrentCellDetail<K, C>) => void;\n};\n\n// constant timeout values for delays following a input gesture until enabling focus rings\nconst MOUSE_FOCUS_SHIFT_TIMEOUT = 0;\nconst TOUCH_FOCUS_SHIFT_TIMEOUT = 200;\n\n// constant event.key values that trigger focus ring and 'scroll to current' logic\nconst NAVIGATION_KEYS = [\n  ' ',\n  'F2',\n  'Enter',\n  'Esc', // Firefox 36 and earlier uses 'Esc' instead of 'Escape'\n  'Escape',\n  'ArrowLeft',\n  'ArrowUp',\n  'ArrowRight',\n  'ArrowDown',\n  'Home',\n  'End',\n  'PageUp',\n  'PageDown'\n];\n\n/**\n * Hook that manages focus interactions on the Preact Table\n */\nexport function useFocusHandling<K extends string | number, D, C extends string>({\n  outerTableRef,\n  tableId,\n  isRtl,\n  columnsArray,\n  sizingInfoRef,\n  selectionExtensionElementRef,\n  cellSupportsTabbable,\n  fullColumnWidths,\n  currentCellOverride,\n  onPersistCurrentCell\n}: UseFocusHandlingProps<K, D, C>) {\n  // tracks whether the most recent 'blur' was caused by focus being lost by the browser window (or iframe)\n  const blurFromWindowRef = useRef<boolean>(false);\n\n  // tracks focus loss during render cycle for potential focus recapture cases\n  const isRenderCycle = useRef<boolean>(true);\n  isRenderCycle.current = true;\n  const blurredRenderCycleElementRef = useRef<FocusableElement | null>(null);\n\n  // track current 'focus info' state\n  const hasFocusRef = useRef<boolean>(false);\n  const [isTabbableMode, setIsTabbableMode] = useState<boolean>(false);\n  const [isShowFocusRing, setIsShowFocusRing] = useState<boolean>(false);\n\n  // track pointer down information\n  const recentPointerRef = useRef<boolean>(false);\n  const pointerTimerRef = useRef<ReturnType<typeof setTimeout> | null>(null);\n  const isShowFocusRingOverrideRef = useRef<boolean | null>(null);\n\n  // tracks the current cell information\n  const [currentCell, setCurrentCell] = useState<Cell<K, C> | undefined>(currentCellOverride);\n  const currentCellRef = useRef<Cell<K, C> | undefined>(currentCellOverride);\n\n  // tracks whether the table is handling a tab gesture that should allow focus to leave the table\n  const [isTabbing, setIsTabbing] = useState<boolean>(false);\n\n  // intercept onPersistCurrentCell calls to ensure internal state is updated appropriately\n  const onCurrentCellChanged = useMemo(() => {\n    return (detail: CurrentCellDetail<K, C>) => {\n      setCurrentCell(detail.value);\n      currentCellRef.current = detail.value;\n      selectionExtensionElementRef.current = undefined;\n      if (onPersistCurrentCell != null) {\n        onPersistCurrentCell(detail);\n      }\n    };\n  }, [onPersistCurrentCell, selectionExtensionElementRef]);\n\n  // ensure any new currentCellOverride settings are applied only on that render\n  const currentCellOverrideRef = useRef<Cell<K, C> | undefined>(currentCellOverride);\n  if (currentCellOverrideRef.current !== currentCellOverride) {\n    currentCellOverrideRef.current = currentCellOverride;\n    if (!cellComparator(currentCell, currentCellOverride)) {\n      onCurrentCellChanged({ value: currentCellOverride });\n    }\n  }\n\n  // Helper function to set the Table's focus tracking state to reflect that it is inactive.\n  const _setAsInactive = useCallback(() => {\n    hasFocusRef.current = false;\n    setIsTabbableMode(false);\n    setIsShowFocusRing(false);\n  }, []);\n\n  // Helper function to set the Table's focus tracking state to reflect that on of its cell has focus.\n  const _enableNavigationMode = useCallback(\n    (cell: Cell<K, C>, skipScrollCellIntoView?: boolean) => {\n      const rootElement = outerTableRef.current;\n      if (rootElement != null) {\n        setIsTabbableMode(false);\n        setIsShowFocusRing(\n          isShowFocusRingOverrideRef.current !== null\n            ? isShowFocusRingOverrideRef.current\n            : !recentPointerRef.current\n        );\n        if (!recentPointerRef.current && !skipScrollCellIntoView) {\n          applyScrollDetail(\n            rootElement,\n            tableId,\n            columnsArray,\n            sizingInfoRef.current,\n            { cell: cell, locationX: 'inView', locationY: 'inView' },\n            isRtl,\n            fullColumnWidths\n          );\n        }\n        if (!cellComparator(cell, currentCell)) {\n          onCurrentCellChanged({ value: cell });\n        }\n      }\n    },\n    [\n      outerTableRef,\n      tableId,\n      columnsArray,\n      sizingInfoRef,\n      isRtl,\n      currentCell,\n      onCurrentCellChanged,\n      fullColumnWidths\n    ]\n  );\n\n  // Helper function to set the Table's focus tracking state to reflect that it is tabbable.\n  const _enableTabbableMode = useCallback(\n    (cell: Cell<K, C>, isKeyboard?: boolean, skipScrollCellIntoView?: boolean) => {\n      const rootElement = outerTableRef.current;\n      if (rootElement != null) {\n        setIsTabbableMode(true);\n        if (!isKeyboard) {\n          setIsShowFocusRing(false);\n          if (!cellComparator(cell, currentCell)) {\n            onCurrentCellChanged({ value: cell });\n          }\n          if (!recentPointerRef.current && !skipScrollCellIntoView) {\n            applyScrollDetail(\n              rootElement,\n              tableId,\n              columnsArray,\n              sizingInfoRef.current,\n              { cell: cell, locationX: 'inView', locationY: 'inView' },\n              isRtl,\n              fullColumnWidths\n            );\n          }\n        }\n      }\n    },\n    [\n      outerTableRef,\n      tableId,\n      columnsArray,\n      sizingInfoRef,\n      isRtl,\n      currentCell,\n      onCurrentCellChanged,\n      fullColumnWidths\n    ]\n  );\n\n  // Helper function to set the Table's focus tracking state to reflect that a user has\n  // exited tabbable mode via the keyboard (esc or 'F2')\n  const _disableTabbableMode = useCallback(\n    (cell: Cell<K, C>) => {\n      const rootElement = outerTableRef.current;\n      if (rootElement != null) {\n        setIsTabbableMode(false);\n        const currentCellElement = getElementFromCell(rootElement, tableId, cell);\n        if (currentCellElement != null) {\n          currentCellElement.focus({ preventScroll: true });\n        } else {\n          rootElement.focus({ preventScroll: true });\n        }\n      }\n    },\n    [outerTableRef, tableId]\n  );\n\n  // PointerDown handler for the outer Table. Focus transfers that occur following a pointerdown\n  // on desktop devices should not result in a focus ring being shown on the focused element\n  const _pointerDownHandler = useCallback(\n    (event: PointerEvent) => {\n      if (event.pointerType !== 'touch') {\n        if (pointerTimerRef.current != null) {\n          clearTimeout(pointerTimerRef.current);\n        }\n        recentPointerRef.current = true;\n        pointerTimerRef.current = setTimeout(() => {\n          recentPointerRef.current = false;\n          if (isShowFocusRing) {\n            setIsShowFocusRing(false);\n          }\n        }, MOUSE_FOCUS_SHIFT_TIMEOUT);\n      }\n    },\n    [isShowFocusRing]\n  );\n\n  // TouchEnd handler for the outer Table. Focus transfers that occur following a touchend\n  // on touch devices should not result in a focus ring being shown on the focused element\n  const _touchEndHandler = useCallback(() => {\n    if (pointerTimerRef.current != null) {\n      clearTimeout(pointerTimerRef.current);\n    }\n    recentPointerRef.current = true;\n    pointerTimerRef.current = setTimeout(() => {\n      recentPointerRef.current = false;\n      if (isShowFocusRing) {\n        setIsShowFocusRing(false);\n      }\n    }, TOUCH_FOCUS_SHIFT_TIMEOUT);\n  }, [isShowFocusRing]);\n\n  // Focus handler for the outer Table. On focus, a focusable area needs to be 'current'.\n  // If a 'current' area already exists, nothing further is needed. Otherwise, the first\n  // focusable element should be made 'current'.\n  const _onFocusHandler = useCallback(\n    (event: FocusEvent) => {\n      hasFocusRef.current = true;\n      const rootElement = outerTableRef.current;\n      if (rootElement != null) {\n        // don't scroll current into view if previous blur was due to window focus loss\n        const skipScrollCellIntoView = blurFromWindowRef.current;\n        blurFromWindowRef.current = false;\n\n        const targetElement = event.target as HTMLElement;\n        if (targetElement === rootElement) {\n          // handle overall root element receiving focus\n          const cell =\n            currentCell != null\n              ? currentCell\n              : (getFirstFocusableCell(rootElement, tableId) as Cell<K, C>);\n          if (cell != null) {\n            _enableNavigationMode(cell, skipScrollCellIntoView);\n          }\n        } else {\n          const cell = logicalCellExtractor(\n            targetElement,\n            tableId,\n            `[data-oj-table-focusable='${tableId}']`\n          ) as Cell<K, C>;\n          if (cell != null) {\n            if (getCellType(targetElement) != null) {\n              // handle individual focusable regions receiving focus\n              _enableNavigationMode(cell, skipScrollCellIntoView);\n            } else {\n              _enableTabbableMode(cell, false, skipScrollCellIntoView);\n            }\n          }\n        }\n      }\n      if (pointerTimerRef.current != null) {\n        clearTimeout(pointerTimerRef.current);\n        pointerTimerRef.current = null;\n      }\n      recentPointerRef.current = false;\n      isShowFocusRingOverrideRef.current = null;\n    },\n    [outerTableRef, tableId, currentCell, _enableTabbableMode, _enableNavigationMode]\n  );\n\n  // Blur handler for the outer Table. When a blur is caused by the browser window itself\n  // losing focus (changing tabs or leaving an iframe for example), an eventual re-focus due\n  // to the window re-gaining focus needs to be handled differently (no auto-scroll mostly).\n  const _onBlurHandler = useCallback(\n    (event: FocusEvent) => {\n      const rootElement = outerTableRef.current;\n      if (rootElement != null) {\n        if (event.target === document.activeElement) {\n          // save focus ring state so it's set once focus comes back\n          isShowFocusRingOverrideRef.current = isShowFocusRing;\n        }\n        const relatedTarget = event.relatedTarget as Element;\n        const isUnknownRelatedTarget = relatedTarget == null;\n        blurFromWindowRef.current = isUnknownRelatedTarget;\n        if (isUnknownRelatedTarget || !getElementContainsFunc(rootElement, true)(relatedTarget)) {\n          _setAsInactive();\n          if (isRenderCycle.current) {\n            // store element that loses focus during a render cycle for recapturing focus logic\n            blurredRenderCycleElementRef.current = event.target as FocusableElement;\n          }\n        }\n        setIsTabbing(false);\n      }\n    },\n    [outerTableRef, isShowFocusRing, _setAsInactive]\n  );\n\n  // KeyDown handler for the outer Table. This specific handler tracks 'focus' transfer keys\n  // Esc, F2, Enter, and Tab. It also ensures the currentCell is scrolled into view on any key\n  const _onKeyDownHandler = useCallback(\n    (event: KeyboardEvent) => {\n      const rootElement = outerTableRef.current;\n      if (rootElement != null && currentCell != null) {\n        if (cellSupportsTabbable(currentCell)) {\n          if (event.key === 'F2') {\n            if (isTabbableMode) {\n              _disableTabbableMode(currentCell);\n            } else {\n              _enableTabbableMode(currentCell, true);\n            }\n          } else if (event.key === 'Esc' || event.key === 'Escape') {\n            // Firefox 36 and earlier uses 'Esc' instead of 'Escape'\n            _disableTabbableMode(currentCell);\n          } else if (event.key === 'Enter' && !isTabbableMode) {\n            _enableTabbableMode(currentCell, true);\n          }\n        }\n        if (NAVIGATION_KEYS.indexOf(event.key) > -1 && !isTabbableMode) {\n          setIsShowFocusRing(true);\n          applyScrollDetail(\n            rootElement,\n            tableId,\n            columnsArray,\n            sizingInfoRef.current,\n            { cell: currentCell, locationX: 'inView', locationY: 'inView' },\n            isRtl,\n            fullColumnWidths\n          );\n        }\n      }\n      if (event.key === 'Tab' && !isTabbableMode) {\n        setIsTabbing(true);\n      }\n    },\n    [\n      outerTableRef,\n      tableId,\n      columnsArray,\n      sizingInfoRef,\n      isRtl,\n      isTabbableMode,\n      currentCell,\n      cellSupportsTabbable,\n      fullColumnWidths,\n      _enableTabbableMode,\n      _disableTabbableMode\n    ]\n  );\n\n  // Callback for the outer Table's FocusTracker usage.\n  const onStartFocusTracking = useCallback(\n    (detail: {\n      activeElement: FocusableElement;\n      hasFocusWithin: boolean;\n      tabbableElements: FocusableElement[];\n    }) => {\n      const rootElement = outerTableRef.current;\n      if (rootElement != null && currentCell != null) {\n        handleEnterActionableMode(\n          detail.hasFocusWithin && getCellType(detail.activeElement) == null,\n          allTabbableElements(\n            getElementFromCell(rootElement, tableId, currentCell) as FocusableElement\n          ),\n          (value?: Cell<K, D>) => {\n            setIsTabbableMode(value != undefined);\n          }\n        );\n      }\n    },\n    [outerTableRef, currentCell, tableId]\n  );\n\n  // Callback for the outer Table's FocusTracker usage.\n  const onFocusStartEdge = useCallback((detail: { tabbableElements: FocusableElement[] }) => {\n    handleWrapActionableFocus(true, detail.tabbableElements, (value?: Cell<K, D>) => {\n      setIsTabbableMode(value != undefined);\n    });\n  }, []);\n\n  // Callback for the outer Table's FocusTracker usage.\n  const onFocusEndEdge = useCallback((detail: { tabbableElements: FocusableElement[] }) => {\n    handleWrapActionableFocus(false, detail.tabbableElements, (value?: Cell<K, D>) => {\n      setIsTabbableMode(value != undefined);\n    });\n  }, []);\n\n  // Handle ensuring focus is properly set at the completion of every render cycle\n  // NO DEPENDENCY ARRAY HERE TO ENSURE THIS RUNS ON EVERY RENDER CYCLE\n  useEffect(() => {\n    const blurredRenderCycleElement = blurredRenderCycleElementRef.current;\n    blurredRenderCycleElementRef.current = null;\n    isRenderCycle.current = false;\n\n    const rootElement = outerTableRef.current;\n    if (rootElement != null) {\n      const activeElement = getActiveElement(rootElement);\n      // if we were tracking focus during the render cycle, ensure we recapture focus if needed\n      if (\n        blurredRenderCycleElement != null &&\n        !isTabbing &&\n        activeElement === getBodyElement(rootElement) &&\n        (!getElementContainsFunc(rootElement, true)(blurredRenderCycleElement) ||\n          !isTabbableElement(blurredRenderCycleElement, true))\n      ) {\n        rootElement.focus({ preventScroll: true });\n        return;\n      }\n      if (\n        hasFocusRef.current &&\n        currentCell != null &&\n        !isTabbing &&\n        cellComparator(currentCell, currentCellRef.current)\n      ) {\n        // ensure real browser focus is on the correct cell element\n        const currentCellElement = getElementFromCell(rootElement, tableId, currentCell);\n        if (currentCellElement != null) {\n          // currentCell is valid, so set focus on it if needed\n          if (\n            (!isTabbableMode && activeElement !== currentCellElement) ||\n            (isTabbableMode && !getElementContainsFunc(currentCellElement, true)(activeElement))\n          ) {\n            currentCellElement.focus({ preventScroll: true });\n          }\n        } else {\n          // currentCell is not valid, so choose a new currentCell instead\n          const newCurrentCell = getFirstFocusableCell(rootElement, tableId) as Cell<K, C>;\n          if (newCurrentCell != null) {\n            onCurrentCellChanged({ value: newCurrentCell });\n          }\n        }\n      }\n    }\n  });\n\n  return {\n    focusHandlingProps: {\n      onPointerDown: _pointerDownHandler,\n      onTouchEnd: _touchEndHandler,\n      onFocus: _onFocusHandler,\n      onBlur: _onBlurHandler,\n      onKeyDown: _onKeyDownHandler,\n      tabIndex: isTabbing ? -1 : 0\n    },\n    currentCell,\n    onCurrentCellChanged,\n    isShowFocusRing,\n    isTabbableMode,\n    onStartFocusTracking,\n    onFocusStartEdge,\n    onFocusEndEdge\n  };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { keyExtractor } from '../../utils/PRIVATE_collectionUtils';\nimport { getRowIndexForRowElement, getElementFromCell } from './TableDomUtils';\nimport { TableColumn } from '../Table';\nimport { Cell, RowActionDetail, SortCriterionDetail } from '../../UNSAFE_TableView';\n\n/**\n * Helper function to handle a row action gesture from a pointer or keyboard event\n */\nexport function handleRowActionGesture<K, D, C>(\n  root: HTMLDivElement,\n  tableId: string,\n  data: D[],\n  onRowAction: (detail: RowActionDetail<K, D>) => void,\n  targetElement: HTMLElement,\n  targetCell?: Cell<K, C>\n) {\n  let rowKey;\n  let rowElement;\n  if (targetCell?.type === 'data') {\n    rowKey = targetCell.rowKey;\n    const targetCellElement = getElementFromCell(root, tableId, targetCell);\n    if (targetCellElement != null) {\n      rowElement = targetCellElement.parentElement;\n    }\n  } else {\n    rowKey = keyExtractor(targetElement, `[data-oj-table-data-row='${tableId}']`) as K;\n    if (rowKey != null) {\n      rowElement = targetElement.closest(`[data-oj-table-data-row='${tableId}']`);\n    }\n  }\n  if (rowKey != null && rowElement != null) {\n    const rowIndex = getRowIndexForRowElement(root, tableId, rowElement as HTMLElement);\n    if (rowIndex != null) {\n      const rowContext = {\n        key: rowKey,\n        data: data[rowIndex]\n      };\n      onRowAction({ context: rowContext, target: targetElement });\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Helper function to handle a row action gesture\n */\nexport function handleSortActionGesture<K, D, C>(\n  columnsArray: TableColumn<K, D, C>[],\n  columnKey: C,\n  onSortCriterionChange: (detail: SortCriterionDetail<C>) => void,\n  sortCriterion?: { key: C; sortDirection: 'ascending' | 'descending' }[]\n) {\n  for (const column of columnsArray) {\n    if (column.key === columnKey) {\n      if (column.value.sortable === 'enabled') {\n        let sortDirection;\n        if (sortCriterion != null) {\n          for (const criterion of sortCriterion) {\n            if (criterion.key === column.key) {\n              sortDirection = criterion.sortDirection;\n              break;\n            }\n          }\n        }\n        const newDirection = sortDirection === 'ascending' ? 'descending' : 'ascending';\n        onSortCriterionChange([{ key: columnKey, sortDirection: newDirection }]);\n        return true;\n      }\n      break;\n    }\n  }\n  return false;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { MutableRef } from 'preact/hooks';\nimport { keyExtractor } from '../../utils/PRIVATE_collectionUtils';\nimport { Keys, containsKey, isSameKey, addKey, removeKey } from '../../utils/UNSAFE_keys';\nimport { SizingInfo, TableColumn } from '../Table';\nimport {\n  logicalCellExtractor,\n  getCellType,\n  getRowKeyForRowIndex,\n  getRowIndexForRowElement,\n  getElementFromCell,\n  getColumnIndexForHeaderFooterElement\n} from './TableDomUtils';\nimport { applyScrollDetail } from './TableScrollUtils';\nimport { SelectionMode } from '../../UNSAFE_Collection';\nimport { Cell, TableSelectionDetail } from '../../UNSAFE_TableView';\n\n/**\n * Helper function to handle a selection gesture (click, spacebar, etc...)\n */\nexport function handleSelectionGesture<K, D, C>(\n  root: HTMLDivElement,\n  tableId: string,\n  columnsArray: TableColumn<K, D, C>[],\n  targetElement: HTMLElement,\n  isMultiSelectGesture: boolean,\n  onSelectionChange: (detail: TableSelectionDetail<K, C>, isExtendableSelection: boolean) => void,\n  selectionMode?: { row?: SelectionMode; column?: SelectionMode },\n  selected?: { row?: Keys<K>; column?: Keys<C> }\n) {\n  const emptyKeys = { all: false, keys: new Set() };\n  let selectedRows = selected?.row != null ? selected.row : (emptyKeys as Keys<K>);\n  let selectedColumns = selected?.column != null ? selected.column : (emptyKeys as Keys<C>);\n\n  const newRowKey = keyExtractor(targetElement, `[data-oj-table-data-row='${tableId}']`) as K;\n  if (newRowKey != null) {\n    if (selectionMode?.row === 'single' || selectionMode?.row === 'multiple') {\n      if (selectedRows == null) {\n        selectedRows = { all: false, keys: new Set([newRowKey]) };\n      } else if (!containsKey(selectedRows, newRowKey)) {\n        if (isMultiSelectGesture && selectionMode.row === 'multiple') {\n          selectedRows = addKey(selectedRows, newRowKey);\n        } else {\n          selectedRows = { all: false, keys: new Set([newRowKey]) };\n        }\n      } else if (isMultiSelectGesture) {\n        selectedRows = removeKey(selectedRows, newRowKey, false);\n      } else {\n        selectedRows = { all: false, keys: new Set([newRowKey]) };\n      }\n      selectedColumns = emptyKeys as Keys<C>;\n    }\n  } else if (selectionMode?.column === 'single' || selectionMode?.column === 'multiple') {\n    const cellElement = targetElement.closest(\n      `[data-oj-table-focusable='${tableId}']`\n    ) as HTMLElement;\n    if (cellElement != null) {\n      const cellType = getCellType(cellElement);\n      if (cellType === 'header' || cellType === 'footer') {\n        const index = getColumnIndexForHeaderFooterElement(\n          root,\n          tableId,\n          cellElement,\n          cellType === 'header'\n        );\n        if (index != null) {\n          const column = columnsArray[index];\n          if (column.value.selectable !== 'disabled') {\n            if (selectedColumns == null) {\n              selectedColumns = { all: false, keys: new Set([column.key]) };\n            } else if (!containsKey(selectedColumns, column.key)) {\n              if (isMultiSelectGesture && selectionMode.column === 'multiple') {\n                selectedColumns = addKey(selectedColumns, column.key);\n              } else {\n                selectedColumns = { all: false, keys: new Set([column.key]) };\n              }\n            } else if (isMultiSelectGesture) {\n              selectedColumns = removeKey(selectedColumns, column.key, false);\n            } else {\n              selectedColumns = { all: false, keys: new Set([column.key]) };\n            }\n            selectedRows = emptyKeys as Keys<K>;\n          }\n        }\n      }\n    }\n  }\n\n  if (!isSameKey(selectedRows, selected?.row) || !isSameKey(selectedColumns, selected?.column)) {\n    onSelectionChange(\n      { value: { row: selectedRows, column: selectedColumns }, target: targetElement },\n      false\n    );\n  }\n}\n\n/**\n * Helper function to calculate and apply a new selection state corresponding to the range provided\n */\nfunction _applyRangeSelection<K, D, C>(\n  root: HTMLDivElement,\n  tableId: string,\n  columnsArray: TableColumn<K, D, C>[],\n  targetElement: HTMLElement,\n  startIndex: number,\n  endIndex: number,\n  isRowGesture: boolean,\n  onSelectionChange: (detail: TableSelectionDetail<K, C>, isExtendableSelection: boolean) => void,\n  selectionMode?: { row?: SelectionMode; column?: SelectionMode },\n  selected?: { row?: Keys<K>; column?: Keys<C> }\n) {\n  const emptyKeys = { all: false, keys: new Set() };\n  let selectedRows = selected?.row != null ? selected.row : (emptyKeys as Keys<K>);\n  let selectedColumns = selected?.column != null ? selected.column : (emptyKeys as Keys<C>);\n\n  if (isRowGesture) {\n    selectedColumns = emptyKeys as Keys<C>;\n    if (selectionMode?.row === 'multiple') {\n      selectedRows = emptyKeys as Keys<K>;\n      // selected rows should be added in the order that they are selected\n      if (startIndex <= endIndex) {\n        for (let i = startIndex; i <= endIndex; i++) {\n          const key = getRowKeyForRowIndex(root, tableId, i) as K;\n          selectedRows = addKey(selectedRows, key) as Keys<K>;\n        }\n      } else {\n        for (let i = startIndex; i >= endIndex; i--) {\n          const key = getRowKeyForRowIndex(root, tableId, i) as K;\n          selectedRows = addKey(selectedRows, key) as Keys<K>;\n        }\n      }\n    }\n  } else {\n    selectedRows = emptyKeys as Keys<K>;\n    if (selectionMode?.column === 'multiple') {\n      selectedColumns = emptyKeys as Keys<C>;\n      // selected columns should be added in the order that they are selected\n      if (startIndex <= endIndex) {\n        for (let i = startIndex; i <= endIndex; i++) {\n          const column = columnsArray[i];\n          if (column.value.selectable !== 'disabled') {\n            selectedColumns = addKey(selectedColumns, column.key);\n          }\n        }\n      } else {\n        for (let i = startIndex; i >= endIndex; i--) {\n          const column = columnsArray[i];\n          if (column.value.selectable !== 'disabled') {\n            selectedColumns = addKey(selectedColumns, column.key);\n          }\n        }\n      }\n    }\n  }\n\n  if (!isSameKey(selectedRows, selected?.row) || !isSameKey(selectedColumns, selected?.column)) {\n    onSelectionChange(\n      { value: { row: selectedRows, column: selectedColumns }, target: targetElement },\n      true\n    );\n  }\n}\n\n/**\n * Determines whether a potential range selection gesture is valid based on the given target\n */\nexport function isRangeSelectionGesture<K, C>(\n  root: HTMLDivElement,\n  tableId: string,\n  targetElement: HTMLElement,\n  currentCell: Cell<K, C>,\n  selectionMode?: { row?: SelectionMode; column?: SelectionMode }\n) {\n  const targetCell = logicalCellExtractor(\n    targetElement,\n    tableId,\n    `[data-oj-table-focusable='${tableId}']`\n  ) as Cell<K, C>;\n  if (\n    ((selectionMode?.row === 'multiple' && currentCell.type === 'data') ||\n      (selectionMode?.column === 'multiple' &&\n        (currentCell.type === 'header' || currentCell.type === 'footer'))) &&\n    targetCell?.type === currentCell.type\n  ) {\n    const currentCellElement = getElementFromCell(root, tableId, currentCell);\n    const targetCellElement = getElementFromCell(root, tableId, targetCell);\n    if (currentCellElement != null && targetCellElement != null) {\n      const isRow = targetCell?.type === 'data';\n      if (isRow) {\n        return (\n          getRowIndexForRowElement(\n            root,\n            tableId,\n            currentCellElement.parentElement as HTMLElement\n          ) != null &&\n          getRowIndexForRowElement(root, tableId, targetCellElement.parentElement as HTMLElement) !=\n            null\n        );\n      } else if (targetCell?.type === 'header' || targetCell?.type === 'footer') {\n        const isHeader = targetCell?.type === 'header';\n        return (\n          getColumnIndexForHeaderFooterElement(root, tableId, currentCellElement, isHeader) !=\n            null &&\n          getColumnIndexForHeaderFooterElement(root, tableId, targetCellElement, isHeader) != null\n        );\n      }\n    }\n  }\n  return false;\n}\n\n/**\n * Helper function to handle a range selection gesture (shift+click)\n */\nexport function handleRangeSelectionGesture<K, D, C>(\n  root: HTMLDivElement,\n  tableId: string,\n  columnsArray: TableColumn<K, D, C>[],\n  targetElement: HTMLElement,\n  currentCell: Cell<K, C>,\n  selectionExtensionElementRef: MutableRef<HTMLElement | undefined>,\n  onSelectionChange: (detail: TableSelectionDetail<K, C>, isExtendableSelection: boolean) => void,\n  selectionMode?: { row?: SelectionMode; column?: SelectionMode },\n  selected?: { row?: Keys<K>; column?: Keys<C> }\n) {\n  const targetCell = logicalCellExtractor(\n    targetElement,\n    tableId,\n    `[data-oj-table-focusable='${tableId}']`\n  ) as Cell<K, C>;\n  const currentCellElement = getElementFromCell(root, tableId, currentCell);\n  const targetCellElement = getElementFromCell(root, tableId, targetCell);\n  if (currentCellElement != null && targetCellElement != null) {\n    if (\n      ((selectionMode?.row === 'multiple' && targetCell?.type === 'data') ||\n        (selectionMode?.column === 'multiple' &&\n          (targetCell?.type === 'header' || targetCell?.type === 'footer'))) &&\n      targetCell?.type === currentCell.type\n    ) {\n      let startIndex;\n      let endIndex;\n      let endElement;\n      const isRow = targetCell?.type === 'data';\n      if (isRow) {\n        endElement = targetCellElement.parentElement as HTMLElement;\n        startIndex = getRowIndexForRowElement(\n          root,\n          tableId,\n          currentCellElement.parentElement as HTMLElement\n        );\n        endIndex = getRowIndexForRowElement(root, tableId, endElement);\n      } else if (targetCell?.type === 'header' || targetCell?.type === 'footer') {\n        const isHeader = targetCell?.type === 'header';\n        endElement = targetCellElement;\n        startIndex = getColumnIndexForHeaderFooterElement(\n          root,\n          tableId,\n          currentCellElement,\n          isHeader\n        );\n        endIndex = getColumnIndexForHeaderFooterElement(root, tableId, targetCellElement, isHeader);\n      }\n      if (startIndex != null && endIndex != null) {\n        selectionExtensionElementRef.current = endElement;\n        _applyRangeSelection(\n          root,\n          tableId,\n          columnsArray,\n          targetElement,\n          startIndex,\n          endIndex,\n          isRow,\n          onSelectionChange,\n          selectionMode,\n          selected\n        );\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\n/**\n * Helper function to handle a selection extension gesture (shift+arrow key)\n */\nexport function handleExtendSelectionGesture<K extends string | number, D, C>(\n  root: HTMLDivElement,\n  tableId: string,\n  columnsArray: TableColumn<K, D, C>[],\n  sizingInfoRef: MutableRef<SizingInfo>,\n  targetElement: HTMLElement,\n  isPrevious: boolean,\n  currentCell: Cell<K, C>,\n  selectionExtensionElementRef: MutableRef<HTMLElement | undefined>,\n  onSelectionChange: (detail: TableSelectionDetail<K, C>, isExtendableSelection: boolean) => void,\n  isRtl: boolean,\n  fullColumnWidths?: number[],\n  selectionMode?: { row?: SelectionMode; column?: SelectionMode },\n  selected?: { row?: Keys<K>; column?: Keys<C> }\n) {\n  const currentCellElement = getElementFromCell(root, tableId, currentCell);\n  if (currentCellElement != null) {\n    let startIndex;\n    let startElement;\n    const isRow = currentCell.type === 'data';\n    const isHeader = currentCell.type === 'header';\n    if (isRow) {\n      startElement = currentCellElement.parentElement as HTMLElement;\n      startIndex = getRowIndexForRowElement(root, tableId, startElement);\n    } else {\n      startElement = currentCellElement;\n      startIndex = getColumnIndexForHeaderFooterElement(root, tableId, startElement, isHeader);\n    }\n    if (startIndex != null) {\n      let endIndex;\n      let extendedElement;\n      const cursorElement = selectionExtensionElementRef.current;\n      if (cursorElement != null) {\n        extendedElement = isPrevious\n          ? (cursorElement.previousElementSibling as HTMLElement)\n          : (cursorElement.nextElementSibling as HTMLElement);\n        if (extendedElement != null) {\n          selectionExtensionElementRef.current = extendedElement;\n          endIndex = isRow\n            ? getRowIndexForRowElement(root, tableId, extendedElement)\n            : getColumnIndexForHeaderFooterElement(root, tableId, extendedElement, isHeader);\n        } else {\n          endIndex = isRow\n            ? getRowIndexForRowElement(root, tableId, cursorElement)\n            : getColumnIndexForHeaderFooterElement(root, tableId, cursorElement, isHeader);\n        }\n      } else {\n        extendedElement = isPrevious\n          ? (startElement.previousElementSibling as HTMLElement)\n          : (startElement.nextElementSibling as HTMLElement);\n        if (extendedElement != null) {\n          selectionExtensionElementRef.current = extendedElement;\n          endIndex = isRow\n            ? getRowIndexForRowElement(root, tableId, extendedElement)\n            : getColumnIndexForHeaderFooterElement(root, tableId, extendedElement, isHeader);\n        } else {\n          endIndex = startIndex;\n        }\n      }\n      if (endIndex != null) {\n        _applyRangeSelection(\n          root,\n          tableId,\n          columnsArray,\n          targetElement,\n          startIndex,\n          endIndex,\n          isRow,\n          onSelectionChange,\n          selectionMode,\n          selected\n        );\n      }\n\n      // scroll 'extensionElement' into view\n      const extensionElement =\n        selectionExtensionElementRef.current != null\n          ? selectionExtensionElementRef.current\n          : currentCellElement;\n      let extensionCell;\n      if (isRow) {\n        const rowKey = keyExtractor(extensionElement, `[data-oj-table-data-row='${tableId}']`) as K;\n        extensionCell = {\n          type: currentCell.type,\n          rowKey: rowKey,\n          columnKey: currentCell.columnKey\n        };\n      } else {\n        extensionCell = logicalCellExtractor(\n          extensionElement,\n          tableId,\n          `[data-oj-table-focusable='${tableId}']`\n        ) as Cell<K, C>;\n      }\n      applyScrollDetail(\n        root,\n        tableId,\n        columnsArray,\n        sizingInfoRef.current,\n        { cell: extensionCell, locationX: 'inView', locationY: 'inView' },\n        isRtl,\n        fullColumnWidths\n      );\n    }\n  }\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { MutableRef } from 'preact/hooks';\nimport { ColumnResizeInfo, TableColumn } from '../Table';\nimport { ColumnResizeDetail, ColumnWidths } from '../../UNSAFE_TableView';\nimport { getElementContainsFunc } from '../../utils/PRIVATE_collectionUtils';\n\n/**\n * Helper function to handle a hover over a resizable column region gesture.\n */\nexport function handleOverResizeRegionGesture<K, D, C>(\n  root: HTMLDivElement,\n  tableId: string,\n  event: PointerEvent,\n  columnsArray: TableColumn<K, D, C>[],\n  resizeInfoRef: MutableRef<ColumnResizeInfo<C>>,\n  isRtl: boolean\n) {\n  // handle hover feedback around potentially resizable columns\n  _updateResizingState(root, tableId, event, columnsArray, resizeInfoRef, isRtl);\n}\n\n/**\n * Helper function to handle a column resize start gesture (pointer down).\n */\nexport function handleColumnResizeStartGesture<K, D, C extends string>(\n  root: HTMLDivElement,\n  tableId: string,\n  event: PointerEvent,\n  columnsArray: TableColumn<K, D, C>[],\n  appliedColumnWidths: ColumnWidths<C>,\n  resizeInfoRef: MutableRef<ColumnResizeInfo<C>>,\n  isRtl: boolean,\n  fullColumnWidths?: number[],\n  onColumnResizing?: (detail: ColumnResizeDetail<C>) => void\n) {\n  if (fullColumnWidths != null) {\n    if (resizeInfoRef.current.key == null) {\n      _updateResizingState(root, tableId, event, columnsArray, resizeInfoRef, isRtl);\n    }\n    if (resizeInfoRef.current.key != null) {\n      const innerTable = root.querySelector(`[data-oj-table-inner-table='${tableId}']`);\n      if (innerTable != null) {\n        const rect = innerTable.getBoundingClientRect();\n        const pointerX = isRtl ? rect.right - event.clientX : event.clientX - rect.left;\n\n        const resizeColumnWidths = [];\n        for (let i = 0; i < fullColumnWidths.length; i++) {\n          const columnWidth = fullColumnWidths[i];\n          resizeColumnWidths.push(columnWidth as number);\n        }\n        resizeInfoRef.current = {\n          isResizing: true,\n          isResizeHover: true,\n          key: resizeInfoRef.current.key,\n          startX: pointerX,\n          delta: 0,\n          fullColumnWidths: resizeColumnWidths,\n          ignoreClick: resizeInfoRef.current.ignoreClick\n        };\n        if (onColumnResizing != null) {\n          onColumnResizing({\n            key: resizeInfoRef.current.key,\n            delta: 0,\n            allColumnWidths: appliedColumnWidths\n          });\n        }\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\n/**\n * Helper function to ensure the resizing state is updated based on the latest pointer event.\n */\nfunction _updateResizingState<K, D, C>(\n  root: HTMLDivElement,\n  tableId: string,\n  event: PointerEvent,\n  columnsArray: TableColumn<K, D, C>[],\n  resizeInfoRef: MutableRef<ColumnResizeInfo<C>>,\n  isRtl: boolean\n) {\n  const headerRowElement = root.querySelector(\n    `[data-oj-table-header-row='${tableId}']`\n  ) as HTMLElement;\n  if (headerRowElement != null) {\n    const headerElements = headerRowElement.querySelectorAll(\n      `[data-oj-table-header-cell='${tableId}']`\n    ) as NodeListOf<HTMLElement>;\n    if (getElementContainsFunc(headerRowElement)(event.target as HTMLElement)) {\n      let isResizeHover = false;\n      for (let i = 0; i < headerElements.length; i++) {\n        const headerElement = headerElements[i];\n        const cellRect = headerElement.getBoundingClientRect();\n        const endEdge = isRtl ? cellRect.left : cellRect.right;\n        if (Math.abs(endEdge - event.pageX) <= 8) {\n          if (columnsArray[i].value.edgeResizable !== 'enabled') {\n            break;\n          }\n          // resize operation on end side of header cell\n          resizeInfoRef.current.key = columnsArray[i].key;\n          headerRowElement.style.cursor = 'col-resize';\n          isResizeHover = true;\n          resizeInfoRef.current.isResizeHover = true;\n        }\n      }\n      if (!isResizeHover) {\n        headerRowElement.style.cursor = '';\n        resizeInfoRef.current.key = undefined;\n        resizeInfoRef.current.isResizeHover = false;\n      }\n    } else {\n      if (headerRowElement != null) {\n        headerRowElement.style.cursor = '';\n      }\n      resizeInfoRef.current.key = undefined;\n      resizeInfoRef.current.isResizeHover = false;\n    }\n  }\n}\n\n/**\n * Helper function to handle a pointer move gesture during a column resize.\n */\nexport function handleColumnResizingGesture<C extends string>(\n  root: HTMLDivElement,\n  tableId: string,\n  event: PointerEvent,\n  appliedColumnWidths: ColumnWidths<C>,\n  resizeInfoRef: MutableRef<ColumnResizeInfo<C>>,\n  isRtl: boolean,\n  fullColumnWidths?: number[],\n  onColumnResizing?: (detail: ColumnResizeDetail<C>) => void\n) {\n  if (resizeInfoRef.current.isResizing && fullColumnWidths != null) {\n    const innerTable = root.querySelector(`[data-oj-table-inner-table='${tableId}']`);\n    if (innerTable != null) {\n      const rect = innerTable.getBoundingClientRect();\n      const currentX = isRtl ? rect.right - event.clientX : event.clientX - rect.left;\n\n      resizeInfoRef.current.delta = currentX - resizeInfoRef.current.startX;\n      // handle resize move operation\n      if (onColumnResizing != null) {\n        onColumnResizing({\n          key: resizeInfoRef.current.key,\n          delta: resizeInfoRef.current.delta,\n          allColumnWidths: appliedColumnWidths\n        });\n      }\n    }\n  }\n}\n\n/**\n * Helper function to handle a column resize end gesture (pointer up).\n */\nexport function handleColumnResizeEndGesture<C extends string>(\n  root: HTMLDivElement,\n  tableId: string,\n  event: PointerEvent,\n  appliedColumnWidths: ColumnWidths<C>,\n  resizeInfoRef: MutableRef<ColumnResizeInfo<C>>,\n  isRtl: boolean,\n  onColumnResize?: (detail: ColumnResizeDetail<C>) => void\n) {\n  if (resizeInfoRef.current.isResizing) {\n    if (onColumnResize != null) {\n      const resizeColumnWidths = [];\n      for (const columnWidth of resizeInfoRef.current.fullColumnWidths) {\n        resizeColumnWidths.push(columnWidth);\n      }\n      const innerTable = root.querySelector(`[data-oj-table-inner-table='${tableId}']`);\n      if (innerTable != null) {\n        const rect = innerTable.getBoundingClientRect();\n        const currentX = isRtl ? rect.right - event.clientX : event.clientX - rect.left;\n\n        resizeInfoRef.current.delta = currentX - resizeInfoRef.current.startX;\n        onColumnResize({\n          key: resizeInfoRef.current.key,\n          delta: resizeInfoRef.current.delta,\n          allColumnWidths: appliedColumnWidths\n        });\n      }\n    }\n  }\n  resizeInfoRef.current = {\n    isResizing: false,\n    isResizeHover: resizeInfoRef.current.isResizeHover,\n    ignoreClick: resizeInfoRef.current.ignoreClick\n  };\n}\n\n/**\n * Helper function to handle the pointer leaving the entire Table when previously hovering\n * over a column resize region.\n */\nexport function handleLeaveResizingGesture<C>(\n  root: HTMLDivElement,\n  tableId: string,\n  resizeInfoRef: MutableRef<ColumnResizeInfo<C>>\n) {\n  if (!resizeInfoRef.current.isResizing) {\n    const headerRowElement = root.querySelector(\n      `[data-oj-table-header-row='${tableId}']`\n    ) as HTMLElement;\n    if (headerRowElement != null) {\n      headerRowElement.style.cursor = '';\n    }\n    resizeInfoRef.current.isResizeHover = false;\n  }\n}\n\n/**\n * Helper function to handle a pointer entering the Table when it was previously handling\n * a column resize gesture.\n */\nexport function handleEnterResizingGesture<C extends string>(\n  root: HTMLDivElement,\n  tableId: string,\n  event: PointerEvent,\n  appliedColumnWidths: ColumnWidths<C>,\n  resizeInfoRef: MutableRef<ColumnResizeInfo<C>>,\n  isRtl: boolean,\n  onColumnResize?: (detail: ColumnResizeDetail<C>) => void\n) {\n  // handle case where user was resizing, moved pointer out of the Table,\n  // released the button, and has now entered the table once again\n  if (resizeInfoRef.current.isResizing && event.buttons === 0) {\n    handleColumnResizeEndGesture(\n      root,\n      tableId,\n      event,\n      appliedColumnWidths,\n      resizeInfoRef,\n      isRtl,\n      onColumnResize\n    );\n  }\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { useCallback, useRef, MutableRef, Ref } from 'preact/hooks';\nimport { getClientHints } from '../../utils/PRIVATE_clientHints';\nimport { getIsSelectionPending } from '../../utils/PRIVATE_textSelectionUtils';\nimport { Keys } from '../../utils/UNSAFE_keys';\nimport { ColumnResizeInfo, TableColumn } from '../Table';\nimport { handleRowActionGesture } from '../utils/TableActionUtils';\nimport {\n  handleSelectionGesture,\n  handleRangeSelectionGesture,\n  isRangeSelectionGesture\n} from '../utils/TableSelectionUtils';\nimport {\n  handleOverResizeRegionGesture,\n  handleColumnResizeStartGesture,\n  handleColumnResizingGesture,\n  handleColumnResizeEndGesture,\n  handleLeaveResizingGesture,\n  handleEnterResizingGesture\n} from '../utils/TableSizingUtils';\nimport { SelectionMode } from '../../UNSAFE_Collection';\nimport {\n  Cell,\n  ColumnWidths,\n  RowActionDetail,\n  ColumnResizeDetail,\n  TableSelectionDetail\n} from '../../UNSAFE_TableView';\n\ntype UsePointerHandlingOptions<K, D, C extends string> = {\n  outerTableRef: Ref<HTMLDivElement>;\n  tableId: string;\n  data: D[] | null;\n  isRtl: boolean;\n  columnsArray: TableColumn<K, D, C>[];\n  appliedColumnWidths: ColumnWidths<C>;\n  resizeInfoRef: MutableRef<ColumnResizeInfo<C>>;\n  selectionExtensionElementRef: MutableRef<HTMLElement | undefined>;\n  fullColumnWidths?: number[];\n  onColumnResizing?: (detail: ColumnResizeDetail<C>) => void;\n  onColumnResize?: (detail: ColumnResizeDetail<C>) => void;\n  currentCell?: Cell<K, C>;\n  selectionMode?: { row?: SelectionMode; column?: SelectionMode };\n  selected?: { row?: Keys<K>; column?: Keys<C> };\n  onTableSelectionChange?: (\n    detail: TableSelectionDetail<K, C>,\n    isSelectionExtension: boolean\n  ) => void;\n  onRowAction?: (detail: RowActionDetail<K, D>) => void;\n};\n\n/**\n * Hook that manages pointer interactions on the Preact Table\n */\nexport function usePointerHandling<K extends string | number, D, C extends string>({\n  outerTableRef,\n  tableId,\n  data,\n  isRtl,\n  columnsArray,\n  appliedColumnWidths,\n  resizeInfoRef,\n  selectionExtensionElementRef,\n  fullColumnWidths,\n  onColumnResizing,\n  onColumnResize,\n  currentCell,\n  selectionMode,\n  selected,\n  onTableSelectionChange,\n  onRowAction\n}: UsePointerHandlingOptions<K, D, C>) {\n  // tracks whether the most recent 'pointerdown' event was due to a touch gesture\n  const selectionTouchRef = useRef<boolean>(false);\n\n  // Pointer move handler for the outer Table.\n  const _pointerMoveHandler = useCallback(\n    (event: PointerEvent) => {\n      if (outerTableRef.current != null && onColumnResizing != null) {\n        if (!resizeInfoRef.current.isResizing) {\n          handleOverResizeRegionGesture(\n            outerTableRef.current,\n            tableId,\n            event,\n            columnsArray,\n            resizeInfoRef,\n            isRtl\n          );\n        } else {\n          handleColumnResizingGesture(\n            outerTableRef.current,\n            tableId,\n            event,\n            appliedColumnWidths,\n            resizeInfoRef,\n            isRtl,\n            fullColumnWidths,\n            onColumnResizing\n          );\n        }\n      }\n    },\n    [\n      outerTableRef,\n      tableId,\n      columnsArray,\n      appliedColumnWidths,\n      resizeInfoRef,\n      isRtl,\n      fullColumnWidths,\n      onColumnResizing\n    ]\n  );\n\n  // Pointer down handler for the outer Table. It ensures the area targeted is 'current'.\n  // NOTE - This event handling is triggered prior to 'onFocus' handling and ensures the\n  // 'pending current' area is set when an initial pointer interaction focuses the Table.\n  const _pointerDownHandler = useCallback(\n    (event: PointerEvent) => {\n      if (outerTableRef.current != null) {\n        selectionTouchRef.current = event.pointerType === 'touch';\n        const targetElement = event.target as HTMLElement;\n        if (\n          onTableSelectionChange != null &&\n          currentCell != null &&\n          event.shiftKey &&\n          isRangeSelectionGesture(\n            outerTableRef.current,\n            tableId,\n            targetElement,\n            currentCell,\n            selectionMode\n          )\n        ) {\n          // prevent focus change on selection extension gesture\n          if (!getIsSelectionPending()) {\n            event.preventDefault();\n          }\n        } else if (\n          handleColumnResizeStartGesture(\n            outerTableRef.current,\n            tableId,\n            event,\n            columnsArray,\n            appliedColumnWidths,\n            resizeInfoRef,\n            isRtl,\n            fullColumnWidths,\n            onColumnResizing\n          )\n        ) {\n          // prevent focus change on column resize gesture\n          event.preventDefault();\n          resizeInfoRef.current.ignoreClick = true;\n        }\n      }\n    },\n    [\n      outerTableRef,\n      tableId,\n      columnsArray,\n      appliedColumnWidths,\n      resizeInfoRef,\n      isRtl,\n      currentCell,\n      selectionMode,\n      onTableSelectionChange,\n      fullColumnWidths,\n      onColumnResizing\n    ]\n  );\n\n  // Pointer up handler for the outer Table.\n  const _pointerUpHandler = useCallback(\n    (event: PointerEvent) => {\n      if (outerTableRef.current != null) {\n        handleColumnResizeEndGesture(\n          outerTableRef.current,\n          tableId,\n          event,\n          appliedColumnWidths,\n          resizeInfoRef,\n          isRtl,\n          onColumnResize\n        );\n      }\n    },\n    [outerTableRef, tableId, appliedColumnWidths, resizeInfoRef, isRtl, onColumnResize]\n  );\n\n  // Pointer leave handler for the outer Table.\n  const _pointerLeaveHandler = useCallback(\n    (_event: PointerEvent) => {\n      if (outerTableRef.current != null) {\n        handleLeaveResizingGesture(outerTableRef.current, tableId, resizeInfoRef);\n      }\n    },\n    [outerTableRef, tableId, resizeInfoRef]\n  );\n\n  // Pointer leave handler for the outer Table.\n  const _pointerEnterHandler = useCallback(\n    (event: PointerEvent) => {\n      if (outerTableRef.current != null) {\n        handleEnterResizingGesture(\n          outerTableRef.current,\n          tableId,\n          event,\n          appliedColumnWidths,\n          resizeInfoRef,\n          isRtl,\n          onColumnResize\n        );\n      }\n    },\n    [outerTableRef, tableId, appliedColumnWidths, resizeInfoRef, isRtl, onColumnResize]\n  );\n\n  // Click handler for the outer Table. It ensures the Table's selection state is\n  // updated to reflect the area targeted.\n  const _clickHandler = useCallback(\n    (event: MouseEvent) => {\n      let isSelectionExtension = false;\n      const platform = getClientHints().platform;\n      const target = event.target as HTMLElement;\n      if (outerTableRef.current != null) {\n        if (\n          onTableSelectionChange != null &&\n          !resizeInfoRef.current.ignoreClick &&\n          !getIsSelectionPending()\n        ) {\n          if (currentCell != null && event.shiftKey) {\n            isSelectionExtension = handleRangeSelectionGesture(\n              outerTableRef.current,\n              tableId,\n              columnsArray,\n              target,\n              currentCell,\n              selectionExtensionElementRef,\n              onTableSelectionChange,\n              selectionMode,\n              selected\n            );\n          }\n          if (!isSelectionExtension) {\n            handleSelectionGesture(\n              outerTableRef.current,\n              tableId,\n              columnsArray,\n              target,\n              (platform === 'mac' ? event.metaKey : event.ctrlKey) || selectionTouchRef.current,\n              onTableSelectionChange,\n              selectionMode,\n              selected\n            );\n          }\n        }\n        if (\n          onRowAction != null &&\n          data != null &&\n          !getIsSelectionPending() &&\n          handleRowActionGesture(outerTableRef.current, tableId, data, onRowAction, target)\n        ) {\n          event.stopPropagation();\n        }\n      }\n      resizeInfoRef.current.ignoreClick = false;\n    },\n    [\n      outerTableRef,\n      tableId,\n      columnsArray,\n      data,\n      resizeInfoRef,\n      selectionExtensionElementRef,\n      currentCell,\n      selectionMode,\n      selected,\n      onTableSelectionChange,\n      onRowAction\n    ]\n  );\n\n  return {\n    onPointerMove: _pointerMoveHandler,\n    onPointerDown: _pointerDownHandler,\n    onPointerUp: _pointerUpHandler,\n    onPointerLeave: _pointerLeaveHandler,\n    onPointerEnter: _pointerEnterHandler,\n    onClick: _clickHandler\n  };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { useMemo, useRef, MutableRef, Ref } from 'preact/hooks';\nimport { Keys } from '../../utils/UNSAFE_keys';\nimport { mergeProps } from '../../utils/UNSAFE_mergeProps';\nimport { ColumnResizeInfo, SizingInfo, TableColumn } from '../Table';\nimport { useFocusHandling } from './useFocusHandling';\nimport { useKeyboardHandling } from './useKeyboardHandling';\nimport { usePointerHandling } from './usePointerHandling';\nimport { useScrollHandling } from './useScrollHandling';\nimport { SelectionMode } from '../../UNSAFE_Collection';\nimport {\n  Cell,\n  ColumnWidths,\n  CurrentCellDetail,\n  RowActionDetail,\n  SortCriterionDetail,\n  ColumnResizeDetail,\n  TableSelectionDetail\n} from '../../UNSAFE_TableView';\n\ntype UseInteractionManagerOptions<K, D, C extends string> = {\n  outerTableRef: Ref<HTMLDivElement>;\n  tableId: string;\n  data: D[] | null;\n  isRtl: boolean;\n  columnsArray: TableColumn<K, D, C>[];\n  appliedColumnWidths: ColumnWidths<C>;\n  sizingInfoRef: MutableRef<SizingInfo>;\n  resizeInfoRef: MutableRef<ColumnResizeInfo<C>>;\n  stickyEdgesState: { start?: number; end?: number };\n  setStickyEdgesState: (stickyEdgesState: { start?: number; end?: number }) => void;\n  cellHasRenderer: (cell: Cell<K, C>) => boolean;\n  fullColumnWidths?: number[];\n  onColumnResizing?: (detail: ColumnResizeDetail<C>) => void;\n  onColumnResize?: (detail: ColumnResizeDetail<C>) => void;\n  currentCellOverride?: Cell<K, C>;\n  onPersistCurrentCell?: (detail: CurrentCellDetail<K, C>) => void;\n  selectionMode?: { row?: SelectionMode; column?: SelectionMode };\n  selected?: { row?: Keys<K>; column?: Keys<C> };\n  onSelectionChange?: (detail: TableSelectionDetail<K, C>) => void;\n  onRowAction?: (detail: RowActionDetail<K, D>) => void;\n  sortCriterion?: { key: C; sortDirection: 'ascending' | 'descending' }[];\n  onSortCriterionChange?: (detail: SortCriterionDetail<C>) => void;\n};\n\n/**\n * Hook that manages interactions and events on the Preact Table\n */\nexport function useInteractionManager<K extends string | number, D, C extends string>({\n  outerTableRef,\n  tableId,\n  data,\n  isRtl,\n  columnsArray,\n  appliedColumnWidths,\n  sizingInfoRef,\n  resizeInfoRef,\n  stickyEdgesState,\n  setStickyEdgesState,\n  cellHasRenderer,\n  fullColumnWidths,\n  onColumnResizing,\n  onColumnResize,\n  currentCellOverride,\n  onPersistCurrentCell,\n  selectionMode,\n  selected,\n  onSelectionChange,\n  onRowAction,\n  sortCriterion,\n  onSortCriterionChange\n}: UseInteractionManagerOptions<K, D, C>) {\n  // tracks the current selection extension element (if any)\n  const selectionExtensionElementRef = useRef<HTMLElement>();\n\n  // intercept onSelectionChange calls to ensure local selectionExtensionElementRef is cleared\n  const onTableSelectionChange = useMemo(() => {\n    return onSelectionChange != null\n      ? (detail: TableSelectionDetail<K, C>, isExtendableSelection: boolean) => {\n          if (!isExtendableSelection) {\n            selectionExtensionElementRef.current = undefined;\n          }\n          onSelectionChange(detail);\n        }\n      : undefined;\n  }, [onSelectionChange]);\n\n  // setup focus tracking using the useFocusHandling hook\n  const {\n    focusHandlingProps,\n    currentCell,\n    onCurrentCellChanged,\n    isShowFocusRing,\n    isTabbableMode,\n    onStartFocusTracking,\n    onFocusStartEdge,\n    onFocusEndEdge\n  } = useFocusHandling({\n    outerTableRef,\n    tableId,\n    columnsArray,\n    sizingInfoRef,\n    selectionExtensionElementRef,\n    isRtl,\n    cellSupportsTabbable: cellHasRenderer,\n    fullColumnWidths,\n    currentCellOverride,\n    onPersistCurrentCell\n  });\n\n  const keyboardHandlingProps = useKeyboardHandling({\n    outerTableRef,\n    tableId,\n    data,\n    isRtl,\n    isTabbableMode,\n    columnsArray,\n    sizingInfoRef,\n    selectionExtensionElementRef,\n    fullColumnWidths,\n    currentCell,\n    onCurrentCellChanged,\n    selectionMode,\n    selected,\n    onTableSelectionChange,\n    onRowAction,\n    sortCriterion,\n    onSortCriterionChange\n  });\n\n  const pointerHandlingProps = usePointerHandling({\n    outerTableRef,\n    tableId,\n    data,\n    isRtl,\n    columnsArray,\n    appliedColumnWidths,\n    resizeInfoRef,\n    selectionExtensionElementRef,\n    fullColumnWidths,\n    onColumnResizing,\n    onColumnResize,\n    currentCell,\n    selectionMode,\n    selected,\n    onTableSelectionChange,\n    onRowAction\n  });\n\n  const scrollHandlingProps = useScrollHandling({\n    outerTableRef,\n    columnsArray,\n    stickyEdgesState,\n    setStickyEdgesState,\n    fullColumnWidths\n  });\n\n  const interactionManagerProps = mergeProps(\n    focusHandlingProps,\n    keyboardHandlingProps,\n    pointerHandlingProps,\n    scrollHandlingProps\n  );\n\n  return {\n    interactionManagerProps,\n    onTableSelectionChange,\n    isShowFocusRing,\n    isTabbableMode,\n    currentCell,\n    onStartFocusTracking,\n    onFocusStartEdge,\n    onFocusEndEdge\n  };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { useCallback, MutableRef, Ref } from 'preact/hooks';\nimport { getClientHints } from '../../utils/PRIVATE_clientHints';\nimport { Keys } from '../../utils/UNSAFE_keys';\nimport { SizingInfo, TableColumn } from '../Table';\nimport { handleRowActionGesture, handleSortActionGesture } from '../utils/TableActionUtils';\nimport { getElementFromCell } from '../utils/TableDomUtils';\nimport {\n  handleAdjacentRowGesture,\n  handleAdjacentColumnGesture,\n  handlePageRowGesture,\n  handleJumpColumnGesture\n} from '../utils/TableNavigationUtils';\nimport { handleSelectionGesture, handleExtendSelectionGesture } from '../utils/TableSelectionUtils';\nimport { SelectionMode } from '../../UNSAFE_Collection';\nimport {\n  Cell,\n  CurrentCellDetail,\n  RowActionDetail,\n  SortCriterionDetail,\n  TableSelectionDetail\n} from '../../UNSAFE_TableView';\n\ntype UseKeyboardHandlingProps<K, D, C extends string> = {\n  outerTableRef: Ref<HTMLDivElement>;\n  tableId: string;\n  data: D[] | null;\n  isRtl: boolean;\n  isTabbableMode: boolean;\n  columnsArray: TableColumn<K, D, C>[];\n  sizingInfoRef: MutableRef<SizingInfo>;\n  selectionExtensionElementRef: MutableRef<HTMLElement | undefined>;\n  onCurrentCellChanged: (detail: CurrentCellDetail<K, C>) => void;\n  fullColumnWidths?: number[];\n  currentCell?: Cell<K, C>;\n  selectionMode?: { row?: SelectionMode; column?: SelectionMode };\n  selected?: { row?: Keys<K>; column?: Keys<C> };\n  onTableSelectionChange?: (\n    detail: TableSelectionDetail<K, C>,\n    isExtendableSelection: boolean\n  ) => void;\n  onRowAction?: (detail: RowActionDetail<K, D>) => void;\n  sortCriterion?: { key: C; sortDirection: 'ascending' | 'descending' }[];\n  onSortCriterionChange?: (detail: SortCriterionDetail<C>) => void;\n};\n\n/**\n * Hook that manages keyboard interactions on the Preact Table\n */\nexport function useKeyboardHandling<K extends string | number, D, C extends string>({\n  outerTableRef,\n  tableId,\n  data,\n  isRtl,\n  isTabbableMode,\n  columnsArray,\n  sizingInfoRef,\n  selectionExtensionElementRef,\n  fullColumnWidths,\n  currentCell,\n  onCurrentCellChanged,\n  selectionMode,\n  selected,\n  onTableSelectionChange,\n  onRowAction,\n  sortCriterion,\n  onSortCriterionChange\n}: UseKeyboardHandlingProps<K, D, C>) {\n  // Keydown handler for the outer Table. This handles all internal\n  // keyboard navigation for the Table.\n  const _keyDownHandler = useCallback(\n    (event: KeyboardEvent) => {\n      const platform = getClientHints().platform;\n      const keyHandlers: Record<string, (root: HTMLDivElement) => void> = {\n        ' ': function (root: HTMLDivElement) {\n          if (outerTableRef.current != null) {\n            if (currentCell != null) {\n              if (!isTabbableMode) {\n                if (onTableSelectionChange != null) {\n                  handleSelectionGesture(\n                    outerTableRef.current,\n                    tableId,\n                    columnsArray,\n                    getElementFromCell(root, tableId, currentCell) as HTMLElement,\n                    true,\n                    onTableSelectionChange,\n                    selectionMode,\n                    selected\n                  );\n                }\n                event.preventDefault();\n              }\n              if (\n                onRowAction != null &&\n                data != null &&\n                handleRowActionGesture(\n                  outerTableRef.current,\n                  tableId,\n                  data,\n                  onRowAction,\n                  event.target as HTMLElement,\n                  currentCell\n                )\n              ) {\n                event.stopPropagation();\n              }\n            }\n          }\n        },\n        Enter: function () {\n          if (outerTableRef.current != null) {\n            if (currentCell != null) {\n              if (\n                onRowAction != null &&\n                data != null &&\n                currentCell.type === 'data' &&\n                handleRowActionGesture(\n                  outerTableRef.current,\n                  tableId,\n                  data,\n                  onRowAction,\n                  event.target as HTMLElement,\n                  currentCell\n                )\n              ) {\n                event.stopPropagation();\n              } else if (\n                !isTabbableMode &&\n                onSortCriterionChange != null &&\n                currentCell.type === 'header' &&\n                handleSortActionGesture(\n                  columnsArray,\n                  currentCell.columnKey,\n                  onSortCriterionChange,\n                  sortCriterion\n                )\n              ) {\n                event.stopPropagation();\n              }\n            }\n          }\n        },\n        ArrowUp: function (root: HTMLDivElement) {\n          if (outerTableRef.current != null) {\n            if (!isTabbableMode && currentCell != null) {\n              if (\n                currentCell.type === 'data' &&\n                event.shiftKey &&\n                onTableSelectionChange != null &&\n                selectionMode?.row === 'multiple'\n              ) {\n                handleExtendSelectionGesture(\n                  outerTableRef.current,\n                  tableId,\n                  columnsArray,\n                  sizingInfoRef,\n                  root,\n                  true,\n                  currentCell,\n                  selectionExtensionElementRef,\n                  onTableSelectionChange,\n                  isRtl,\n                  fullColumnWidths,\n                  selectionMode,\n                  selected\n                );\n              } else {\n                handleAdjacentRowGesture(\n                  root,\n                  tableId,\n                  columnsArray,\n                  currentCell,\n                  onCurrentCellChanged,\n                  true\n                );\n              }\n              event.preventDefault();\n            }\n          }\n        },\n        ArrowDown: function (root: HTMLDivElement) {\n          if (outerTableRef.current != null) {\n            if (!isTabbableMode && currentCell != null) {\n              if (\n                currentCell.type === 'data' &&\n                event.shiftKey &&\n                onTableSelectionChange != null &&\n                selectionMode?.row === 'multiple'\n              ) {\n                handleExtendSelectionGesture(\n                  outerTableRef.current,\n                  tableId,\n                  columnsArray,\n                  sizingInfoRef,\n                  root,\n                  false,\n                  currentCell,\n                  selectionExtensionElementRef,\n                  onTableSelectionChange,\n                  isRtl,\n                  fullColumnWidths,\n                  selectionMode,\n                  selected\n                );\n              } else {\n                handleAdjacentRowGesture(\n                  root,\n                  tableId,\n                  columnsArray,\n                  currentCell,\n                  onCurrentCellChanged,\n                  false\n                );\n              }\n              event.preventDefault();\n            }\n          }\n        },\n        ArrowLeft: function (root: HTMLDivElement) {\n          if (outerTableRef.current != null) {\n            if (!isTabbableMode && currentCell != null) {\n              if (\n                (currentCell.type === 'header' || currentCell.type === 'footer') &&\n                event.shiftKey &&\n                onTableSelectionChange != null &&\n                selectionMode?.column === 'multiple'\n              ) {\n                handleExtendSelectionGesture(\n                  outerTableRef.current,\n                  tableId,\n                  columnsArray,\n                  sizingInfoRef,\n                  root,\n                  true,\n                  currentCell,\n                  selectionExtensionElementRef,\n                  onTableSelectionChange,\n                  isRtl,\n                  fullColumnWidths,\n                  selectionMode,\n                  selected\n                );\n              } else {\n                handleAdjacentColumnGesture(\n                  columnsArray,\n                  currentCell,\n                  onCurrentCellChanged,\n                  !isRtl\n                );\n              }\n              event.preventDefault();\n            }\n          }\n        },\n        ArrowRight: function (root: HTMLDivElement) {\n          if (outerTableRef.current != null) {\n            if (!isTabbableMode && currentCell != null) {\n              if (\n                (currentCell.type === 'header' || currentCell.type === 'footer') &&\n                event.shiftKey &&\n                onTableSelectionChange != null &&\n                selectionMode?.column === 'multiple'\n              ) {\n                handleExtendSelectionGesture(\n                  outerTableRef.current,\n                  tableId,\n                  columnsArray,\n                  sizingInfoRef,\n                  root,\n                  false,\n                  currentCell,\n                  selectionExtensionElementRef,\n                  onTableSelectionChange,\n                  isRtl,\n                  fullColumnWidths,\n                  selectionMode,\n                  selected\n                );\n              } else {\n                handleAdjacentColumnGesture(columnsArray, currentCell, onCurrentCellChanged, isRtl);\n              }\n              event.preventDefault();\n            }\n          }\n        },\n        PageUp: function (root: HTMLDivElement) {\n          if (!isTabbableMode && currentCell != null) {\n            handlePageRowGesture(\n              root,\n              tableId,\n              columnsArray,\n              sizingInfoRef,\n              currentCell,\n              onCurrentCellChanged,\n              true,\n              isRtl,\n              fullColumnWidths\n            );\n            event.preventDefault();\n          }\n        },\n        PageDown: function (root: HTMLDivElement) {\n          if (!isTabbableMode && currentCell != null) {\n            handlePageRowGesture(\n              root,\n              tableId,\n              columnsArray,\n              sizingInfoRef,\n              currentCell,\n              onCurrentCellChanged,\n              false,\n              isRtl,\n              fullColumnWidths\n            );\n            event.preventDefault();\n          }\n        },\n        Home: function (root: HTMLDivElement) {\n          if (!isTabbableMode && currentCell != null) {\n            handleJumpColumnGesture(\n              root,\n              tableId,\n              columnsArray,\n              currentCell,\n              onCurrentCellChanged,\n              true,\n              platform === 'mac' ? event.metaKey : event.ctrlKey\n            );\n            event.preventDefault();\n          }\n        },\n        End: function (root: HTMLDivElement) {\n          if (!isTabbableMode && currentCell != null) {\n            handleJumpColumnGesture(\n              root,\n              tableId,\n              columnsArray,\n              currentCell,\n              onCurrentCellChanged,\n              false,\n              platform === 'mac' ? event.metaKey : event.ctrlKey\n            );\n            event.preventDefault();\n          }\n        }\n      };\n      if (Object.keys(keyHandlers).includes(event.key) && outerTableRef.current != null) {\n        keyHandlers[event.key](outerTableRef.current);\n      }\n    },\n    [\n      outerTableRef,\n      tableId,\n      data,\n      isRtl,\n      isTabbableMode,\n      columnsArray,\n      sizingInfoRef,\n      selectionExtensionElementRef,\n      fullColumnWidths,\n      currentCell,\n      onCurrentCellChanged,\n      selectionMode,\n      selected,\n      onTableSelectionChange,\n      onRowAction,\n      sortCriterion,\n      onSortCriterionChange\n    ]\n  );\n\n  return { onKeyDown: _keyDownHandler };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { useCallback, Ref } from 'preact/hooks';\nimport { TableColumn } from '../Table';\nimport { updateStickyEdges } from '../utils/TableScrollUtils';\n\ntype UseScrollHandlingProps<K, D, C extends string> = {\n  outerTableRef: Ref<HTMLDivElement>;\n  columnsArray: TableColumn<K, D, C>[];\n  stickyEdgesState: { start?: number; end?: number };\n  setStickyEdgesState: (stickyEdgesState: { start?: number; end?: number }) => void;\n  fullColumnWidths?: number[];\n};\n\n/**\n * Hook that manages handling scroll events on the Preact Table\n */\nexport function useScrollHandling<K extends string | number, D, C extends string>({\n  outerTableRef,\n  columnsArray,\n  stickyEdgesState,\n  setStickyEdgesState,\n  fullColumnWidths\n}: UseScrollHandlingProps<K, D, C>) {\n  // Scroll hander for the outer Table. It ensures the Table's sticky edges are updated.\n  const _scrollHandler = useCallback(() => {\n    if (outerTableRef.current != null && fullColumnWidths != null) {\n      updateStickyEdges(\n        outerTableRef.current,\n        columnsArray,\n        fullColumnWidths,\n        stickyEdgesState,\n        setStickyEdgesState,\n        outerTableRef.current.scrollLeft\n      );\n    }\n  }, [outerTableRef, columnsArray, stickyEdgesState, setStickyEdgesState, fullColumnWidths]);\n\n  return { onScroll: _scrollHandler };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { MutableRef } from 'preact/hooks';\nimport { SampledWidths, TableColumn } from '../Table';\nimport { tableStyles } from '../themes/TableStyles.css';\nimport { ColumnWidths } from '../../UNSAFE_TableView';\n\n/**\n * Helper method to extract the individual column widths of the Table\n * depending on its layout. With a 'fixed' layout, an initial 'availableWidth'\n * is required, while with a 'contents' layout, -1 can be provided as the\n * 'availableWidth' initially. This will trigger the layout logic to ensure\n * a non-contstrained Table width is supported, and is needed to match\n * current Redwood behaviors with a 'contents' layout.\n */\nexport function getLayoutColumnWidths<K, D, C extends string>(\n  outerTableElement: HTMLDivElement,\n  scrollbarWidth: number,\n  tableId: string,\n  isFixed: boolean,\n  sampledColumnWidthsRef: MutableRef<SampledWidths<C> | undefined>,\n  availableWidth: number,\n  columnsArray: TableColumn<K, D, C>[],\n  staticColumnWidths?: ColumnWidths<C>\n) {\n  if (isFixed) {\n    return _getFixedLayoutColumnWidths(availableWidth, columnsArray, staticColumnWidths);\n  }\n  let newColumnWidths = _getContentsLayoutColumnWidths(\n    outerTableElement,\n    tableId,\n    sampledColumnWidthsRef,\n    availableWidth,\n    columnsArray,\n    staticColumnWidths\n  );\n  if (availableWidth === -1) {\n    let totalWidth = 0;\n    const widthsArray = [];\n    for (let i = 0; i < columnsArray.length; i++) {\n      const width = newColumnWidths[columnsArray[i].key];\n      widthsArray.push(width);\n      totalWidth += width;\n    }\n    // for content sizing, apply the new column widths immediately, and check to see\n    // if all space is actually utilized - this supports no width constraint scenarios\n    _udpateTableSizing(outerTableElement, tableId, widthsArray, totalWidth);\n    availableWidth = outerTableElement.getBoundingClientRect().width - scrollbarWidth;\n    if (Math.abs(totalWidth - availableWidth) > 0.005) {\n      newColumnWidths = _getContentsLayoutColumnWidths(\n        outerTableElement,\n        tableId,\n        sampledColumnWidthsRef,\n        availableWidth,\n        columnsArray,\n        staticColumnWidths\n      );\n    }\n  }\n  return newColumnWidths;\n}\n\n/**\n * Helper method to extract the individual column widths of the Table\n * for a 'fixed' layout table that already has its root width applied.\n */\nfunction _getFixedLayoutColumnWidths<K, D, C extends string>(\n  availableWidth: number,\n  columnsArray: TableColumn<K, D, C>[],\n  staticColumnWidths?: ColumnWidths<C>\n) {\n  const DEFAULT_COLUMN_WEIGHT = 1;\n  const DEFAULT_COLUMN_MIN_WIDTH = 100;\n  const DEFAULT_COLUMN_MAX_WIDTH = undefined;\n\n  let requiresActiveSizing = false;\n  let totalWorkingWeight = 0;\n  let forcedTotalWidth = 0;\n  let pendingTotalWidth = 0;\n  const columnMaxWidthsArray = [];\n  const columnWeightsArray = [];\n  const forcedColumnWidthsArray = [];\n  const newColumnWidthsArray = [];\n  const appliedColumnWidthsArray = [];\n  for (let i = 0; i < columnsArray.length; i++) {\n    const column = columnsArray[i];\n    let columnMinWidth = column.value.minWidth;\n    if (columnMinWidth == null || columnMinWidth <= 0) {\n      columnMinWidth = DEFAULT_COLUMN_MIN_WIDTH;\n    }\n    let columnMaxWidth = column.value.maxWidth;\n    if (columnMaxWidth == null || columnMaxWidth < columnMinWidth) {\n      columnMaxWidth = DEFAULT_COLUMN_MAX_WIDTH;\n    }\n    columnMaxWidthsArray.push(columnMaxWidth);\n    let columnWeight = column.value.weight;\n    if (columnWeight == null || columnWeight < 1) {\n      columnWeight = DEFAULT_COLUMN_WEIGHT;\n    }\n    columnWeightsArray.push(columnWeight);\n    const columnWidth = staticColumnWidths != null ? staticColumnWidths[column.key] : undefined;\n    if (columnWidth != null) {\n      forcedTotalWidth += columnWidth;\n      pendingTotalWidth += columnWidth;\n      forcedColumnWidthsArray.push(columnWidth);\n      newColumnWidthsArray.push(columnWidth);\n      appliedColumnWidthsArray.push(columnWidth);\n    } else {\n      requiresActiveSizing = true;\n      pendingTotalWidth += columnMinWidth;\n      totalWorkingWeight += columnWeight;\n      forcedColumnWidthsArray.push(undefined);\n      newColumnWidthsArray.push(columnMinWidth);\n      appliedColumnWidthsArray.push(columnMinWidth);\n    }\n  }\n\n  // enforce min and max rules if active sizing is required and available space remains\n  if (requiresActiveSizing && pendingTotalWidth < availableWidth) {\n    _enforceFixedMinMaxRules(\n      columnsArray,\n      availableWidth,\n      totalWorkingWeight,\n      forcedTotalWidth,\n      forcedColumnWidthsArray,\n      columnWeightsArray,\n      columnMaxWidthsArray,\n      newColumnWidthsArray,\n      appliedColumnWidthsArray\n    );\n  }\n  return _createColumnWidths(columnsArray, newColumnWidthsArray);\n}\n\n/**\n * Helper function to enforce all of the layout sizing rules on the Table's columns.\n */\nfunction _enforceFixedMinMaxRules<K, D, C>(\n  columnsArray: TableColumn<K, D, C>[],\n  availableWidth: number,\n  totalWorkingWeight: number,\n  forcedTotalWidth: number,\n  forcedColumnWidthsArray: (number | undefined)[],\n  columnWeightsArray: number[],\n  columnMaxWidthsArray: (number | undefined)[],\n  newColumnWidthsArray: number[],\n  appliedColumnWidthsArray: number[]\n) {\n  // try and honor the weights of each column combined with the min widths, and then check that against\n  // any max widths once completed. if the final result doesn't fill the space AND at least 1 max width\n  // rule was enforced, repeat the process until no max rules are enforced OR the space is filled.\n  let isMaxRuleApplied = true;\n  while (isMaxRuleApplied) {\n    isMaxRuleApplied = false;\n    _enforceWeightedMinRules(\n      columnsArray,\n      availableWidth,\n      totalWorkingWeight,\n      forcedTotalWidth,\n      forcedColumnWidthsArray,\n      columnWeightsArray,\n      newColumnWidthsArray,\n      appliedColumnWidthsArray\n    );\n    let pendingTotalWidth = 0;\n    for (let i = 0; i < columnsArray.length; i++) {\n      if (forcedColumnWidthsArray[i] == null) {\n        const maxWidth = columnMaxWidthsArray[i];\n        if (maxWidth != null && newColumnWidthsArray[i] > maxWidth) {\n          isMaxRuleApplied = true;\n          forcedColumnWidthsArray[i] = maxWidth;\n          forcedTotalWidth += maxWidth;\n          totalWorkingWeight -= columnWeightsArray[i];\n          newColumnWidthsArray[i] = maxWidth;\n          appliedColumnWidthsArray[i] = maxWidth;\n        }\n      }\n      pendingTotalWidth += newColumnWidthsArray[i];\n    }\n    isMaxRuleApplied = isMaxRuleApplied && pendingTotalWidth < availableWidth;\n  }\n}\n\n/**\n * Helper method to extract the individual column widths of the Table\n * for a 'contents' layout table that already has its root width applied.\n */\nfunction _getContentsLayoutColumnWidths<K, D, C extends string>(\n  outerTableElement: HTMLDivElement,\n  tableId: string,\n  sampledColumnWidthsRef: MutableRef<SampledWidths<C> | undefined>,\n  availableWidth: number,\n  columnsArray: TableColumn<K, D, C>[],\n  staticColumnWidths?: ColumnWidths<C>\n) {\n  const DEFAULT_COLUMN_MIN_WIDTH = undefined;\n  const DEFAULT_COLUMN_MAX_WIDTH = undefined;\n\n  let requiresActiveSizing = false;\n  const columnMinWidthsArray = [] as (number | undefined)[];\n  const columnMaxWidthsArray = [];\n  const forcedColumnWidthsArray = [];\n  const newColumnWidthsArray = [];\n  for (let i = 0; i < columnsArray.length; i++) {\n    const column = columnsArray[i];\n    let columnMinWidth = column.value.minWidth;\n    if (columnMinWidth == null || columnMinWidth <= 0) {\n      columnMinWidth = DEFAULT_COLUMN_MIN_WIDTH;\n    }\n    columnMinWidthsArray.push(columnMinWidth);\n    let columnMaxWidth = column.value.maxWidth;\n    if (columnMaxWidth == null || columnMaxWidth < (columnMinWidth != null ? columnMinWidth : 0)) {\n      columnMaxWidth = DEFAULT_COLUMN_MAX_WIDTH;\n    }\n    columnMaxWidthsArray.push(columnMaxWidth);\n    const columnWidth = staticColumnWidths != null ? staticColumnWidths[column.key] : undefined;\n    if (columnWidth != null) {\n      forcedColumnWidthsArray.push(columnWidth);\n      newColumnWidthsArray[i] = columnWidth;\n    } else {\n      requiresActiveSizing = true;\n      forcedColumnWidthsArray.push(undefined);\n    }\n  }\n\n  // short-circuit normal contents sizing if each column specifies a 'width' value\n  if (requiresActiveSizing) {\n    // if active sizing is required, update min width values to reflect actual widths\n    // performance note - this should be the only logic that requires DOM measurements\n    let forcedTotalWidth = 0;\n    let pendingTotalWidth = 0;\n    let totalPreferredWidth = 0;\n    let totalWorkingWeight = 0;\n    let totalRemainingWeight = 0;\n    const sampledWidths = sampledColumnWidthsRef.current;\n    const sampledMinWidthsArray = [];\n    const sampledWeightWidthsArray = [] as number[];\n    const appliedColumnWidthsArray = [];\n    if (sampledWidths != null) {\n      for (let i = 0; i < columnsArray.length; i++) {\n        sampledMinWidthsArray.push(sampledWidths.minWidths[columnsArray[i].key]);\n        sampledWeightWidthsArray.push(sampledWidths.weightWidths[columnsArray[i].key]);\n      }\n    } else {\n      sampledColumnWidthsRef.current = {\n        minWidths: {} as ColumnWidths<C>,\n        weightWidths: {} as ColumnWidths<C>\n      };\n      const headerElements = outerTableElement.querySelectorAll(\n        `[data-oj-table-header-cell='${tableId}']`\n      );\n      // when sampledColumnWidths are not populated, content wrapping is disabled in the table\n      // which allows for measurements to represent the column weights\n      for (let i = 0; i < headerElements.length; i++) {\n        const sampledWeightWidth = (headerElements[i] as HTMLElement).getBoundingClientRect().width;\n        sampledWeightWidthsArray.push(sampledWeightWidth);\n        sampledColumnWidthsRef.current.weightWidths[columnsArray[i].key] = sampledWeightWidth;\n      }\n      // re-enable wrapping, allowing measurements to represent minimum auto-resizable column widths\n      outerTableElement.classList.remove(tableStyles.disableWrapping);\n      for (let i = 0; i < headerElements.length; i++) {\n        const sampledMinWidth = (headerElements[i] as HTMLElement).getBoundingClientRect().width;\n        sampledMinWidthsArray.push(sampledMinWidth);\n        sampledColumnWidthsRef.current.minWidths[columnsArray[i].key] = sampledMinWidth;\n      }\n    }\n\n    for (let i = 0; i < sampledMinWidthsArray.length; i++) {\n      const forcedWidth = forcedColumnWidthsArray[i];\n      if (forcedWidth == null) {\n        let columnWidth;\n        const sampledMinWidth = sampledMinWidthsArray[i];\n        const minWidth = columnMinWidthsArray[i];\n        const maxWidth = columnMaxWidthsArray[i];\n        if (minWidth != null && minWidth >= sampledMinWidth) {\n          columnWidth = minWidth;\n        } else if (maxWidth != null && sampledMinWidth >= maxWidth) {\n          columnWidth = maxWidth;\n        } else {\n          columnWidth = sampledMinWidth;\n        }\n        pendingTotalWidth += columnWidth;\n        // replace sampled weight with min width if needed\n        const columnWeight =\n          minWidth != null && minWidth >= sampledWeightWidthsArray[i]\n            ? minWidth\n            : sampledWeightWidthsArray[i];\n        sampledWeightWidthsArray[i] = columnWeight;\n        totalPreferredWidth +=\n          maxWidth != null && maxWidth <= columnWeight ? maxWidth : columnWeight;\n        totalWorkingWeight += columnWeight;\n        totalRemainingWeight += columnWeight - columnWidth;\n        // newColumnWidthsArray already has content, so update in place rather than 'push'\n        newColumnWidthsArray[i] = columnWidth;\n        appliedColumnWidthsArray.push(columnWidth);\n      } else {\n        forcedTotalWidth += forcedWidth;\n        pendingTotalWidth += forcedWidth;\n        totalPreferredWidth += forcedWidth;\n        appliedColumnWidthsArray.push(forcedWidth);\n      }\n    }\n    // special case for initial rendering where we don't know if overall width is constrained\n    if (availableWidth === -1) {\n      availableWidth = totalPreferredWidth;\n    }\n    if (pendingTotalWidth < availableWidth) {\n      _enforceContentsMinMaxRules(\n        columnsArray,\n        availableWidth,\n        totalPreferredWidth,\n        totalRemainingWeight,\n        totalWorkingWeight,\n        pendingTotalWidth,\n        forcedTotalWidth,\n        forcedColumnWidthsArray,\n        sampledWeightWidthsArray,\n        columnMaxWidthsArray,\n        newColumnWidthsArray,\n        appliedColumnWidthsArray\n      );\n    }\n  }\n  return _createColumnWidths(columnsArray, newColumnWidthsArray);\n}\n\n/**\n * Helper function to enforce all of the layout sizing rules on the Table's columns.\n */\nfunction _enforceContentsMinMaxRules<K, D, C>(\n  columnsArray: TableColumn<K, D, C>[],\n  availableWidth: number,\n  totalPreferredWidth: number,\n  totalRemainingWeight: number,\n  totalWorkingWeight: number,\n  appliedPendingTotalWidth: number,\n  forcedTotalWidth: number,\n  forcedColumnWidthsArray: (number | undefined)[],\n  columnWeightsArray: number[],\n  columnMaxWidthsArray: (number | undefined)[],\n  newColumnWidthsArray: number[],\n  appliedColumnWidthsArray: number[]\n) {\n  // try and honor the weights of each column combined with the min widths, and then check that against\n  // any max widths once completed. if the final result doesn't fill the space AND at least 1 max width\n  // rule was enforced, repeat the process until no max rules are enforced OR the space is filled.\n  let isMaxRuleApplied = true;\n  while (isMaxRuleApplied) {\n    isMaxRuleApplied = false;\n    if (totalPreferredWidth > availableWidth) {\n      _enforceConstrainedWeightRules(\n        columnsArray,\n        availableWidth - appliedPendingTotalWidth,\n        totalRemainingWeight,\n        columnWeightsArray,\n        forcedColumnWidthsArray,\n        newColumnWidthsArray,\n        appliedColumnWidthsArray\n      );\n    } else {\n      _enforceWeightedMinRules(\n        columnsArray,\n        availableWidth,\n        totalWorkingWeight,\n        forcedTotalWidth,\n        forcedColumnWidthsArray,\n        columnWeightsArray,\n        newColumnWidthsArray,\n        appliedColumnWidthsArray\n      );\n    }\n\n    let pendingTotalWidth = 0;\n    for (let i = 0; i < columnsArray.length; i++) {\n      if (forcedColumnWidthsArray[i] == null) {\n        const maxWidth = columnMaxWidthsArray[i];\n        if (maxWidth != null && newColumnWidthsArray[i] > maxWidth) {\n          isMaxRuleApplied = true;\n          forcedColumnWidthsArray[i] = maxWidth;\n          forcedTotalWidth += maxWidth;\n          appliedPendingTotalWidth += maxWidth - appliedColumnWidthsArray[i];\n          totalWorkingWeight -= columnWeightsArray[i];\n          newColumnWidthsArray[i] = maxWidth;\n          appliedColumnWidthsArray[i] = maxWidth;\n        }\n      }\n      pendingTotalWidth += newColumnWidthsArray[i];\n    }\n    isMaxRuleApplied = isMaxRuleApplied && pendingTotalWidth < availableWidth;\n  }\n}\n\n/**\n * Helper function to enforce constrained weights / min width rules on the Table's columns.\n */\nfunction _enforceConstrainedWeightRules<K, D, C>(\n  columnsArray: TableColumn<K, D, C>[],\n  initialExtraWidth: number,\n  totalRemainingWeight: number,\n  columnWeightsArray: number[],\n  forcedColumnWidthsArray: (number | undefined)[],\n  newColumnWidthsArray: number[],\n  appliedColumnWidthsArray: number[]\n) {\n  if (initialExtraWidth > 0) {\n    let availableWidth = initialExtraWidth;\n    let currentWeightTotal = totalRemainingWeight;\n    for (let i = 0; i < columnsArray.length; i++) {\n      if (currentWeightTotal > 0 && forcedColumnWidthsArray[i] == null) {\n        const currentWeight = columnWeightsArray[i] - appliedColumnWidthsArray[i];\n        const weightWidth = (currentWeight / currentWeightTotal) * availableWidth;\n        newColumnWidthsArray[i] = weightWidth + appliedColumnWidthsArray[i];\n        availableWidth -= weightWidth;\n        currentWeightTotal -= currentWeight;\n      }\n    }\n  }\n}\n\n/**\n * Helper function to enforce the weights / min width rules on the Table's columns.\n */\nfunction _enforceWeightedMinRules<K, D, C>(\n  columnsArray: TableColumn<K, D, C>[],\n  availableWidth: number,\n  totalWeight: number,\n  forcedTotalWidth: number,\n  forcedColumnWidthsArray: (number | undefined)[],\n  columnWeightsArray: number[],\n  newColumnWidthsArray: number[],\n  appliedColumnWidthsArray: number[]\n) {\n  const pendingForcedColumnWidths = [] as (number | undefined)[];\n  let isMinRuleApplied = true;\n  while (isMinRuleApplied) {\n    isMinRuleApplied = false;\n    let currentWeightTotal = totalWeight;\n    let widthDiff = availableWidth - forcedTotalWidth;\n    if (widthDiff > 0) {\n      for (let i = 0; i < columnsArray.length; i++) {\n        if (\n          currentWeightTotal > 0 &&\n          forcedColumnWidthsArray[i] == null &&\n          pendingForcedColumnWidths[i] == null\n        ) {\n          const currentWeight = columnWeightsArray[i];\n          const newWidth = (currentWeight / currentWeightTotal) * widthDiff;\n\n          // if calculated width breaks min width requirement, force min width as needed\n          const minWidth = appliedColumnWidthsArray[i];\n          if (newWidth < minWidth) {\n            // the preferred weighted size conflicts with the min size, so set pending to min size\n            pendingForcedColumnWidths[i] = minWidth;\n            forcedTotalWidth += minWidth;\n            newColumnWidthsArray[i] = minWidth;\n            isMinRuleApplied = true;\n            totalWeight -= currentWeight;\n            break;\n          }\n          newColumnWidthsArray[i] = newWidth;\n          widthDiff -= newWidth;\n          currentWeightTotal -= currentWeight;\n        }\n      }\n    }\n  }\n}\n\n/**\n * Helper function to create a ColumnWidths object from a TableColumn array and a widths array.\n */\nfunction _createColumnWidths<K, D, C extends string>(\n  columnsArray: TableColumn<K, D, C>[],\n  columnWidthsArray: number[]\n) {\n  const columnWidths = {} as ColumnWidths<C>;\n  for (let i = 0; i < columnsArray.length; i++) {\n    columnWidths[columnsArray[i].key] = columnWidthsArray[i];\n  }\n  return columnWidths;\n}\n\n/**\n * Helper method to apply the given sizing object to the currently rendered Table\n * and column elements.\n */\nfunction _udpateTableSizing(\n  root: HTMLDivElement,\n  tableId: string,\n  widthsArray: number[],\n  totalWidth: number\n) {\n  const tableCols = root.querySelectorAll(`[data-oj-table-col='${tableId}']`);\n  for (let i = 0; i < tableCols.length; i++) {\n    const tableCol = tableCols[i] as HTMLTableColElement;\n    tableCol.style.width = `${widthsArray[i]}px`;\n  }\n  const innerTableElem = root.querySelectorAll(\n    `[data-oj-table-inner-table='${tableId}']`\n  )[0] as HTMLElement;\n  innerTableElem.style.width = `${totalWidth}px`;\n  innerTableElem.style.tableLayout = 'fixed';\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport {\n  useImperativeHandle,\n  useCallback,\n  useMemo,\n  useRef,\n  useLayoutEffect,\n  useState\n} from 'preact/hooks';\nimport { forwardRef, ForwardedRef } from 'preact/compat';\nimport { JSXInternal } from 'preact/src/jsx';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { useId } from '../hooks/UNSAFE_useId';\nimport { TabbableModeContext } from '../hooks/UNSAFE_useTabbableMode';\nimport { useUser } from '../hooks/UNSAFE_useUser';\nimport {\n  Cell,\n  Column,\n  ColumnWidths,\n  TableHorizontalScrollPosition,\n  TableVerticalScrollPosition\n} from '../UNSAFE_TableView';\nimport { TableColGroup } from './TableColGroup';\nimport { TableBody } from './TableBody';\nimport { TableHeader } from './TableHeader';\nimport { TableFooter } from './TableFooter';\nimport { TableDragIndicator } from './TableDragIndicator';\nimport { FocusTracker } from '../PRIVATE_FocusTracker';\nimport { Props, TableViewHandle } from '../UNSAFE_TableView';\nimport { useInteractionManager } from './hooks/useInteractionManager';\nimport { getLayoutColumnWidths } from './utils/TableLayoutUtils';\nimport {\n  getViewportConfig,\n  getHorizontalScrollPosition,\n  setHorizontalScrollPosition,\n  getVerticalScrollPosition,\n  setVerticalScrollPosition,\n  updateStickyColumns\n} from './utils/TableScrollUtils';\nimport { innerTableStyles, focusTrackerStyles } from './themes/Table.css';\nimport { TableVariantOptions, tableStyles } from './themes/TableStyles.css';\nimport { TableRedwoodTheme } from './themes/redwood/TableTheme';\nimport { useComponentTheme } from '../hooks/UNSAFE_useComponentTheme';\nimport { useResizeObserver } from '../hooks/UNSAFE_useResizeObserver';\nimport { useTestId } from '../hooks/UNSAFE_useTestId';\n\nexport type TableColumn<K, D, C> = {\n  key: C;\n  value: Column<K, D, C>;\n};\n\nexport type SampledWidths<C extends string> = {\n  minWidths: ColumnWidths<C>;\n  weightWidths: ColumnWidths<C>;\n};\n\nexport type SizingInfo =\n  | {\n      isInitialRender: true;\n      boxWidth?: number;\n      contentWidth?: number;\n      boxHeight?: number;\n      contentHeight?: number;\n      defaultScrollbarWidth?: number;\n      defaultScrollbarHeight?: number;\n    }\n  | {\n      isInitialRender: false;\n      boxWidth: number;\n      contentWidth: number;\n      boxHeight: number;\n      contentHeight: number;\n      defaultScrollbarWidth: number;\n      defaultScrollbarHeight: number;\n    };\n\ntype LayoutInfo =\n  | {\n      isLayoutRequired: true;\n      columnWidthsArray?: number[];\n    }\n  | {\n      isLayoutRequired: false;\n      columnWidthsArray: number[];\n    };\n\nexport type ColumnResizeInfo<C> =\n  | {\n      isResizing: false;\n      isResizeHover: boolean;\n      key?: C;\n      startX?: never;\n      delta?: never;\n      fullColumnWidths?: never;\n      ignoreClick: boolean;\n    }\n  | {\n      isResizing: true;\n      isResizeHover: boolean;\n      key: C;\n      startX: number;\n      delta: number;\n      fullColumnWidths: number[];\n      ignoreClick: boolean;\n    };\n\nexport type ScrollDetail<K, C> = {\n  cell: Cell<K, C>;\n  locationX?: 'inView' | 'start' | 'end';\n  locationY?: 'inView' | 'top' | 'bottom';\n};\n\nconst _defaultSelected = {\n  row: { all: false, keys: new Set() },\n  column: { all: false, keys: new Set() }\n};\n\n/**\n * Component that renders items as a flat table.\n * In order to maximize performance, only items that are visible in the viewport are rendered.\n */\nexport const Table = forwardRef(function Table<K extends string | number, D, C extends string>(\n  {\n    'aria-label': ariaLabel,\n    'aria-labelledby': ariaLabelledBy,\n    getAccessibleRowHeaders,\n    columns,\n    columnOrder,\n    columnWidths,\n    layout = 'contents',\n    data,\n    getRowKey,\n    hasMore = false,\n    onLoadMore = () => {},\n    currentCellOverride,\n    onPersistCurrentCell,\n    currentRowVariant,\n    gridlines,\n    selectionMode,\n    selected = _defaultSelected as NonNullable<Props<K, D, C>['selected']>,\n    onSelectionChange,\n    onRowAction,\n    sortCriterion,\n    onSortCriterionChange,\n    horizontalScrollPositionOverride,\n    verticalScrollPositionOverride,\n    columnResizingIndicator,\n    onColumnResizing,\n    onColumnResize,\n    noDataRenderer,\n    testId\n  }: Props<K, D, C>,\n  ref?: ForwardedRef<TableViewHandle<K, C>>\n) {\n  const tableId = useId();\n  const outerTableRef = useRef<HTMLDivElement>(null);\n  const sizingInfoRef = useRef<SizingInfo>({ isInitialRender: true });\n  const [appliedColumnWidths, setAppliedColumnWidths] = useState<ColumnWidths<C>>();\n  const [contentHeight, setContentHeight] = useState<number>();\n  const isVerticalScrollRef = useRef<boolean>(false);\n  const sampledColumnWidthsRef = useRef<SampledWidths<C>>();\n  const horizontalScrollPositionOverrideRef = useRef<TableHorizontalScrollPosition<C>>();\n  const verticalScrollPositionOverrideRef = useRef<TableVerticalScrollPosition<K>>();\n\n  const [stickyEdgesState, setStickyEdgesState] = useState<{ start?: number; end?: number }>({\n    start: undefined,\n    end: undefined\n  });\n\n  const resizeInfoRef = useRef<ColumnResizeInfo<C>>({\n    isResizing: false,\n    isResizeHover: false,\n    ignoreClick: false\n  });\n\n  const { direction } = useUser();\n  const isRtl = direction === 'rtl';\n  const testIdProps = useTestId(testId);\n\n  const columnsArray = useMemo(() => {\n    const newColumnsArray = [] as Array<TableColumn<K, D, C>>;\n    if (columnOrder != null) {\n      for (const key of columnOrder) {\n        if (columns[key] != null) {\n          newColumnsArray.push({\n            key: key,\n            value: columns[key]\n          });\n        }\n      }\n    } else {\n      for (const [key, value] of Object.entries(columns)) {\n        newColumnsArray.push({\n          key: key as C,\n          value: value as Column<K, D, C>\n        });\n      }\n    }\n    return newColumnsArray;\n  }, [columnOrder, columns]);\n\n  let isLayoutRequired = false;\n  const columnWidthsArray = [];\n  if (appliedColumnWidths != null) {\n    for (let i = 0; i < columnsArray.length; i++) {\n      const key = columnsArray[i].key;\n      const appliedWidth = appliedColumnWidths[key];\n      const staticWidth = columnWidths != null ? columnWidths[key] : undefined;\n      if (appliedWidth == null || (staticWidth != null && staticWidth !== appliedWidth)) {\n        isLayoutRequired = true;\n        break;\n      }\n      columnWidthsArray.push(appliedWidth);\n    }\n  } else {\n    isLayoutRequired = true;\n  }\n  const layoutInfo = {\n    isLayoutRequired: isLayoutRequired,\n    columnWidthsArray: isLayoutRequired ? undefined : columnWidthsArray\n  } as LayoutInfo;\n\n  useImperativeHandle(\n    ref!,\n    () => {\n      return {\n        getHorizontalScrollPosition: () => {\n          if (layoutInfo.isLayoutRequired) {\n            return {};\n          }\n          return getHorizontalScrollPosition(\n            outerTableRef.current!,\n            columnsArray,\n            layoutInfo.columnWidthsArray\n          );\n        },\n        getVerticalScrollPosition: () => {\n          if (layoutInfo.isLayoutRequired) {\n            return {};\n          }\n          return getVerticalScrollPosition(outerTableRef.current!, tableId);\n        }\n      };\n    },\n    [tableId, columnsArray, layoutInfo.isLayoutRequired, layoutInfo.columnWidthsArray]\n  );\n\n  const cellHasRenderer = useCallback(\n    (cell: Cell<K, C>) => {\n      let hasRenderer = false;\n      if (cell.type === 'noData') {\n        hasRenderer = noDataRenderer != null;\n      } else {\n        for (const column of columnsArray) {\n          if (column.key === cell.columnKey) {\n            if (cell.type === 'data') {\n              hasRenderer = column.value.renderer != null;\n            } else if (cell.type === 'header') {\n              hasRenderer = column.value.headerRenderer != null;\n            } else if (cell.type === 'footer') {\n              hasRenderer = column.value.footerRenderer != null;\n            }\n            break;\n          }\n        }\n      }\n      return hasRenderer;\n    },\n    [columnsArray, noDataRenderer]\n  );\n\n  const {\n    interactionManagerProps,\n    onTableSelectionChange,\n    isShowFocusRing,\n    isTabbableMode,\n    currentCell,\n    onStartFocusTracking,\n    onFocusStartEdge,\n    onFocusEndEdge\n  } = useInteractionManager({\n    outerTableRef,\n    tableId,\n    data,\n    isRtl,\n    columnsArray,\n    appliedColumnWidths: appliedColumnWidths!,\n    sizingInfoRef,\n    resizeInfoRef,\n    stickyEdgesState,\n    setStickyEdgesState,\n    cellHasRenderer,\n    fullColumnWidths: layoutInfo.isLayoutRequired ? undefined : layoutInfo.columnWidthsArray,\n    onColumnResizing,\n    onColumnResize,\n    currentCellOverride,\n    onPersistCurrentCell,\n    selectionMode,\n    selected,\n    onSelectionChange,\n    onRowAction,\n    sortCriterion,\n    onSortCriterionChange\n  });\n\n  // ensure sampled column sizes are cleared if 'columns' is updated\n  useLayoutEffect(() => {\n    sampledColumnWidthsRef.current = undefined;\n    setAppliedColumnWidths(undefined);\n  }, [columns]);\n\n  // setup sizing calculation updates for subsequent renders\n  useLayoutEffect(() => {\n    const rootElement = outerTableRef.current;\n    if (\n      rootElement != null &&\n      !sizingInfoRef.current.isInitialRender &&\n      layoutInfo.isLayoutRequired &&\n      sizingInfoRef.current.defaultScrollbarWidth != null\n    ) {\n      const totalWidth =\n        layout === 'fixed'\n          ? sizingInfoRef.current.boxWidth - sizingInfoRef.current.defaultScrollbarWidth\n          : -1;\n      const newColumnWidths = getLayoutColumnWidths(\n        rootElement,\n        sizingInfoRef.current.defaultScrollbarWidth,\n        tableId,\n        layout === 'fixed',\n        sampledColumnWidthsRef,\n        totalWidth,\n        columnsArray,\n        columnWidths\n      );\n      setAppliedColumnWidths(newColumnWidths);\n    }\n  }, [tableId, columnsArray, columnWidths, layout, layoutInfo.isLayoutRequired]);\n\n  // setup component resize-based sizing calculation updates\n  const resizeObserverCallbackRef = useRef<(entry: ResizeObserverEntry) => void>();\n  resizeObserverCallbackRef.current = (entry: ResizeObserverEntry) => {\n    if (outerTableRef.current != null) {\n      let availableWidth;\n      let scrollbarWidth;\n      const newContentWidth = entry.contentBoxSize[0].inlineSize;\n      const newContentHeight = entry.contentBoxSize[0].blockSize;\n      const newBoxWidth = entry.borderBoxSize[0].inlineSize;\n      const newBoxHeight = entry.borderBoxSize[0].blockSize;\n\n      if (newContentWidth !== 0 || newBoxWidth !== 0) {\n        if (sizingInfoRef.current.isInitialRender) {\n          scrollbarWidth = newBoxWidth - newContentWidth;\n          availableWidth = layout === 'fixed' ? newContentWidth : -1;\n          sizingInfoRef.current = {\n            isInitialRender: false,\n            contentWidth: newContentWidth,\n            boxWidth: newBoxWidth,\n            contentHeight: newContentHeight,\n            boxHeight: newBoxHeight,\n            defaultScrollbarWidth: scrollbarWidth,\n            defaultScrollbarHeight: newBoxHeight - newContentHeight\n          };\n        } else {\n          scrollbarWidth = sizingInfoRef.current.defaultScrollbarWidth;\n          availableWidth = isVerticalScrollRef.current\n            ? newContentWidth\n            : newBoxWidth - scrollbarWidth;\n          sizingInfoRef.current.contentWidth = newContentWidth;\n          sizingInfoRef.current.boxWidth = newBoxWidth;\n          sizingInfoRef.current.contentHeight = newContentHeight;\n          sizingInfoRef.current.boxHeight = newBoxHeight;\n        }\n        const newColumnWidths = getLayoutColumnWidths(\n          outerTableRef.current,\n          scrollbarWidth,\n          tableId,\n          layout === 'fixed',\n          sampledColumnWidthsRef,\n          availableWidth,\n          columnsArray,\n          columnWidths\n        );\n        setAppliedColumnWidths(newColumnWidths);\n        if (contentHeight !== newContentHeight) {\n          setContentHeight(newContentHeight);\n        }\n      }\n    }\n  };\n  // ensure resize observer callback function is static to avoid hook re-subscribing each render\n  const staticResizeObserverCallback = useCallback((entry: ResizeObserverEntry) => {\n    resizeObserverCallbackRef.current!(entry);\n  }, []);\n  useResizeObserver(outerTableRef, staticResizeObserverCallback);\n\n  // after each additional render, update vertical scrollbar state if necessary\n  useLayoutEffect(() => {\n    const scrollbarWidth = sizingInfoRef.current.defaultScrollbarWidth;\n    if (\n      outerTableRef.current != null &&\n      !sizingInfoRef.current.isInitialRender &&\n      contentHeight != null &&\n      scrollbarWidth != null\n    ) {\n      const innerTable = outerTableRef.current.querySelector(\n        `[data-oj-table-inner-table='${tableId}']`\n      );\n      if (innerTable != null) {\n        const hasVerticalOverflow = contentHeight < innerTable.getBoundingClientRect().height;\n        isVerticalScrollRef.current = hasVerticalOverflow;\n        if (hasVerticalOverflow) {\n          outerTableRef.current.classList.remove(tableStyles.noVerticalScroll);\n          outerTableRef.current.classList.add(tableStyles.verticalScroll);\n          outerTableRef.current.style.paddingInlineEnd = '';\n        } else {\n          outerTableRef.current.classList.remove(tableStyles.verticalScroll);\n          outerTableRef.current.classList.add(tableStyles.noVerticalScroll);\n          outerTableRef.current.style.paddingInlineEnd = `${scrollbarWidth}px`;\n        }\n      }\n    }\n  }, [tableId, contentHeight, data, noDataRenderer, appliedColumnWidths]);\n\n  // update horizontal scroll position if a new value is provided\n  useLayoutEffect(() => {\n    if (\n      horizontalScrollPositionOverrideRef.current !== horizontalScrollPositionOverride &&\n      !layoutInfo.isLayoutRequired\n    ) {\n      setHorizontalScrollPosition(\n        outerTableRef.current!,\n        columnsArray,\n        layoutInfo.columnWidthsArray,\n        isRtl,\n        horizontalScrollPositionOverride\n      );\n      horizontalScrollPositionOverrideRef.current = horizontalScrollPositionOverride;\n    }\n  }, [\n    tableId,\n    columnsArray,\n    layoutInfo.isLayoutRequired,\n    layoutInfo.columnWidthsArray,\n    horizontalScrollPositionOverride,\n    isRtl\n  ]);\n\n  // update vertical scroll position if a new value is provided\n  useLayoutEffect(() => {\n    if (\n      verticalScrollPositionOverrideRef.current !== verticalScrollPositionOverride &&\n      !layoutInfo.isLayoutRequired\n    ) {\n      setVerticalScrollPosition(outerTableRef.current!, tableId, verticalScrollPositionOverride);\n      verticalScrollPositionOverrideRef.current = verticalScrollPositionOverride;\n    }\n  }, [tableId, layoutInfo.isLayoutRequired, verticalScrollPositionOverride]);\n\n  // ensure sticky columns are updated appropriately\n  useLayoutEffect(() => {\n    if (outerTableRef.current != null && !layoutInfo.isLayoutRequired) {\n      updateStickyColumns(\n        outerTableRef.current,\n        tableId,\n        isRtl,\n        columnsArray,\n        layoutInfo.columnWidthsArray,\n        stickyEdgesState,\n        setStickyEdgesState\n      );\n    }\n  }, [\n    tableId,\n    columnsArray,\n    layoutInfo.isLayoutRequired,\n    layoutInfo.columnWidthsArray,\n    isRtl,\n    stickyEdgesState\n  ]);\n\n  // initialize base Table style classes\n  const { classes: themeClasses } = useComponentTheme<TableVariantOptions>(TableRedwoodTheme, {\n    forceScroll: sizingInfoRef.current.isInitialRender ? 'isForceScroll' : 'notForceScroll',\n    verticalScroll: isVerticalScrollRef.current ? 'isVerticalScroll' : 'notVerticalScroll',\n    disableWrapping:\n      layout === 'contents' && sampledColumnWidthsRef.current === undefined\n        ? 'isDisableWrapping'\n        : 'notDisableWrapping'\n  });\n\n  const classes = classNames([themeClasses]);\n  const tableClasses = classNames([innerTableStyles.base]);\n  const focusTrackerClasses = classNames([focusTrackerStyles.base]);\n\n  // aria-rowcount includes header and footer rows\n  const hasFooters = columnsArray.some((column: TableColumn<K, D, C>) => {\n    return column.value.footerRenderer != null || column.value.footerText != null;\n  });\n  const ariaRowCount = data == null ? undefined : hasMore ? -1 : data.length + (hasFooters ? 2 : 1);\n\n  const startStickyEdge = stickyEdgesState.start;\n  const endStickyEdge = stickyEdgesState.end;\n\n  const hasVerticalGridlines = gridlines?.vertical === 'visible';\n  const hasHorizontalGridlines = gridlines?.horizontal !== 'hidden';\n\n  const isRowSelectionEnabled =\n    selectionMode?.row === 'single' || selectionMode?.row === 'multiple';\n  const isColumnSelectionEnabled =\n    selectionMode?.column === 'single' || selectionMode?.column === 'multiple';\n\n  const getTableBodyProps = () => {\n    return {\n      tableId: tableId,\n      data: data,\n      columnsArray: columnsArray,\n      getAccessibleRowHeaders: getAccessibleRowHeaders,\n      hasVerticalGridlines: hasVerticalGridlines,\n      hasHorizontalGridlines: hasHorizontalGridlines,\n      selected: selected,\n      isRowSelectionEnabled: isRowSelectionEnabled,\n      isSingleRowSelectionEnabled: selectionMode?.row === 'single',\n      currentCell: currentCell,\n      currentRowVariant: currentRowVariant,\n      isShowFocusRing: isShowFocusRing,\n      getRowKey: getRowKey,\n      hasMore: hasMore,\n      onLoadMore: onLoadMore,\n      noDataRenderer: noDataRenderer,\n      viewportConfig: getViewportConfig(outerTableRef),\n      onSelectionChange: onTableSelectionChange,\n      startStickyEdge: startStickyEdge,\n      endStickyEdge: endStickyEdge,\n      isRtl: isRtl\n    };\n  };\n\n  const getTableColGroupProps = () => {\n    let columnWidthsArray;\n    if (!layoutInfo.isLayoutRequired) {\n      columnWidthsArray = layoutInfo.columnWidthsArray;\n    } else {\n      columnWidthsArray = [];\n      for (let i = 0; i < columnsArray.length; i++) {\n        columnWidthsArray[i] = undefined;\n      }\n    }\n    return {\n      tableId: tableId,\n      columnWidthsArray: columnWidthsArray\n    };\n  };\n\n  const getTableHeaderProps = () => {\n    return {\n      tableId: tableId,\n      columnsArray: columnsArray,\n      hasVerticalGridlines: hasVerticalGridlines,\n      focusedKey: currentCell?.type === 'header' ? currentCell.columnKey : undefined,\n      selectedColumnKeys: selected.column,\n      selectedRowKeys: selected.row,\n      isColumnSelectionEnabled: isColumnSelectionEnabled,\n      isRowSelectionEnabled: isRowSelectionEnabled,\n      onSelectionChange: onTableSelectionChange,\n      sortCriterion: sortCriterion,\n      onSortCriterionChange: onSortCriterionChange,\n      isShowFocusRing: isShowFocusRing,\n      startStickyEdge: startStickyEdge,\n      endStickyEdge: endStickyEdge,\n      isResizeHover: resizeInfoRef.current.isResizeHover,\n      isRtl: isRtl\n    };\n  };\n\n  const getTableFooterProps = () => {\n    return {\n      tableId: tableId,\n      isRendered: hasFooters,\n      columnsArray: columnsArray,\n      hasVerticalGridlines: hasVerticalGridlines,\n      focusedKey: currentCell?.type === 'footer' ? currentCell.columnKey : undefined,\n      selectedKeys: selected.column,\n      isColumnSelectionEnabled: isColumnSelectionEnabled,\n      isShowFocusRing: isShowFocusRing,\n      startStickyEdge: startStickyEdge,\n      endStickyEdge: endStickyEdge,\n      isRtl: isRtl\n    };\n  };\n\n  const getTableDragIndicator = () => {\n    if (columnResizingIndicator != null && !layoutInfo.isLayoutRequired) {\n      let position = 0;\n      for (let i = 0; i < columnsArray.length; i++) {\n        position += layoutInfo.columnWidthsArray[i];\n        if (columnsArray[i].key === columnResizingIndicator.key) {\n          if (columnResizingIndicator.delta != null) {\n            position += columnResizingIndicator.delta;\n          }\n          break;\n        }\n      }\n      return <TableDragIndicator position={position} isRtl={isRtl} />;\n    }\n    return undefined;\n  };\n\n  const getTableStyle = () => {\n    let widthString = '';\n    let heightString = '';\n    if (!layoutInfo.isLayoutRequired) {\n      let totalWidth = 0;\n      for (let i = 0; i < layoutInfo.columnWidthsArray.length; i++) {\n        totalWidth += layoutInfo.columnWidthsArray[i];\n      }\n      widthString = `width: ${totalWidth}px; table-layout: fixed;`;\n    } else {\n      // shrink table down as much as possible when a 'contents' layout is required, otherwise\n      // the sampled column widths will not reflect the true minimum sizes with line-clamping\n      widthString = layout !== 'contents' ? 'width: 100%;' : 'width: 1px';\n    }\n    if (contentHeight != null) {\n      heightString = data == null || data.length === 0 ? `min-height: ${contentHeight}px;` : '';\n    }\n    return `${widthString}${heightString}`;\n  };\n\n  return (\n    <div\n      {...testIdProps}\n      ref={outerTableRef}\n      aria-colcount={columnsArray.length}\n      aria-label={ariaLabel}\n      aria-labelledby={ariaLabelledBy}\n      aria-rowcount={ariaRowCount}\n      {...(selectionMode?.column === 'multiple' || selectionMode?.row === 'multiple'\n        ? { 'aria-multiselectable': true }\n        : {})}\n      class={classes}\n      role={'grid'}\n      {...interactionManagerProps}>\n      <FocusTracker\n        styleClass={focusTrackerClasses}\n        isDisabled={!isTabbableMode}\n        onFocusStartEdge={onFocusStartEdge}\n        onFocusEndEdge={onFocusEndEdge}\n        onStartTracking={onStartFocusTracking}>\n        <TabbableModeContext.Provider value={{ isTabbable: isTabbableMode }}>\n          <table\n            class={tableClasses}\n            role={'presentation'}\n            style={getTableStyle()}\n            data-oj-table-inner-table={tableId}>\n            <TableColGroup {...getTableColGroupProps()} />\n            <TableHeader {...getTableHeaderProps()} />\n            <TableBody {...getTableBodyProps()} />\n            <TableFooter {...getTableFooterProps()} />\n          </table>\n        </TabbableModeContext.Provider>\n        {getTableDragIndicator()}\n      </FocusTracker>\n    </div>\n  );\n}) as <K extends string | number, D, C extends string>(\n  p: Props<K, D, C> & { ref?: ForwardedRef<TableViewHandle<K, C>> }\n) => JSXInternal.Element;\n"],"names":["TableColGroup","tableId","columnWidthsArray","getColStyle","columnWidth","_jsx","map","jsx","style","_timerValue","TableSkeletonRow","colspan","preactKey","minimumCount","isVisible","setIsVisible","useState","useEffect","setTimeout","cellClasses","classNames","tableSkeletonCellStyles","base","class","LOADMORE_STYLE_CLASS","children","colSpan","role","Array","_element","tableSkeletonBarContainerStyles","Skeleton","height","_defaultCellRenderer","rowData","field","Text","truncation","variant","size","String","TableCell","columnKey","columnIndex","rowKey","rowIndex","isFinalRowIndex","isFinalColumnIndex","hasVerticalGridlines","hasHorizontalGridlines","isRowSelected","isPreviousRowSelected","isColumnSelected","isPreviousColumnSelected","isShowFocusRing","isRowHeader","stickyColumn","renderer","selectorRenderer","isRowSelectionEnabled","isRowSingleSelection","applyActiveStyle","applyHoverStyle","applyPseudoHoverStyle","isStickyStartEdge","isStickyEndEdge","isRtl","hasRenderer","classes","themeClasses","useComponentTheme","TableCellRedwoodTheme","defaultRenderer","firstRow","lastRow","firstColumn","lastColumn","borderTopSpacer","borderBottomSpacer","borderStartSpacer","borderEndSpacer","verticalGrid","horizontalGrid","rowSingleSelection","rowSelectable","rowSelected","previousRowSelected","columnSelected","previousColumnSelected","stickyStartColumn","stickyEndColumn","stickyStartEdge","stickyEndEdge","rowHighlight","showFocusRing","active","hover","pseudoHover","rtl","cellRendererProps","selector","id","useId","tabIndex","MemoizeTableRow","memo","isFinalRow","columnsArray","rowHeaderColumnKeys","isSelected","isPreviousSelected","isSingleRowSelectionEnabled","selectedRowKeys","all","keys","Set","focusRingColumnKey","selectedColumnKeys","onSelectionChange","startStickyEdge","endStickyEdge","translations","useTranslationBundle","interactionProps","useInteractionStyle","TableRowRedwoodTheme","accessibleRowName","toString","handleRowSelectorChange","detail","value","row","column","target","Selector","collection_selectRow","ROW_NAME","onChange","selectedKeys","undefined","key","containsKey","cellProps","stickyEdge","length","has","prev","next","columnsArray1","columnsArray2","i","_areColumnsArraysEquivalent","horizontalGridlines","verticalGridlines","set1","set2","every","x","isSameKey","TableNoData","columnsCount","rowClasses","tableRowStyles","TableNoDataRedwoodTheme","contentRenderer","collection_noData","TableBody","getAccessibleRowHeaders","data","getRowKey","hasMore","onLoadMore","viewportConfig","currentCell","currentRowVariant","selected","noDataRenderer","loadIndicatorKeyRef","useRef","Date","getTime","isShowEmptyLoadingRef","collectionClasses","collectionStyles","getRowContext","useCallback","context","index","collectionData","d","metadata","isShowEmptyLoading","isShowNoData","current","type","LoadMoreCollection","loadMoreIndicator","tableRowContext","containsCurrentCell","rowProps","TableHeaderCell","isColumnSelectable","headerText","sortable","sortDirection","onSortCriterionChange","TableHeaderCellRedwoodTheme","columnSelectable","selectorAllState","deletedKeys","handleSelectorChange","headerCellRendererProps","SelectorAll","collection_selectAllRows","sortControl","EmbeddedIconButton","collection_sortEnabled","collection_sortDisabled","isDisabled","onAction","handleSortGesture","SortAscendingIcon","SortDescendingIcon","SortDefaultIcon","SvgChevronUpDown","getHeaderCellRenderer","text","tableHeaderCellTextStyles","overflowWrap","lineClamp","_jsxs","tableHeaderSortContainerStyles","getAriaSort","TableHeader","focusedKey","isColumnSelectionEnabled","sortCriterion","isResizeHover","tableHeaderRowStyles","containerClasses","tableHeaderRowContainerStyles","criterion","headerCellProps","selectable","headerRenderer","_defaultFooterCellRenderer","footerText","TableFooterCell","TableFooterCellRedwoodTheme","footerCellRendererProps","TableFooter","isRendered","tableFooterRowStyles","tableFooterRowContainerStyles","footerCellProps","footerRenderer","TableDragIndicator","position","tableDragIndicatorClasses","tableDragIndicatorStyles","getCellType","element","dataset","Number","getRowKeyForRowIndex","root","rowElements","querySelectorAll","getRowIndexForRowElement","rowElement","prototype","indexOf","call","getColumnKey","getColumnIndexForHeaderFooterElement","cellElement","isHeader","columnElements","logicalCellExtractor","cellSelector","onlyAncestors","startingElement","parentElement","closest","cellType","keyExtractor","getElementFromCell","cell","headerElements","headerElement","footerElements","footerElement","cellElements","querySelector","getScrollerBottomOffset","footerRowElement","getBoundingClientRect","getFirstFocusableRowKey","firstRowElement","getLastFocusableRowKey","rowCount","getFirstFocusableCell","firstCellElement","firstCellType","hasNoDataCell","hasFooterCells","_scrollRowIntoView","scrollerElement","scrollbarHeight","location","topOffset","headerRowElement","getScrollerTopOffset","bottomOffset","verticalOverflowDiff","_getVerticalOverflowDiff","topOverflowDiff","top","hasTopOverflow","bottomOverflowDiff","bottom","hasBottomOverflow","Math","abs","scrollTop","_roundScrollValue","isOver","ceil","floor","_getHorizontalOverflowDiff","startOffset","endOffset","scrollbarWidth","elementRect","scrollerRect","left","right","setHorizontalScrollPosition","fullColumnWidths","horizontalScrollPosition","scrollPosition","useColumn","offsetX","getHorizontalScrollPosition","_getScrollLeftFromScrollPosition","scrollLeft","setVerticalScrollPosition","verticalScrollPosition","y","useRow","offsetY","getVerticalScrollPosition","_getScrollTopFromScrollPosition","newScrollLeft","columnEnd","newScrollTop","rowBottom","rowHeight","applyScrollDetail","sizingInfo","scrollDetail","scroller","findElementByKey","boxHeight","contentHeight","locationY","columnElement","stickyStartColumns","getStickyColumnIndicies","stickyIndex","stickyEndColumns","horizontalOverflowDiff","leftOverflowDiff","hasLeftOverflow","rightOverflowDiff","hasRightOverflow","_scrollColumnIntoView","boxWidth","contentWidth","locationX","isStart","stickyColumns","edge","push","_applyStickyColumnOffset","stickyOffset","styleProperty","styleValue","j","updateStickyEdges","stickyEdgesState","setStickyEdgesState","currentScrollIndex","newScrollPosition","startIndex","endIndex","stickyStartIndicies","currentIndex","currentWidth","endOverflow","scrollWidth","clientWidth","stickyEndIndicies","start","end","getViewportConfig","outerTableRef","config","cellComparator","cell1","cell2","handleAdjacentRowGesture","initialCell","onCurrentCellChanged","isPrevious","newCurrentCell","currentRowKey","currentRowElement","adjacentRowElement","previousElementSibling","nextElementSibling","newColumnKey","_getBoundaryColumnKey","handlePageRowGesture","sizingInfoRef","verticalRowIndex","getRowIndexForRowKey","targetRowIndex","max","scrollerBottom","newRowKey","handleAdjacentColumnGesture","newKey","initialKey","_getAdjacentColumnKey","isFirst","handleJumpColumnGesture","includeRows","MOUSE_FOCUS_SHIFT_TIMEOUT","TOUCH_FOCUS_SHIFT_TIMEOUT","NAVIGATION_KEYS","handleRowActionGesture","onRowAction","targetElement","targetCell","targetCellElement","handleSelectionGesture","isMultiSelectGesture","selectionMode","emptyKeys","selectedRows","selectedColumns","removeKey","addKey","_applyRangeSelection","isRowGesture","handleExtendSelectionGesture","selectionExtensionElementRef","currentCellElement","startElement","isRow","extendedElement","cursorElement","extensionElement","extensionCell","_updateResizingState","event","resizeInfoRef","getElementContainsFunc","cellRect","endEdge","pageX","edgeResizable","cursor","handleColumnResizeEndGesture","appliedColumnWidths","onColumnResize","isResizing","innerTable","rect","currentX","clientX","delta","startX","allColumnWidths","ignoreClick","usePointerHandling","onColumnResizing","onTableSelectionChange","selectionTouchRef","_pointerMoveHandler","handleColumnResizingGesture","handleOverResizeRegionGesture","_pointerDownHandler","pointerType","shiftKey","isRangeSelectionGesture","getIsSelectionPending","preventDefault","pointerX","resizeColumnWidths","handleColumnResizeStartGesture","_pointerUpHandler","_pointerLeaveHandler","_event","handleLeaveResizingGesture","_pointerEnterHandler","buttons","handleEnterResizingGesture","_clickHandler","isSelectionExtension","platform","getClientHints","endElement","handleRangeSelectionGesture","metaKey","ctrlKey","stopPropagation","onPointerMove","onPointerDown","onPointerUp","onPointerLeave","onPointerEnter","onClick","useInteractionManager","cellHasRenderer","currentCellOverride","onPersistCurrentCell","useMemo","isExtendableSelection","focusHandlingProps","isTabbableMode","onStartFocusTracking","onFocusStartEdge","onFocusEndEdge","cellSupportsTabbable","blurFromWindowRef","isRenderCycle","blurredRenderCycleElementRef","hasFocusRef","setIsTabbableMode","setIsShowFocusRing","recentPointerRef","pointerTimerRef","isShowFocusRingOverrideRef","setCurrentCell","currentCellRef","isTabbing","setIsTabbing","currentCellOverrideRef","_setAsInactive","_enableNavigationMode","skipScrollCellIntoView","rootElement","_enableTabbableMode","isKeyboard","_disableTabbableMode","focus","preventScroll","clearTimeout","_touchEndHandler","_onFocusHandler","_onBlurHandler","document","activeElement","relatedTarget","isUnknownRelatedTarget","_onKeyDownHandler","handleEnterActionableMode","hasFocusWithin","allTabbableElements","handleWrapActionableFocus","tabbableElements","blurredRenderCycleElement","getActiveElement","getBodyElement","isTabbableElement","onTouchEnd","onFocus","onBlur","onKeyDown","useFocusHandling","keyboardHandlingProps","_keyDownHandler","keyHandlers","Enter","handleSortActionGesture","ArrowUp","ArrowDown","ArrowLeft","ArrowRight","PageUp","PageDown","Home","End","Object","includes","useKeyboardHandling","pointerHandlingProps","scrollHandlingProps","onScroll","useScrollHandling","interactionManagerProps","mergeProps","getLayoutColumnWidths","outerTableElement","isFixed","sampledColumnWidthsRef","availableWidth","staticColumnWidths","DEFAULT_COLUMN_WEIGHT","DEFAULT_COLUMN_MIN_WIDTH","DEFAULT_COLUMN_MAX_WIDTH","requiresActiveSizing","totalWorkingWeight","forcedTotalWidth","pendingTotalWidth","columnMaxWidthsArray","columnWeightsArray","forcedColumnWidthsArray","newColumnWidthsArray","appliedColumnWidthsArray","columnMinWidth","minWidth","columnMaxWidth","maxWidth","columnWeight","weight","isMaxRuleApplied","_enforceWeightedMinRules","_enforceFixedMinMaxRules","_createColumnWidths","_getFixedLayoutColumnWidths","newColumnWidths","_getContentsLayoutColumnWidths","totalWidth","widthsArray","width","tableCols","innerTableElem","tableLayout","_udpateTableSizing","columnMinWidthsArray","totalPreferredWidth","totalRemainingWeight","sampledWidths","sampledMinWidthsArray","sampledWeightWidthsArray","minWidths","weightWidths","sampledWeightWidth","classList","remove","tableStyles","disableWrapping","sampledMinWidth","forcedWidth","appliedPendingTotalWidth","_enforceConstrainedWeightRules","_enforceContentsMinMaxRules","initialExtraWidth","currentWeightTotal","currentWeight","weightWidth","totalWeight","pendingForcedColumnWidths","isMinRuleApplied","widthDiff","newWidth","columnWidths","_defaultSelected","Table","forwardRef","ariaLabel","ariaLabelledBy","columns","columnOrder","layout","gridlines","horizontalScrollPositionOverride","verticalScrollPositionOverride","columnResizingIndicator","testId","ref","isInitialRender","setAppliedColumnWidths","setContentHeight","isVerticalScrollRef","horizontalScrollPositionOverrideRef","verticalScrollPositionOverrideRef","direction","useUser","testIdProps","useTestId","newColumnsArray","entries","isLayoutRequired","appliedWidth","staticWidth","layoutInfo","useImperativeHandle","useLayoutEffect","defaultScrollbarWidth","resizeObserverCallbackRef","entry","newContentWidth","contentBoxSize","inlineSize","newContentHeight","blockSize","newBoxWidth","borderBoxSize","newBoxHeight","defaultScrollbarHeight","staticResizeObserverCallback","useResizeObserver","hasVerticalOverflow","noVerticalScroll","add","verticalScroll","paddingInlineEnd","stickyStartOffset","stickyEndOffset","updateStickyColumns","TableRedwoodTheme","forceScroll","tableClasses","innerTableStyles","focusTrackerClasses","focusTrackerStyles","hasFooters","some","ariaRowCount","vertical","horizontal","FocusTracker","styleClass","onStartTracking","TabbableModeContext","Provider","isTabbable","widthString","heightString","getTableStyle","getTableColGroupProps","getTableDragIndicator"],"mappings":"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"}