{"version":3,"file":"UNSAFE_DrawerPopup.js","sources":["../../src/UNSAFE_DrawerPopup/DrawerPopup.tsx"],"sourcesContent":["import { JSX, RefObject } from 'preact';\nimport { useState, useRef, useEffect, useCallback } from 'preact/hooks';\nimport { Layer } from '../UNSAFE_Layer';\nimport { Modal } from '../UNSAFE_Modal';\nimport { FocusTrap } from '../UNSAFE_FocusTrap';\nimport {\n  getAutofocusFocusables,\n  focusOn,\n  focusWithin,\n  getActiveElement\n} from '../utils/PRIVATE_tabbableUtils';\nimport { normalizePosition } from '../utils/PRIVATE_floatingUtils';\nimport { RtlSide } from '../UNSAFE_Floating';\nimport { getClientHints } from '../utils/PRIVATE_clientHints';\n\n// Hooks\nimport { useOutsideClick } from '../hooks/UNSAFE_useOutsideClick';\nimport { useAnimation } from '../hooks/UNSAFE_useAnimation';\nimport { useUser } from '../hooks/UNSAFE_useUser';\nimport { useTestId, TestIdProps } from '../hooks/UNSAFE_useTestId';\nimport { useSwipe } from '../hooks/UNSAFE_useSwipe';\n\n// Style imports\nimport { useComponentTheme } from '../hooks/UNSAFE_useComponentTheme';\nimport { DrawerPopupVariantOptions } from './themes/DrawerPopupStyles.css';\nimport { colorInterpolations, ColorProps } from '../utils/UNSAFE_interpolations/colors';\nimport { mergeInterpolations } from '../utils/UNSAFE_mergeInterpolations';\nimport { DrawerPopupRedwoodTheme } from './themes/redwood/DrawerPopupTheme';\n\n// Types\ntype IntrinsicProps = Pick<JSX.HTMLAttributes<HTMLDivElement>, 'children'>;\ntype Placement = 'start' | 'end' | 'bottom';\ntype NormalizedPlacement = 'left' | 'right' | 'bottom';\ntype Status = 'unmounted' | 'initial' | 'opening' | 'closing';\ntype VisibilityStatus = 'hidden' | 'visible';\ntype DisplayModeHorizontal = 'overlay' | 'fullOverlay';\ntype OnCloseDetail = {\n  reason: 'outsideClick' | 'escapeKey' | 'swipe';\n};\n\ntype Props = IntrinsicProps &\n  Pick<ColorProps, 'backgroundColor'> & {\n    /**\n     * Specifies whether the Drawer is open.\n     */\n    isOpen: boolean;\n    /**\n     * Specifies at what edge the Drawer opens.\n     * Supported values are:\n     * <p><code>start</code>, <code>end</code>, <code>bottom</code></p>\n     * Default is <code>start</code>.\n     */\n    placement?: Placement;\n    /**\n     * Specifies modality of the Darwer.\n     * Supported values are:\n     * <p><code>modal</code>, <code>modeless</code></p>\n     * Default is <code>modal</code>.\n     */\n    modality?: 'modal' | 'modeless';\n    /**\n     * Specifies callback triggered when a user tries to close a Drawer through UI interaction.\n     * The parent should listen to this event and close the Drawer. If the parent fails to remove\n     * the Popup, then no change will be done in the UI by the component.\n     * Supported detail values are:\n     * <p><code>outsideClick</code>, <code>escapeKey</code></p>, <code>swipe</code>\n     */\n    onClose?: (detail: OnCloseDetail) => void;\n    /**\n     * Specifies callback triggered after the animation ends.\n     */\n    onTransitionEnd?: (value: boolean) => void;\n    /**\n     * Optional ref for an element to focus on when component mounts.\n     */\n    autoFocusRef?: RefObject<HTMLElement>;\n    /**\n     * Specifies guidance for screen readers.\n     */\n    'aria-label'?: string;\n    /**\n     * Specifies ID of an element used for guidance for screen readers.\n     */\n    'aria-labelledby'?: string;\n    /**\n     * Specifies ID of an element (or space separated IDs of multiple elements) that\n     * describes the Drawer.\n     */\n    'aria-describedby'?: string;\n  } & TestIdProps;\n\n// Constants\nconst displayModefullWidthThreshold = 600;\nconst zero = '0px';\nconst duration = 250;\n\nconst getElementHeight = (element: HTMLDivElement): number => {\n  return Math.round(element.offsetHeight);\n};\n\nconst getElementWidth = (element: HTMLDivElement): number => {\n  return Math.round(element.getBoundingClientRect().width);\n};\n\n/**\n * A drawer popup adds a single slide-in side content alongside some primary content to an application window.\n *\n * This drawer always overlays the page and can be placed at the 'start', 'end' or 'bottom' edge.\n */\nexport const DrawerPopup = ({\n  children,\n  isOpen = false,\n  autoFocusRef,\n  placement = 'start',\n  modality = 'modal',\n  onClose,\n  onTransitionEnd,\n  'aria-label': ariaLabel,\n  'aria-labelledby': ariaLabelledBy,\n  'aria-describedby': ariaDescribedBy,\n  testId,\n  ...props\n}: Props) => {\n  // Initialize states\n  const [status, setStatus] = useState<Status>(isOpen ? 'initial' : 'unmounted');\n  const [visibility, setVisibility] = useState<VisibilityStatus>('hidden');\n  const [isOutsideClickDisabled, setIsOutsideClickDisabled] = useState<boolean>(!isOpen);\n  const [displayModeHorizontal, setDisplayModeHorizontal] =\n    useState<DisplayModeHorizontal>('overlay');\n\n  const rootRef = useRef<HTMLDivElement>(null);\n  const launcherRef = useRef<HTMLElement | null>(null);\n\n  const isBottomPlacement = placement === 'bottom';\n\n  // Animation config\n  const animationStates = {\n    opening: () => {\n      if (isBottomPlacement) {\n        return {\n          from: {\n            translateY: getTranslateY()\n          },\n          to: {\n            translateY: zero\n          },\n          options: {\n            duration: duration\n          }\n        };\n      } else {\n        return {\n          from: {\n            translateX: getTranslateX()\n          },\n          to: {\n            translateX: zero\n          },\n          options: {\n            duration: duration\n          }\n        };\n      }\n    },\n    closing: () => {\n      if (isBottomPlacement) {\n        return {\n          from: {\n            translateY: zero\n          },\n          to: {\n            translateY: getTranslateY()\n          },\n          options: {\n            duration: duration\n          }\n        };\n      } else {\n        return {\n          from: {\n            translateX: zero\n          },\n          to: {\n            translateX: getTranslateX()\n          },\n          options: {\n            duration: duration\n          }\n        };\n      }\n    }\n  };\n\n  // testId support\n  const testIdProps = useTestId(testId);\n\n  // Normalizing position\n  const { direction } = useUser();\n  const getNormalizedPlacement = (): RtlSide => {\n    return normalizePosition(placement, direction);\n  };\n\n  const getTranslateX = (): string => {\n    return `${getNormalizedPlacement() === 'right' ? '' : '-'}${getElementWidth(\n      rootRef.current as HTMLDivElement\n    )}px`;\n  };\n\n  const getTranslateY = (): string => {\n    return `${getElementHeight(rootRef.current as HTMLDivElement)}px`;\n  };\n\n  const handleFocus = () => {\n    // Set focus to the first match:\n    // 1. First element inside the drawer matching [autofocus]\n    const autofocusItems: HTMLElement[] = getAutofocusFocusables(rootRef.current as HTMLElement);\n    if (autofocusItems.length > 0) {\n      focusOn(autofocusItems[0]);\n      return;\n    }\n    // 2. Tabbable element inside the content element\n    // 3. The drawer itself\n    focusWithin(rootRef.current as HTMLElement);\n  };\n\n  // Animation\n  const { nodeRef } = useAnimation<Status, HTMLDivElement>(status, {\n    animationStates,\n    isAnimatedOnMount: true,\n    onAnimationEnd: () => {\n      if (status === 'opening') {\n        handleFocus();\n        onTransitionEnd?.(true);\n      } else if (!isOpen) {\n        nodeRef(null);\n        setVisibility('hidden');\n        setStatus('unmounted');\n        onTransitionEnd?.(false);\n      }\n    }\n  });\n\n  useEffect(() => {\n    // 1. Ignore status update on initial render\n    if (status === 'unmounted' && !isOpen) {\n      return;\n    }\n\n    // 2. Mount visually hidden component\n    // Component gets mounted, but will be visually hidden to avoid flickering\n    // Flickering happens because it gets rendered before animation hook repositions\n    // it in next render cycle\n    if (status === 'unmounted' && isOpen) {\n      setStatus('initial');\n      return;\n    }\n\n    // 3. Setup animation\n    // Component has been mounted.\n    // We will kick out animation as node is already present in DOM.\n    // To avoid flickering, we still keep it visually hidden until the next render cycle.\n    if (status === 'initial' && isOpen) {\n      nodeRef(rootRef.current);\n      setIsOutsideClickDisabled(false);\n      setStatus('opening');\n      return;\n    }\n\n    // 3. Unhide component. It becomes visible.\n    if (status === 'opening' && isOpen) {\n      setVisibility('visible');\n      return;\n    }\n\n    // 4. Closing\n    if (!isOpen) {\n      setIsOutsideClickDisabled(true);\n      setStatus('closing');\n    }\n  }, [isOpen, status, nodeRef]);\n\n  // Launcher handler\n  useEffect(() => {\n    if (modality === 'modeless') {\n      if (status === 'opening') {\n        // Remember launcher\n        launcherRef.current = getActiveElement() as HTMLElement;\n\n        // Register F6 key handler to enter the Popup\n        launcherRef.current?.addEventListener('keydown', launcherKeyDownCallback);\n      }\n      if (status === 'closing') {\n        return () => {\n          // Deregister F6 key handler\n          launcherRef.current?.removeEventListener('keydown', launcherKeyDownCallback);\n        };\n      }\n    }\n    return;\n  }, [modality, status]);\n\n  const launcherKeyDownCallback = (event: KeyboardEvent): void => {\n    // Moves focus from launcher (must have focus) back to the Drawer\n    if (launcherRef.current === getActiveElement() && event.code === 'F6') {\n      // Prevent default F6 handlers.\n      // F6 is a standard Chrome address bar shortcut on Windows.\n      event.preventDefault();\n      event.stopPropagation();\n\n      // Focus on first tabbable in a container or container itself if there is none\n      focusWithin(rootRef.current as HTMLElement);\n    }\n  };\n\n  const handleKeyDown = useCallback(\n    (event: KeyboardEvent) => {\n      const launcherEl = launcherRef.current;\n      switch (event.code) {\n        case 'Escape': {\n          onClose?.({ reason: 'escapeKey' });\n          break;\n        }\n        case 'F6':\n          if (modality === 'modeless') {\n            // Prevent default F6 handlers.\n            // F6 is a standard Chrome address bar shortcut on Windows.\n            event.preventDefault();\n            event.stopPropagation();\n            // Focus launcher\n            if (launcherEl) {\n              focusOn(launcherEl);\n            }\n            break;\n          }\n      }\n    },\n    [onClose]\n  );\n\n  // OutsideClick handler\n  const handleOutsideClick = useCallback(() => {\n    // Trigger onClose event with outside click detail\n    onClose?.({ reason: 'outsideClick' });\n  }, [onClose]);\n\n  useOutsideClick({\n    isDisabled: isOutsideClickDisabled,\n    ref: rootRef,\n    handler: handleOutsideClick\n  });\n\n  // Drawer placement\n  const getDrawerPlacement = (): NormalizedPlacement => {\n    if (isBottomPlacement) {\n      return placement;\n    } else {\n      if (direction === 'rtl') {\n        return placement === 'start' ? 'right' : 'left';\n      } else {\n        return placement === 'start' ? 'left' : 'right';\n      }\n    }\n  };\n\n  const clientHints = getClientHints();\n\n  const getViewportWidth = useCallback((): number => {\n    if (clientHints.platform === 'ios') {\n      // On ios window.innerWidth is not recommended way of measuring the viewport\n      return document.documentElement.clientWidth;\n    }\n    return window.innerWidth;\n  }, [clientHints.platform]);\n\n  // Window resize handler\n  // Handles display mode: Overlay <> Full overlay (full width side drawers)\n  const handleResize = useCallback(() => {\n    const viewportWidth = getViewportWidth();\n    if (displayModeHorizontal === 'overlay' && viewportWidth < displayModefullWidthThreshold) {\n      setDisplayModeHorizontal('fullOverlay');\n    }\n    if (displayModeHorizontal === 'fullOverlay' && viewportWidth > displayModefullWidthThreshold) {\n      setDisplayModeHorizontal('overlay');\n    }\n  }, [getViewportWidth, displayModeHorizontal]);\n\n  useEffect(() => {\n    const root = rootRef.current;\n    if (root && status === 'opening') {\n      const resizeObserver = new ResizeObserver(() => {\n        handleResize();\n      });\n      resizeObserver.observe(document.body);\n      return () => {\n        resizeObserver.unobserve(document.body);\n      };\n    }\n    return undefined;\n  }, [status, handleResize]);\n\n  // OutsideClick handler\n  const swipeHandler = useCallback(\n    (event: any): void => {\n      const swipeDir = event.direction;\n      if (\n        (direction === 'ltr' && placement === 'start' && swipeDir === 'left') ||\n        (placement === 'end' && swipeDir === 'right') ||\n        (direction === 'rtl' && placement === 'start' && swipeDir === 'right') ||\n        (placement === 'end' && swipeDir === 'left') ||\n        (placement === 'bottom' && swipeDir === 'down')\n      ) {\n        onClose?.({ reason: 'swipe' });\n      }\n    },\n    [direction, placement, onClose]\n  );\n\n  const swipeOptions = {\n    threshold: 50,\n    maximumTime: 750,\n    tolerance: 40\n  };\n  const { swipeProps } = useSwipe(swipeHandler, swipeOptions);\n\n  // Styles\n  const { classes } = useComponentTheme<DrawerPopupVariantOptions>(DrawerPopupRedwoodTheme, {\n    placement: getDrawerPlacement(),\n    visibility,\n    displayModeHorizontal:\n      ['start', 'end'].indexOf(placement) > -1 ? displayModeHorizontal : undefined\n  });\n\n  const interpolations = [...Object.values(colorInterpolations)];\n  const styleInterpolations = mergeInterpolations<ColorProps>(interpolations);\n  const { ...styles } = styleInterpolations(props);\n\n  const renderDrawer = () => {\n    return (\n      <div\n        ref={rootRef}\n        className={classes}\n        style={styles}\n        tabIndex={-1}\n        role=\"dialog\"\n        onKeyDown={handleKeyDown}\n        aria-label={ariaLabel}\n        aria-labelledby={ariaLabelledBy}\n        aria-describedby={ariaDescribedBy}\n        {...swipeProps}\n        {...testIdProps}>\n        <FocusTrap autoFocusRef={autoFocusRef}>{children}</FocusTrap>\n      </div>\n    );\n  };\n\n  const isMounted = status !== 'unmounted';\n  if (isMounted) {\n    // Modal vs. modelss upper wrapper\n    if (modality === 'modal') {\n      return <Modal isOpen={isMounted}>{renderDrawer()}</Modal>;\n    } else {\n      return <Layer>{renderDrawer()}</Layer>;\n    }\n  }\n\n  return null;\n};\n"],"names":["zero","duration","children","isOpen","autoFocusRef","placement","modality","onClose","onTransitionEnd","ariaLabel","ariaLabelledBy","ariaDescribedBy","testId","props","status","setStatus","useState","visibility","setVisibility","isOutsideClickDisabled","setIsOutsideClickDisabled","displayModeHorizontal","setDisplayModeHorizontal","rootRef","useRef","launcherRef","isBottomPlacement","animationStates","opening","from","translateY","getTranslateY","to","options","translateX","getTranslateX","closing","testIdProps","useTestId","direction","useUser","normalizePosition","element","current","Math","round","getBoundingClientRect","width","offsetHeight","nodeRef","useAnimation","isAnimatedOnMount","onAnimationEnd","autofocusItems","getAutofocusFocusables","length","focusOn","focusWithin","handleFocus","useEffect","getActiveElement","addEventListener","launcherKeyDownCallback","removeEventListener","event","code","preventDefault","stopPropagation","handleKeyDown","useCallback","launcherEl","reason","handleOutsideClick","useOutsideClick","isDisabled","ref","handler","clientHints","getClientHints","getViewportWidth","platform","document","documentElement","clientWidth","window","innerWidth","handleResize","viewportWidth","resizeObserver","ResizeObserver","observe","body","unobserve","swipeHandler","swipeDir","swipeProps","useSwipe","threshold","maximumTime","tolerance","classes","useComponentTheme","DrawerPopupRedwoodTheme","indexOf","undefined","interpolations","Object","values","colorInterpolations","styleInterpolations","mergeInterpolations","styles","renderDrawer","_jsx","className","style","tabIndex","role","onKeyDown","FocusTrap","isMounted","jsx","Modal","Layer"],"mappings":"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"}