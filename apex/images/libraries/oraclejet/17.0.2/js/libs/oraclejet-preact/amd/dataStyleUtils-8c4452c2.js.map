{"version":3,"file":"dataStyleUtils-8c4452c2.js","sources":["../../src/utils/PRIVATE_chartUtils/navUtils.ts","../../src/utils/PRIVATE_chartUtils/utils.ts","../../src/utils/PRIVATE_visSVGUtils/areaUtils.ts","../../src/utils/PRIVATE_chartUtils/accUtils.ts","../../src/utils/PRIVATE_chartUtils/dataStyleUtils.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { ChartItemData, ItemInfo, Info } from '../UNSAFE_visTypes/chart';\ntype isItemNavigableType = (seriesIndex: number, groupIndex: number) => boolean;\n\n/**\n * Returns the next navigable item in the same series.\n * @param seriesIndex\n * @param groupIndex\n * @param numOfGroups\n * @returns\n */\nexport function getNextItemInSeries(\n  info: ItemInfo,\n  viewportEndIndex: number,\n  isNavigable: isItemNavigableType\n): ItemInfo | undefined {\n  const { seriesIndex, groupIndex } = info;\n  const nextGroupIndex = groupIndex + 1;\n\n  if (nextGroupIndex > viewportEndIndex) {\n    return;\n  }\n\n  if (isNavigable(seriesIndex, nextGroupIndex)) {\n    return { seriesIndex, groupIndex: nextGroupIndex };\n  }\n\n  return getNextItemInSeries(\n    {\n      seriesIndex,\n      groupIndex: nextGroupIndex\n    },\n    viewportEndIndex,\n    isNavigable\n  );\n}\n\n/**\n * Returns the previous navigable item in the same series.\n * @param seriesIndex\n * @param itemIndex\n * @returns\n */\nexport function getPrevItemInSeries(\n  info: ItemInfo,\n  viewportStartIndex: number,\n  isNavigable: isItemNavigableType\n): ItemInfo | undefined {\n  const { seriesIndex, groupIndex } = info;\n  const prevGroupIndex = groupIndex - 1;\n\n  if (prevGroupIndex < viewportStartIndex) {\n    return;\n  }\n\n  if (isNavigable(seriesIndex, prevGroupIndex)) {\n    return { seriesIndex, groupIndex: prevGroupIndex };\n  }\n  if (prevGroupIndex === 0) {\n    return undefined;\n  }\n  return getPrevItemInSeries(\n    { seriesIndex, groupIndex: prevGroupIndex },\n    viewportStartIndex,\n    isNavigable\n  );\n}\n\n/**\n * Returns the previous navigable item in the same group.\n * @param seriesIndex\n * @param groupIndex\n * @param isNavigable\n */\nexport function getPrevItemInGroup(\n  info: ItemInfo,\n  isNavigable: isItemNavigableType\n): ItemInfo | undefined {\n  const { seriesIndex, groupIndex } = info;\n  const prevSeriesIndex = seriesIndex - 1;\n  if (prevSeriesIndex < 0) {\n    return;\n  }\n\n  if (isNavigable(prevSeriesIndex, groupIndex)) {\n    return { seriesIndex: prevSeriesIndex, groupIndex };\n  }\n\n  return getPrevItemInGroup(\n    {\n      seriesIndex: prevSeriesIndex,\n      groupIndex\n    },\n    isNavigable\n  );\n}\n\n/**\n * Returns the next navigable item in the same group.\n * @param seriesIndex\n * @param groupIndex\n * @param numOfSeries\n * @param numOfGroups\n */\nexport function getNextItemInGroup(\n  info: ItemInfo,\n  numOfSeries: number,\n  isNavigable: isItemNavigableType\n): ItemInfo | undefined {\n  const { seriesIndex, groupIndex } = info;\n  const nextSeriesIndex = seriesIndex + 1;\n\n  if (nextSeriesIndex >= numOfSeries) {\n    return;\n  }\n\n  if (isNavigable(nextSeriesIndex, groupIndex)) {\n    return { seriesIndex: nextSeriesIndex, groupIndex };\n  }\n\n  return getNextItemInGroup(\n    {\n      seriesIndex: nextSeriesIndex,\n      groupIndex\n    },\n    numOfSeries,\n    isNavigable\n  );\n}\n\n/**\n * Returns the next item in the group with higher value than the current item.\n * @param info The ItemInfo of current item.\n * @param numSeries The number of series in the group.\n * @param getDataItem The function that returns the chart data item.\n * @returns\n */\nexport function getNextHigherItemInGroup<K extends string | number, D extends ChartItemData<K>>(\n  info: ItemInfo,\n  numSeries: number,\n  getDataItem: (seriesIndex: number, groupIndex: number) => D | undefined,\n  isItemNavigable: isItemNavigableType\n) {\n  const { groupIndex, seriesIndex } = info;\n  const item = getDataItem(seriesIndex, groupIndex);\n  if (!item) {\n    return info;\n  }\n\n  let minValue = Number.MAX_VALUE;\n  let minIndex = seriesIndex;\n\n  for (let i = 0; i < numSeries; i++) {\n    const itemValue = getDataItem(i, groupIndex)?.value;\n    if (\n      !itemValue ||\n      itemValue < item.value ||\n      !isItemNavigable(i, groupIndex) ||\n      seriesIndex === i\n    ) {\n      continue;\n    }\n    if (itemValue < minValue) {\n      minValue = itemValue;\n      minIndex = i;\n    }\n  }\n  return { seriesIndex: minIndex, groupIndex };\n}\n\n/**\n * Returns the item info of the item in the group with lower value than the current item.\n * @param info The ItemInfo of the current item.\n * @param numSeries The number of series in the group.\n * @param getDataItem The function that returns the chart data item.\n * @returns\n */\nexport function getNextLowerItemInGroup<K extends string | number, D extends ChartItemData<K>>(\n  info: ItemInfo,\n  numSeries: number,\n  getDataItem: (seriesIndex: number, groupIndex: number) => D | undefined,\n  isItemNavigable: isItemNavigableType\n) {\n  const { groupIndex, seriesIndex } = info;\n  const item = getDataItem(seriesIndex, groupIndex);\n  if (!item) {\n    return info;\n  }\n\n  let maxValue = Number.MIN_VALUE;\n  let maxIndex = seriesIndex;\n\n  for (let i = 0; i < numSeries; i++) {\n    const itemValue = getDataItem(i, groupIndex)?.value;\n    if (\n      !itemValue ||\n      itemValue > item.value ||\n      !isItemNavigable(i, groupIndex) ||\n      seriesIndex === i\n    ) {\n      continue;\n    }\n\n    if (itemValue > maxValue) {\n      maxValue = itemValue;\n      maxIndex = i;\n    }\n  }\n  return { seriesIndex: maxIndex, groupIndex };\n}\n\nexport function getLineAreaChartNavUtil<K extends string | number, D extends ChartItemData<K>>(\n  getDataItem: (seriesIndex: number, groupIndex: number) => D | undefined,\n  numSeries: number,\n  viewportStartIndex: number,\n  viewportEndIndex: number,\n  isStacked: boolean,\n  isRtl: boolean,\n  isHoriz: boolean\n) {\n  const isItemNavigable = (seriesIndex: number, groupIndex: number) => {\n    const barItem = getDataItem(seriesIndex, groupIndex);\n    return Boolean(barItem);\n  };\n\n  const getNextChartItem = (\n    itemInfo: Info,\n    arrow: 'ArrowLeft' | 'ArrowRight' | 'ArrowDown' | 'ArrowUp'\n  ): Info => {\n    let newInfo: Info | undefined;\n\n    const info = {\n      groupIndex: itemInfo.groupIndex!,\n      seriesIndex: itemInfo.seriesIndex!\n    };\n\n    if (info.groupIndex < viewportStartIndex) {\n      info.groupIndex = viewportStartIndex;\n      return info;\n    } else if (info.groupIndex > viewportEndIndex) {\n      info.groupIndex = viewportEndIndex;\n      return info;\n    }\n\n    if (arrow === 'ArrowLeft') {\n      if (!isHoriz) {\n        newInfo = isRtl\n          ? getNextItemInSeries(info, viewportEndIndex, isItemNavigable)\n          : getPrevItemInSeries(info, viewportStartIndex, isItemNavigable);\n      } else {\n        newInfo = isRtl\n          ? getNextHigherItemInGroup<K, D>(info, numSeries, getDataItem, isItemNavigable)\n          : getNextLowerItemInGroup<K, D>(info, numSeries, getDataItem, isItemNavigable);\n      }\n    } else if (arrow === 'ArrowRight') {\n      if (!isHoriz) {\n        newInfo = isRtl\n          ? getPrevItemInSeries(info, viewportStartIndex, isItemNavigable)\n          : getNextItemInSeries(info, viewportEndIndex, isItemNavigable);\n      } else {\n        newInfo = !isRtl\n          ? getNextHigherItemInGroup<K, D>(info, numSeries, getDataItem, isItemNavigable)\n          : getNextLowerItemInGroup<K, D>(info, numSeries, getDataItem, isItemNavigable);\n      }\n    } else if (arrow === 'ArrowDown') {\n      if (isHoriz) {\n        newInfo = getNextItemInSeries(info, viewportEndIndex, isItemNavigable);\n      } else {\n        if (isStacked) {\n          newInfo = getPrevItemInGroup(info, isItemNavigable);\n        } else {\n          newInfo = getNextLowerItemInGroup<K, D>(info, numSeries, getDataItem, isItemNavigable);\n        }\n      }\n    } else {\n      if (isHoriz) {\n        newInfo = getPrevItemInSeries(info, viewportStartIndex, isItemNavigable);\n      } else {\n        if (isStacked) {\n          newInfo = getNextItemInGroup(info, numSeries, isItemNavigable);\n        } else {\n          newInfo = getNextHigherItemInGroup<K, D>(info, numSeries, getDataItem, isItemNavigable);\n        }\n      }\n    }\n    return newInfo || info;\n  };\n\n  return getNextChartItem;\n}\n","/**\n * @license\n * Copyright (c) 2008 %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { MarkerShapes } from '../UNSAFE_visTypes/common';\nimport { Point } from '../PRIVATE_visSVGUtils';\nimport { curveThroughPoints } from '../PRIVATE_visSVGUtils/pathUtils';\nimport { Scale, ChartItemData, Group } from '../UNSAFE_visTypes/chart';\nimport { ColorProps } from '../UNSAFE_interpolations/colors';\nimport { colorSchemeVars } from '../../Common/themes/themeContract.css';\nimport { rgb, rgba } from '../../UNSAFE_Theme';\nimport { getStraightAreaPath, getCurveAreaPath } from '../PRIVATE_visSVGUtils/areaUtils';\nimport { getGroupCenterCoord } from '../../utils/PRIVATE_chartUtils/layoutUtils';\nimport { LineAreaItem } from '../../UNSAFE_LineAreaChart/lineAreaChart.types';\n\nexport function getCmdsForArea(\n  lineSegmentCoords: Point[],\n  bottomCoords: Point[],\n  areaType: 'straight' | 'curved',\n  isHoriz: boolean,\n  isBottomSegmentCurved: boolean\n) {\n  if (areaType === 'straight') {\n    return getStraightAreaPath(lineSegmentCoords, bottomCoords);\n  }\n  return getCurveAreaPath(\n    lineSegmentCoords,\n    bottomCoords,\n    false,\n    isHoriz ? 'mh' : 'mv',\n    isBottomSegmentCurved\n  );\n}\n\nexport function getCmdsForLine(\n  lineSegmentCoords: Point[],\n  lineType: 'straight' | 'curved',\n  isHoriz: boolean\n) {\n  if (lineType === 'straight') {\n    return lineSegmentCoords.join(' ');\n  }\n  return curveThroughPoints(lineSegmentCoords, false, isHoriz ? 'mh' : 'mv');\n}\n/**\n * Returns the cumulative series for stacked chart.\n */\nexport function getCumulativeSeries<K extends string | number, D extends ChartItemData<K>>(\n  numSeries: number,\n  numGroups: number,\n  getDataItem: (seriesIndex: number, groupIndex: number) => D | undefined,\n  hiddenIds: Set<number | string>,\n  isLog: boolean\n) {\n  const series: number[][] = [];\n  for (let seriesIndex = 0; seriesIndex < numSeries; seriesIndex += 1) {\n    const currentSeries: number[] = [];\n    const prevSeries = series[seriesIndex - 1];\n    for (let groupIndex = 0; groupIndex < numGroups; groupIndex += 1) {\n      const item = getDataItem(seriesIndex, groupIndex);\n      if (!item || hiddenIds?.has(item.id) || (isLog && item.value <= 0)) {\n        continue;\n      }\n      if (seriesIndex) {\n        currentSeries[groupIndex] = item.value + prevSeries[groupIndex];\n      } else {\n        currentSeries[groupIndex] = item.value;\n      }\n    }\n    series.push(currentSeries);\n  }\n  return series;\n}\n\n/**\n * Returns the series data.\n */\nexport function getSeriesData<K extends string | number, D extends ChartItemData<K>>(\n  numSeries: number,\n  numGroups: number,\n  getDataItem: (seriesIndex: number, groupIndex: number) => D | undefined,\n  hiddenIds: Set<number | string>,\n  isLog: boolean\n) {\n  const series: number[][] = [];\n  for (let seriesIndex = 0; seriesIndex < numSeries; seriesIndex += 1) {\n    const currentSeries: number[] = [];\n    for (let groupIndex = 0; groupIndex < numGroups; groupIndex += 1) {\n      const item = getDataItem(seriesIndex, groupIndex);\n      if (!item || hiddenIds?.has(item.id) || (isLog && item.value <= 0)) {\n        continue;\n      }\n      currentSeries[groupIndex] = item.value;\n    }\n    series.push(currentSeries);\n  }\n  return series;\n}\n\n/**\n * Returns the markertype order.\n */\nexport function getMarkers(): MarkerShapes[] {\n  return ['square', 'circle', 'diamond', 'plus', 'triangleDown', 'triangleUp'];\n}\n\n/**\n * Returns the marker fill and stroke depending on the state.\n */\nexport function getMarkerFillAndStroke( // TODO : JET-62244 - Replace getMarkerFillAndStroke function with classes.\n  isMarkerDisplayed: boolean,\n  isSelectionEnabled: boolean,\n  isHovered: boolean,\n  isFocused: boolean,\n  isSelected: boolean,\n  seriesColor: ColorProps['color'],\n  itemColor?: ColorProps['color']\n) {\n  let fill;\n  let stroke;\n  let outerStroke;\n\n  if (isSelectionEnabled) {\n    if (isSelected) {\n      if (isMarkerDisplayed) {\n        // TODO: settle on one visual for selected markers: \n        // Selected effect when markers are turned on\n        fill = itemColor || seriesColor;\n        outerStroke = rgb(colorSchemeVars.palette.neutral[130]);\n        stroke = rgb(colorSchemeVars.palette.neutral[0]);\n      } else {\n        // Selected effect when markers are not turned on\n        fill = rgb(colorSchemeVars.palette.neutral[0]);\n        if (isHovered || isFocused) {\n          stroke = itemColor || seriesColor;\n        } else {\n          stroke = rgb(colorSchemeVars.palette.neutral[130]);\n        }\n      }\n    } else if (isHovered || isFocused) {\n      stroke = itemColor || seriesColor;\n      fill = rgb(colorSchemeVars.palette.neutral[0]);\n    } else {\n      if (isMarkerDisplayed) {\n        fill = itemColor || seriesColor;\n        stroke = rgb(colorSchemeVars.palette.neutral[0]);\n      } else {\n        fill = rgba(colorSchemeVars.palette.neutral[0], 0);\n        stroke = rgba(colorSchemeVars.palette.neutral[0], 0);\n      }\n    }\n  } else if (isMarkerDisplayed) {\n    fill = itemColor || seriesColor;\n    stroke = rgb(colorSchemeVars.palette.neutral[0]);\n  } else {\n    stroke = isFocused ? itemColor || seriesColor : rgba(colorSchemeVars.palette.neutral[0], 0);\n    fill = rgba(colorSchemeVars.palette.neutral[0], 0);\n  }\n  return { fill, stroke, outerStroke };\n}\n\n/**\n * Returns the coordinates of line or area based on orientation and size of the chart.\n */\nexport function getLineAreaSegments<K extends string | number, D extends LineAreaItem<K>>(\n  yScale: Scale,\n  xScale: Scale,\n  data: number[],\n  startIndex: number,\n  endIndex: number,\n  isHorizontal: boolean,\n  isLog: boolean,\n  groups: Group[],\n  seriesIndex: number,\n  getDataItem: (seriesIndex: number, groupIndex: number) => D | undefined,\n  timeAxisType?: 'enabled' | 'skipGaps' | 'mixedFrequency'\n): Point[][] {\n  const segments: Point[][] = [];\n  let currentPath: Point[] = [];\n\n  for (let groupIndex = startIndex; groupIndex < endIndex + 1; groupIndex += 1) {\n    const item = data[groupIndex];\n\n    if (item == null || (isLog && item <= 0)) {\n      segments.push(currentPath);\n      currentPath = [];\n      continue;\n    }\n    const x = isHorizontal\n      ? yScale.transform(item)\n      : getGroupCenterCoord<K, D>(\n          groups[groupIndex],\n          groupIndex,\n          xScale,\n          getDataItem(seriesIndex, groupIndex)!,\n          timeAxisType\n        );\n    const y = isHorizontal\n      ? getGroupCenterCoord<K, D>(\n          groups[groupIndex],\n          groupIndex,\n          xScale,\n          getDataItem(seriesIndex, groupIndex)!,\n          timeAxisType\n        )\n      : yScale.transform(item);\n    currentPath.push([x, y]);\n    if (groupIndex === endIndex) {\n      segments.push(currentPath);\n    }\n  }\n  return segments;\n}\n","/**\n * @license\n * Copyright (c) 2008 %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { Point } from './lineUtils';\nimport { curveThroughPoints } from './pathUtils';\n\n/**\n * Returns a straight area path command.\n * @param {array} lineSegmentCoords Polyline top points array.\n * @param {array} bottomCoords Polyline bottom points array.\n * @return {string} Straight area path commands.\n */\nexport function getStraightAreaPath(lineSegmentCoords: Point[], bottomCoords: Point[]) {\n  // Create the path data string\n  let pathData;\n  if (lineSegmentCoords.length > 0) {\n    pathData =\n      lineSegmentCoords\n        .map((lineSegmentCoord, index) => {\n          return `${index === 0 ? 'M' : 'L'} ${lineSegmentCoord[0]} ${lineSegmentCoord[1]}`;\n        })\n        .join(' ') +\n      [...bottomCoords]\n        .reverse()\n        .map((bottomCoord) => {\n          return `L ${bottomCoord[0]} ${bottomCoord[1]}`;\n        })\n        .join(' ') +\n      'Z';\n  }\n  return pathData;\n}\n\n/**\n * Returns a curved area path command, based on cubic hermite splines, that goes through the points in the points array.\n * @param {array} lineSegmentCoords Polyline top points array.\n * @param {array} bottomCoords Polyline bottom points array.\n * @param {boolean} connectWithLine Whether the first point is reached using lineTo. Otherwise, moveTo is used.\n * @param {string} splineType The spline type.\n * @return {string} Curved area path commands.\n */\nexport function getCurveAreaPath(\n  lineSegmentCoords: Point[],\n  bottomCoords: Point[],\n  connectWithLine: boolean,\n  splineType: string,\n  isBottomSegmentCurved?: boolean\n) {\n  let pathData;\n  if (lineSegmentCoords.length > 0) {\n    if (!isBottomSegmentCurved) {\n      pathData =\n        curveThroughPoints(lineSegmentCoords, connectWithLine, splineType) +\n        [...bottomCoords]\n          .reverse()\n          .map((bottomCoord) => {\n            return `L ${bottomCoord[0]} ${bottomCoord[1]}`;\n          })\n          .join(' ') +\n        'Z';\n    } else {\n      pathData =\n        curveThroughPoints(lineSegmentCoords, false, splineType) +\n        ' ' +\n        curveThroughPoints([...bottomCoords].reverse(), true, splineType) +\n        ' Z';\n    }\n  }\n  return pathData;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { generateAriaLabel } from '#utils/UNSAFE_visUtils/accUtils';\nimport { BundleType } from '../../resources/nls/bundle';\n\n/**\n * Returns the aria label for the chart item\n * @param translations The translations bundle.\n * @param series The series of the item.\n * @param group The group of the item.\n * @param value The value of the item.\n * @param isSelected Whether the item is selected.\n * @param isDrillable Whether the item is drillable.\n * @param accessibleLabel The accessible label of the item.\n * @returns\n */\nexport function getItemAriaLabel(\n  translations: BundleType,\n  series: string,\n  group: string,\n  value: number,\n  isSelectionEnabled: boolean,\n  isSelected: boolean,\n  isDrillable: boolean,\n  accessibleLabel?: string\n) {\n  const seriesLabel = translations.chart_labelSeries();\n  const groupLabel = translations.chart_labelGroup();\n  const valueLabel = translations.chart_labelValue();\n\n  const label =\n    accessibleLabel ||\n    `${seriesLabel}: ${series}, ${groupLabel}: ${group}, ${valueLabel}: ${value}`;\n\n  return generateAriaLabel(translations, label, {\n    isSelected: !isSelectionEnabled ? undefined : isSelected,\n    isDrillable\n  });\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { getColorRamp } from '../../utils/UNSAFE_visUtils';\nimport { BarItemData, BarSeriesData } from '../../UNSAFE_BarChart/barChart.types';\nimport { LineAreaItem, LineAreaSeriesData } from '../../UNSAFE_LineAreaChart/lineAreaChart.types';\nimport { getMarkers } from './utils';\n\nexport function getItemColor<K, D>(\n  seriesIndex: number,\n  groupIndex: number,\n  series: (LineAreaSeriesData<K, D> | BarSeriesData<K, D>)[],\n  getDataItem: (\n    seriesIndex: number,\n    groupIndex: number\n  ) => LineAreaItem<K> | BarItemData<K> | undefined\n) {\n  const item = getDataItem(seriesIndex, groupIndex);\n  if (item?.color) {\n    return item.color;\n  }\n\n  if ((item as LineAreaItem<K>).markerColor) {\n    return (item as LineAreaItem<K>).markerColor;\n  }\n  const itemSeries = series[seriesIndex] as LineAreaSeriesData<K, D>;\n\n  const colors = getColorRamp();\n  return (\n    itemSeries.color ||\n    itemSeries.lineColor ||\n    itemSeries.areaColor ||\n    colors[seriesIndex % colors.length]\n  );\n}\n\nexport function getMarkerType<K>(\n  seriesIndex: number,\n  groupIndex: number,\n  chartType: 'bar' | 'lineWithArea',\n  getDataItem: (\n    seriesIndex: number,\n    groupIndex: number\n  ) => LineAreaItem<K> | BarItemData<K> | undefined\n) {\n  if (chartType === 'bar') {\n    return 'circle';\n  }\n  const item = getDataItem(seriesIndex, groupIndex);\n  if ((item as LineAreaItem<K>).markerType) {\n    return (item as LineAreaItem<K>).markerType;\n  }\n  const shapes = getMarkers();\n  return shapes[seriesIndex % shapes.length];\n}\n"],"names":["getNextItemInSeries","info","viewportEndIndex","isNavigable","seriesIndex","groupIndex","nextGroupIndex","getPrevItemInSeries","viewportStartIndex","prevGroupIndex","getPrevItemInGroup","prevSeriesIndex","getNextItemInGroup","numOfSeries","nextSeriesIndex","getNextHigherItemInGroup","numSeries","getDataItem","isItemNavigable","item","minValue","Number","MAX_VALUE","minIndex","i","itemValue","value","getNextLowerItemInGroup","maxValue","MIN_VALUE","maxIndex","getMarkers","lineSegmentCoords","bottomCoords","areaType","isHoriz","isBottomSegmentCurved","pathData","length","map","lineSegmentCoord","index","join","reverse","bottomCoord","getStraightAreaPath","connectWithLine","splineType","curveThroughPoints","getCurveAreaPath","lineType","numGroups","hiddenIds","isLog","series","currentSeries","prevSeries","has","id","push","translations","group","isSelectionEnabled","isSelected","isDrillable","accessibleLabel","seriesLabel","chart_labelSeries","groupLabel","chart_labelGroup","valueLabel","chart_labelValue","label","generateAriaLabel","undefined","color","markerColor","itemSeries","colors","getColorRamp","lineColor","areaColor","isStacked","isRtl","barItem","Boolean","itemInfo","arrow","newInfo","yScale","xScale","data","startIndex","endIndex","isHorizontal","groups","timeAxisType","segments","currentPath","x","transform","getGroupCenterCoord","y","isMarkerDisplayed","isHovered","isFocused","seriesColor","itemColor","fill","stroke","outerStroke","rgb","colorSchemeVars","palette","neutral","rgba","chartType","markerType","shapes"],"mappings":"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"}