{"version":3,"file":"MeterCircle-f1561632.js","sources":["../../src/UNSAFE_MeterCircle/CircularReferenceLine.tsx","../../src/UNSAFE_MeterCircle/circleMeterUtils.ts","../../src/UNSAFE_MeterCircle/layoutUtils.ts","../../src/UNSAFE_MeterCircle/FitMeterCircle.tsx","../../src/UNSAFE_MeterCircle/SizedMeterCircle.tsx","../../src/UNSAFE_MeterCircle/MeterCircle.tsx"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { getCenterCoord } from '../utils/PRIVATE_meterUtils';\nimport { ColorProps } from '../utils/UNSAFE_interpolations/colors';\nimport { VisThresholdsColors, getVisThresholdColor } from '../utils/UNSAFE_meterUtils';\nimport { styles } from './themes/MeterCircleStyles.css';\nimport { classNames } from '../utils/UNSAFE_classNames';\n\ntype getCenterCoordParamType = Parameters<typeof getCenterCoord>;\n\nexport type CircularReferenceLineProps = {\n  color?: ColorProps['color'] | VisThresholdsColors;\n  angle: number;\n  radius: string;\n  length: string;\n  section: getCenterCoordParamType[0];\n};\n\nexport function CircularReferenceLine({\n  color,\n  angle,\n  radius,\n  length,\n  section = 'full'\n}: CircularReferenceLineProps) {\n  const centerCoord = getCenterCoord(section);\n  const yOffset = `calc(${centerCoord.y * 100}% - ((${Math.sin(\n    (angle * 2 * Math.PI) / 360\n  )} * ${radius})))`;\n  const xOffset = `calc(${centerCoord.x * 100}%  + ((${Math.cos(\n    (angle * 2 * Math.PI) / 360\n  )} * ${radius})))`;\n  return (\n    <div\n      class={classNames([\n        styles.referenceBaseLineStyle,\n        color ? undefined : styles.referenceBorderStyle\n      ])}\n      style={{\n        left: xOffset,\n        top: yOffset,\n        width: `calc(${length})`,\n        transform: `translate(0, -1px) rotate(${360 - angle}deg)`,\n        backgroundColor: color ? getVisThresholdColor(color) : undefined\n      }}></div>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport type { Ref } from 'preact/hooks';\nimport {\n  getPositiveAngle,\n  convertToPolar,\n  getCenterCoord,\n  Sector\n} from '../utils/PRIVATE_meterUtils';\n\nimport { CenterContext } from './meterCircle.types';\n\ntype Dimensions = {\n  width: number;\n  height: number;\n  innerRadius: number;\n  outerRadius: number;\n};\n\n/**\n * Returns the true dimensions of the meter circle after initial render. All dimensions are 0 for initial render.\n * @param element The HTML element that wraps the track and indicator div.\n * @param section The section in which the meter circle lies.\n * @returns The dimensions of the meter circle.\n */\nexport function getDimensions(element: HTMLElement | null, section: Sector): Dimensions {\n  if (!element) {\n    return {\n      width: 0,\n      height: 0,\n      innerRadius: 0,\n      outerRadius: 0\n    };\n  }\n\n  const circleTrack = element.children[0] as HTMLElement;\n  const rect = circleTrack.getBoundingClientRect();\n\n  return {\n    width: Math.round(rect.width),\n    height: Math.round(rect.height),\n    ...getInnerAndOuterRadius(circleTrack, rect, section)\n  };\n}\n\n/**\n * Returns the inner and outer radius of the meter circle.\n * @param element The HTML element that wraps the track and indicator div.\n * @param rect The bounding rect of the wrapper HTML element.\n * @param section The section in which the meter circle lies.\n * @returns The inner and outer radius of the meter circle.\n */\nfunction getInnerAndOuterRadius(\n  element: HTMLElement,\n  rect: { width: number; height: number },\n  section: string\n): {\n  innerRadius: number;\n  outerRadius: number;\n} {\n  const width = element.clientWidth;\n  const height = element.clientHeight;\n\n  if (section === 'bottom' || section === 'top') {\n    return { outerRadius: rect.width / 2, innerRadius: height };\n  } else if (section === 'left' || section === 'right') {\n    return { outerRadius: rect.height / 2, innerRadius: width };\n  }\n  return { innerRadius: width / 2, outerRadius: rect.width / 2 };\n}\n\n/**\n * Returns the value corresponding to clicked point in the meter circle. Returns undefined if the clicked point is\n * outside the track of the meter circle.\n * @param pageX The pageX of the click event\n * @param pageY The pageY of the click event\n * @param max The max value of the meter circle.\n * @param min The min value of the meter circle.\n * @param step The step of the metercircle.\n * @param dimensionsRef The ref that stores dimensions reference of meter circle.\n * @param startAngle The startAngle of the meter circle.\n * @param angleExtent The angleExtent of the meter circle\n * @returns {number} The value corresponding to clicked point in the meter circle.\n */\nexport function getValue(\n  event: PointerEvent,\n  min: number,\n  max: number,\n  step: number,\n  dimensionsRef: Ref<Dimensions>,\n  startAngle: number,\n  angleExtent: number,\n  section: Sector,\n  isRtl: boolean\n): number | undefined {\n  const dims = dimensionsRef.current;\n  if (!dims) {\n    return undefined;\n  }\n\n  const center = getCenterCoord(section);\n  const { angle } = convertToPolar(\n    dims.width * center.x,\n    dims.height * center.y,\n    event.offsetX,\n    event.offsetY\n  );\n\n  const positiveAngle = getPositiveAngle(angle);\n\n  let val;\n  if (isRtl && startAngle + angleExtent > positiveAngle) {\n    val = (getPositiveAngle(angle - startAngle) / angleExtent) * (max - min);\n  }\n\n  if (!isRtl) {\n    const clockwiseArc = getPositiveAngle(startAngle - positiveAngle);\n    if (clockwiseArc <= angleExtent) {\n      val = (clockwiseArc * (max - min)) / angleExtent;\n    }\n  }\n\n  if (val != undefined) {\n    val = Math.round(val / step) * step;\n    val = Math.max(Math.min(max, val), min);\n  }\n  return val;\n}\n\n/**\n * Returns the fraction of angle extent for given delta.\n * @param delta The delta of metric values.\n * @param min The minimum value of the meter circle.\n * @param max The maximum value of the meter circle.\n * @param angleExtent The angle extent of the meter circle.\n * @returns The angle extent corresponding to delta in metric value.\n */\nexport function getAngleExtentFromDelta(\n  delta: number,\n  min: number,\n  max: number,\n  angleExtent: number\n): number {\n  return (delta * angleExtent) / (max - min);\n}\n\n/**\n * Returns the start angle for given metric value.\n * @param value The metric value\n * @param min The minimum value of the meter circle.\n * @param max The maximum value of the meter circle.\n * @param startAngle The startAngle of the meter circle.\n * @param angleExtent The angleExtent of the meter circle.\n * @param isRtl Whether the reading mode is 'rtl'\n * @returns The startAngle for the metric value.\n */\nexport function getStartAngleForValue(\n  value: number,\n  min: number,\n  max: number,\n  startAngle: number,\n  angleExtent: number,\n  isRtl: boolean\n): number {\n  const extent = getAngleExtentFromDelta(value - min, min, max, angleExtent);\n  return startAngle + (isRtl ? 1 : -1) * extent;\n}\n\n/**\n * Returns the center context of for the meter circle.\n */\nexport function getCenterContext(\n  dimensionsRef: Ref<Dimensions>,\n  section: 'top' | 'bottom' | 'left' | 'right' | 'full'\n): CenterContext | undefined {\n  const dims = dimensionsRef.current;\n\n  if (!dims) {\n    return;\n  }\n\n  const center = getCenterCoord(section);\n  const cx = center.x * dims.width;\n  const cy = center.y * dims.height;\n\n  const isHoriz = section === 'top' || section === 'bottom';\n\n  let innerX, innerY, innerW, innerH;\n  let outerX, outerY, outerW, outerH;\n\n  if (isHoriz || section === 'full') {\n    outerW = 2 * dims.innerRadius;\n    outerH = section === 'full' ? 2 * dims.innerRadius : dims.innerRadius;\n    outerX = cx - dims.innerRadius;\n    outerY = section === 'bottom' ? 0 : cy - dims.innerRadius;\n\n    innerW = Math.sqrt(2) * dims.innerRadius;\n    innerH = section === 'full' ? innerW : dims.innerRadius / Math.sqrt(2);\n    innerX = cx - dims.innerRadius / Math.sqrt(2);\n    innerY = section === 'bottom' ? 0 : cy - dims.innerRadius / Math.sqrt(2);\n  } else {\n    outerH = 2 * dims.innerRadius;\n    outerW = dims.innerRadius;\n    outerX = section === 'left' ? cx - dims.innerRadius : 0;\n    outerY = cy - dims.innerRadius;\n\n    innerH = Math.sqrt(2) * dims.innerRadius;\n    innerW = dims.innerRadius / Math.sqrt(2);\n    innerX = section === 'left' ? cx - dims.innerRadius / Math.sqrt(2) : 0;\n    innerY = cy - dims.innerRadius / Math.sqrt(2);\n  }\n\n  return {\n    outerBounds: {\n      x: outerX,\n      y: outerY,\n      width: outerW,\n      height: outerH\n    },\n    innerBounds: {\n      x: innerX,\n      y: innerY,\n      width: innerW,\n      height: innerH\n    }\n  };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport {\n  Threshold,\n  MeterSize,\n  ThresholdDisplay,\n  getVisThresholdColor\n} from '../utils/UNSAFE_meterUtils';\nimport { getClipPath, Sector } from '../utils/PRIVATE_meterUtils';\nimport { getAngleExtentFromDelta, getStartAngleForValue } from './circleMeterUtils';\nimport { MeterProps, CircularRefLine } from './meterCircle.types';\nimport { ColorProps } from '../utils/UNSAFE_interpolations/colors';\nimport { meterCircleVars } from './themes/MeterCircleContract.css';\nimport { colorSchemeVars } from '../Common/themes/themeContract.css';\nimport { xUnits } from '../UNSAFE_Theme/utils';\n\nexport type MeterInfo = Required<\n  Pick<MeterProps, 'min' | 'max' | 'value' | 'size' | 'startAngle' | 'angleExtent'>\n> & {\n  section: Sector;\n  isRtl: boolean;\n  innerRadius: number;\n};\n\nconst METER_CIRCLE_XS_REF_PROTUSION = 8;\n\nconst METER_CIRCLE_SM_REF_PROTUSION = 16;\n/**\n * Returns the css variable corresponding to the default size of the meter circle.\n * @param size The size of the meter circle.\n * @returns The css variable corresponding to the default size of the meter circle.\n */\nfunction getSizeVar(size: MeterSize, diameter?: number): string {\n  return size\n    ? size === 'fit'\n      ? `${diameter}px`\n      : meterCircleVars.sizes[size]\n    : meterCircleVars.size;\n}\n\n/**\n * Returns the css variable corresponding to the default track size of the meter circle.\n * @param size The size of the meter circle.\n * @returns The css variable corresponding to the default track size of the meter circle.\n */\nfunction getTrackSizeVar(size: MeterSize): string {\n  return size ? meterCircleVars.trackSizes[size] : meterCircleVars.trackSize;\n}\n\n/**\n * Returns the calculated css variable string for the inner radius when given size and innerRadius of meter circle.\n * @param size The size of the meter circle.\n * @param innerRadius The inner radius of the meter circle.\n * @returns {string} CSS varible string for the calculated inner radius of the meter circle.\n */\nexport function getInnerRadius(size: MeterSize, innerRadius?: number, diameter?: number): string {\n  if (innerRadius != undefined) {\n    return `(${getSizeVar(size, diameter)} * ${innerRadius / 2})`;\n  }\n  return `(${getSizeVar(size, diameter)} * 0.5 - ${getTrackSizeVar(size)})`;\n}\n\n/**\n * Returns the calculated css variable string for meter circle track for a given size and innerRadius of meter circle.\n * @param size The size of the meter circle.\n * @param innerRadius The inner radius of the meter circle.\n * @returns {string} CSS variable for the calculated track size of the meter circle.\n */\nexport function getTrackSize(size: MeterSize, innerRadius?: number, diameter?: number): string {\n  if (innerRadius != undefined) {\n    return `(${getSizeVar(size, diameter)} * ${1 - innerRadius} / 2)`;\n  }\n  return getTrackSizeVar(size);\n}\n\n/**\n * Returns the calculated length of reference line for given size and inner radius of meter circle.\n * The length of reference line runs from the inner radius to slight outside the outer radius.\n * The length outside the outer radius depends on size of the meter circle.\n * @param size The size of the meter circle.\n * @param innerRadius The inner radius of the meter circle.\n * @returns The calculated CSS var for the length of reference line.\n */\nexport function getRefLineLength(\n  size: MeterSize,\n  innerRadius?: number,\n  isXsSize?: boolean,\n  diameter?: number\n): string {\n  return `${getTrackSize(size, innerRadius, diameter)} +  ${xUnits(\n    size === 'fit' && !isXsSize ? 4 : 2\n  )}`;\n}\n\n/**\n * Returns the array of calculated props for InnerCircle representing each threshold.\n * @param meterInfo MeterInfo object containing info about given meter circle.\n * @param thresholds thresholds array of the meter circle.\n * @param isTrackRendered Whether track is rendered.\n * @param trackColor The track color of the meter circle.\n * @param innerRadius The inner radius of the meter circle.\n * @returns Array of calculated props object for InnerCircle representing each threshold.\n */\nexport function getThresholdsProps(\n  meterInfo: MeterInfo,\n  thresholds: Threshold[],\n  isTrackRendered: boolean,\n  trackColor?: ColorProps['color'],\n  innerRadius?: number,\n  diameter?: number\n): Array<{\n  clipPath: string;\n  color?: ColorProps['color'];\n  section: Sector;\n  size: string;\n}> {\n  const {\n    min,\n    max,\n    startAngle,\n    angleExtent,\n    size,\n    section,\n    isRtl,\n    innerRadius: innerDim\n  } = meterInfo;\n  const trackSize = `calc(${getTrackSize(size, innerRadius, diameter)})`;\n  const thresholdProps = [];\n  const validThresholds = thresholds\n    .filter((threshold: Threshold) => threshold.max > min && threshold.max <= max)\n    .sort((a, b) => a.max - b.max);\n  const numOfThreshold = validThresholds.length;\n  for (let i = 0; i < numOfThreshold; i++) {\n    const threshold = validThresholds[i];\n    const startValue = i === 0 ? min : validThresholds[i - 1].max;\n    const diff = i === 0 ? threshold.max : threshold.max - validThresholds[i - 1].max;\n\n    let thresholdStart = getStartAngleForValue(\n      startValue,\n      min,\n      max,\n      startAngle,\n      angleExtent,\n      isRtl\n    );\n    let thresholdExtent = getAngleExtentFromDelta(diff, min, max, angleExtent);\n\n    const { startOffset, extentOffset } = getThresholdsBuffer(\n      innerDim,\n      angleExtent,\n      i === 0,\n      threshold.max === max,\n      isRtl\n    );\n    const clipPath = getClipPath(\n      thresholdStart + startOffset,\n      thresholdExtent + extentOffset,\n      isRtl,\n      section\n    );\n\n    thresholdProps.push({\n      clipPath,\n      color: getVisThresholdColor(threshold.color),\n      size: trackSize,\n      section\n    });\n\n    if (i === numOfThreshold - 1 && threshold.max < max && isTrackRendered) {\n      thresholdStart = thresholdStart + (isRtl ? 1 : -1) * thresholdExtent;\n      thresholdExtent = getAngleExtentFromDelta(max - threshold.max, min, max, angleExtent);\n      const { startOffset, extentOffset } = getThresholdsBuffer(\n        innerDim,\n        angleExtent,\n        false,\n        true,\n        isRtl\n      );\n      thresholdProps.push({\n        clipPath: getClipPath(\n          thresholdStart + startOffset,\n          thresholdExtent + extentOffset,\n          isRtl,\n          section\n        ),\n        color: trackColor,\n        size: trackSize,\n        section\n      });\n    }\n  }\n  return thresholdProps;\n}\n\n/**\n * Returns the calculated props for CircularReferenceLine.\n * @param meterInfo MeterInfo object containing info about the meter circle.\n * @param refLine The CircularRefLine object\n * @param innerRadius The innerRadius of the meter circle.\n * @returns An bject with calculated props for CircularReferenceLine.\n */\nexport function getReferenceLinesProps(\n  meterInfo: MeterInfo,\n  refLine: CircularRefLine,\n  innerRadius?: number,\n  isXsSize?: boolean,\n  diameter?: number\n): {\n  radius: string;\n  length: string;\n  angle: number;\n  color?: ColorProps['color'];\n} {\n  const { min, max, startAngle, angleExtent, size, isRtl } = meterInfo;\n  return {\n    radius: getInnerRadius(size, innerRadius, diameter),\n    length: getRefLineLength(size, innerRadius, isXsSize, diameter),\n    angle: getStartAngleForValue(refLine.value, min, max, startAngle, angleExtent, isRtl),\n    color: refLine.color\n  };\n}\n\n/**\n * Returns the calculated props for InnerCircle representing the track.\n * @param meterInfo MeterInfo object containing info about the meter circle.\n * @param trackColor The color of the track.\n * @param istrackRendered Whether the track is rendered.\n * @param thresholdDisplay Specifies whether the current threshold is displayed in the track, on the indicator, or if all thresholds are displayed in the track.\n * @param innerRadius The innerRadius of the meter circle.\n * @param thresholds thresholds array of the meter circle.\n * @returns An object with calculated props for InnerCircle that represents the track.\n */\nexport function getTrackProps(\n  meterInfo: MeterInfo,\n  isTrackRendered: boolean,\n  thresholdDisplay: ThresholdDisplay,\n  trackColor?: ColorProps['color'],\n  innerRadius?: number,\n  thresholds?: Threshold[],\n  diameter?: number\n): {\n  section: Sector;\n  color?: ColorProps['color'];\n  clipPath: string;\n  size: string;\n} {\n  const { startAngle, angleExtent, size, section, isRtl } = meterInfo;\n  const color = !isTrackRendered\n    ? 'transparent'\n    : thresholdDisplay === 'all' && thresholds\n    ? `${colorSchemeVars.dvt.contrastLine}`\n    : trackColor;\n  return {\n    section,\n    color,\n    clipPath: getClipPath(startAngle, angleExtent, isRtl, section),\n    size: `calc(${getTrackSize(size, innerRadius, diameter)})`\n  };\n}\n\n/**\n * Returns the calculated props for InnerCircle representing the indicator.\n * @param meterInfo MeterInfo object containing info about the meter circle.\n * @param indicatorSize Relative thickness of the indicator to the track.\n * @param innerRadius The innerRadius of the meter circle.\n * @returns An object with calculated props for InnerCircle that represents the indicator.\n */\nexport function getIndicatorProps(\n  meterInfo: MeterInfo,\n  indicatorSize: number,\n  innerRadius?: number,\n  fitDiameter?: number\n) {\n  const { value, min, max, startAngle, angleExtent, size, section, isRtl } = meterInfo;\n  const valueExtent = ((value - min) * angleExtent) / (max - min);\n  const validIndicatorSize = Math.min(Math.max(0, indicatorSize), 1);\n  const isHoriz = section === 'left' || section === 'right';\n  const isVert = section === 'top' || section === 'bottom';\n  const valueTrackSize = `calc(${getTrackSize(\n    size,\n    innerRadius,\n    fitDiameter\n  )} * ${validIndicatorSize})`;\n  const diameter = `${getSizeVar(\n    size,\n    fitDiameter\n  )} - ((1 - ${validIndicatorSize}) * ${getTrackSize(size, innerRadius, fitDiameter)})`;\n  const radius = `(${diameter}) / 2`;\n  return {\n    section,\n    width: isHoriz ? `calc(${radius})` : `calc(${diameter})`,\n    height: isVert ? `calc(${radius})` : `calc(${diameter})`,\n    size: valueTrackSize,\n    clipPath: getClipPath(startAngle, valueExtent, isRtl, section)\n  };\n}\n\n/**\n * Returns the threshold offsets to create the whitespace between the thresholds.\n * @param innerRadius The innerRadius of the meter circle.\n * @param angleExtent The angleExtent of the meter circle.\n * @param firstThreshold Whether the current threshold is the first threshold.\n * @param lastThreshold  Whether the current threshold is the last threshold.\n * @param isRtl Whether the document reading mode is 'rtl'\n * @returns The offsets (startOffset and extentOffset) to add to calculated threshold startAngle and threhsold extent.\n */\nfunction getThresholdsBuffer(\n  innerRadius: number,\n  angleExtent: number,\n  firstThreshold: boolean,\n  lastThreshold: boolean,\n  isRtl: boolean\n): {\n  startOffset: number;\n  extentOffset: number;\n} {\n  if (!innerRadius) {\n    return { startOffset: 0, extentOffset: 0 };\n  }\n  const offset = 360 / (2 * Math.PI * innerRadius);\n  let startOffset = (offset / 2) * (isRtl ? 1 : -1);\n  let extentOffset = -1 * offset;\n\n  if (firstThreshold && angleExtent < 360) {\n    startOffset = 0;\n    extentOffset = -0.5 * offset;\n  }\n\n  if (lastThreshold && angleExtent < 360) {\n    extentOffset = -0.5 * offset;\n  }\n  return { startOffset, extentOffset };\n}\n\nexport function getWidthAndHeight(width: number, height: number, section: Sector) {\n  if (section === 'top' || section === 'bottom') {\n    return {\n      height: Math.min(height, width / 2),\n      width: Math.min(height, width / 2) * 2\n    };\n  } else if (section === 'left' || section === 'right') {\n    return {\n      width: Math.min(width, height / 2),\n      height: Math.min(width, height / 2) * 2\n    };\n  } else {\n    return {\n      width: Math.min(width, height),\n      height: Math.min(width, height)\n    };\n  }\n}\n\nexport function getWidthAndHeightWithReferenceLine(\n  _width: number,\n  _height: number,\n  hasReferenceLine: boolean,\n  isXsSize: boolean,\n  section: Sector\n) {\n  if (!hasReferenceLine) {\n    return { width: _width, height: _height };\n  }\n\n  if (section === 'full') {\n    return {\n      width:\n        _width - 2 * (isXsSize ? METER_CIRCLE_XS_REF_PROTUSION : METER_CIRCLE_SM_REF_PROTUSION),\n      height:\n        _height - 2 * (isXsSize ? METER_CIRCLE_XS_REF_PROTUSION : METER_CIRCLE_SM_REF_PROTUSION)\n    };\n  } else if (section === 'top' || section === 'bottom') {\n    return {\n      width:\n        _width - 2 * (isXsSize ? METER_CIRCLE_XS_REF_PROTUSION : METER_CIRCLE_SM_REF_PROTUSION),\n      height: _height - (isXsSize ? METER_CIRCLE_XS_REF_PROTUSION : METER_CIRCLE_SM_REF_PROTUSION)\n    };\n  } else {\n    return {\n      width: _width - (isXsSize ? METER_CIRCLE_XS_REF_PROTUSION : METER_CIRCLE_SM_REF_PROTUSION),\n      height:\n        _height - 2 * (isXsSize ? METER_CIRCLE_XS_REF_PROTUSION : METER_CIRCLE_SM_REF_PROTUSION)\n    };\n  }\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { useUser } from '../hooks/UNSAFE_useUser';\nimport { useEffect, useRef, useState } from 'preact/hooks';\nimport { mergeProps } from '../utils/UNSAFE_mergeProps';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { CircleWrapper, CircleInner } from '../PRIVATE_Meter';\nimport { CircularReferenceLine } from './CircularReferenceLine';\nimport { TrackResizeContainer } from '../PRIVATE_TrackResizeContainer';\n\nimport {\n  validateRange,\n  getTrackAndIndicatorColor,\n  getMeterAriaProps,\n  getCircleSection\n} from '../utils/PRIVATE_meterUtils';\n\nimport { getDimensions, getValue, getCenterContext } from './circleMeterUtils';\n\nimport {\n  getIndicatorProps,\n  getTrackProps,\n  getThresholdsProps,\n  getReferenceLinesProps,\n  MeterInfo,\n  getWidthAndHeight,\n  getWidthAndHeightWithReferenceLine\n} from './layoutUtils';\n\nimport {\n  usePointerEvents,\n  useKeyboardEvents,\n  useMeterDatatip\n} from '../hooks/PRIVATE_useVisMeterEvents';\n\nimport { MeterProps, CircularRefLine } from './meterCircle.types';\nimport { useTabbableMode } from '../hooks/UNSAFE_useTabbableMode';\nimport { useComponentTheme } from '../hooks/UNSAFE_useComponentTheme';\nimport { MeterCircleStyles, MeterCircleVariantOptions } from './themes/MeterCircleStyles.css';\nimport { MeterCircleRedwoodTheme } from './themes/redwood/MeterCircleTheme';\nimport { useTestId } from '../hooks/UNSAFE_useTestId';\n\nconst XS_BREAKPOINT = 360;\nconst FIT_INNERRADIUS = 0.8;\n\n/**\n * A Meter circle displays information graphically in a circular bar, highlighting a specific metric value's progress in relation to its min, max, or thresholds.\n */\nexport function FitMeterCircle({\n  max = 100,\n  min = 0,\n  value = 0,\n  step = 1,\n  size = 'fit',\n  startAngle = 90,\n  angleExtent = 360,\n  isTrackRendered = true,\n  thresholdDisplay = 'all',\n  indicatorSize = 1,\n  testId,\n  ...props\n}: MeterProps) {\n  const testIdProps = useTestId(testId);\n  validateRange(min, max, value, step);\n  const isInteractive = props.onCommit || props.onInput;\n  const { classes, styles } = useComponentTheme<MeterCircleVariantOptions, MeterCircleStyles>(\n    MeterCircleRedwoodTheme,\n    {\n      size,\n      interaction: isInteractive ? 'isInteractive' : undefined\n    }\n  );\n\n  return (\n    <TrackResizeContainer class={classes} width={'100%'} height={'100%'}>\n      {function _(_width, _height) {\n        const { direction } = useUser();\n        const isRtl = direction === 'rtl';\n\n        let sAngle = startAngle;\n        if (isRtl) {\n          sAngle = 180 - sAngle;\n        }\n        const section = getCircleSection(sAngle, angleExtent, isRtl);\n\n        const { width: _w } = getWidthAndHeight(_width, _height, section);\n        const isXsSize = _w < XS_BREAKPOINT;\n\n        const innerR = props.innerRadius || size === 'fit' ? FIT_INNERRADIUS : undefined;\n\n        const { width: w, height: h } = getWidthAndHeightWithReferenceLine(\n          _width,\n          _height,\n          !!props.referenceLines?.length,\n          isXsSize,\n          section\n        );\n\n        const { width, height } = getWidthAndHeight(w, h, section);\n\n        const radius = section === 'full' ? Math.min(width, height) / 2 : Math.min(width, height);\n        const diameter = radius * 2;\n\n        const currentInputRef = useRef<number>();\n\n        const dimensionsRef = useRef(getDimensions(null, section));\n        const circleWrapperRef = useRef<HTMLDivElement>(null);\n        const [isDimsReady, setDimsReady] = useState<boolean>(false);\n\n        useEffect(() => {\n          if (props.onCommit || props.onInput || props.children) {\n            dimensionsRef.current = getDimensions(circleWrapperRef.current, section);\n            setDimsReady(true);\n          }\n        }, [section]);\n\n        const getValueFromEvent = (event: PointerEvent) => {\n          const circleContainer = circleWrapperRef.current;\n          if (event.target == circleContainer) {\n            return getValue(\n              event,\n              min,\n              max,\n              step,\n              dimensionsRef,\n              sAngle,\n              angleExtent,\n              section,\n              isRtl\n            );\n          }\n          return;\n        };\n\n        const isPointerActiveRef = useRef(false);\n\n        const pointerEventsProps = usePointerEvents(\n          value,\n          getValueFromEvent,\n          circleWrapperRef,\n          currentInputRef,\n          isPointerActiveRef,\n          props.onCommit,\n          props.onInput\n        );\n\n        const keyboardEventsProps = useKeyboardEvents(\n          value,\n          min,\n          max,\n          step,\n          currentInputRef,\n          props.onCommit,\n          props.onInput\n        );\n\n        const { datatipContent, datatipProps } = useMeterDatatip(\n          value,\n          isPointerActiveRef,\n          props.datatip,\n          props['aria-describedby']\n        );\n\n        const ariaProps = getMeterAriaProps(\n          value,\n          min,\n          max,\n          props['aria-label'],\n          props['aria-labelledby'],\n          props.thresholds\n        );\n        const mergedProps = mergeProps(\n          pointerEventsProps,\n          keyboardEventsProps,\n          datatipProps,\n          ariaProps\n        );\n\n        const { trackColor, indicatorColor } = getTrackAndIndicatorColor(\n          value,\n          thresholdDisplay,\n          props.trackColor,\n          props.indicatorColor,\n          props.thresholds\n        );\n\n        const meterInfo = {\n          min,\n          max,\n          value,\n          startAngle: sAngle,\n          angleExtent,\n          size,\n          section,\n          isRtl,\n          innerRadius: dimensionsRef.current.innerRadius\n        } as MeterInfo;\n\n        const { isTabbable } = useTabbableMode();\n        const centerContext = getCenterContext(dimensionsRef, section);\n\n        return (\n          <>\n            <div\n              class={classNames([\n                classes,\n                section === 'full' ? `${styles.meterCircleFullSizeStyle}, ${styles.centerDiv}` : ''\n              ])}\n              style={{\n                width: _width,\n                height: _height\n              }}\n              tabIndex={!isTabbable ? -1 : 0}\n              {...testIdProps}\n              {...mergedProps}>\n              <CircleWrapper\n                wrapperRef={circleWrapperRef}\n                class={classNames([\n                  styles.circleWrapperBaseStyle,\n                  props.referenceLines && props.referenceLines.length > 0\n                    ? size && styles[`fit${isXsSize ? 'Sm' : 'Lg'}${section}Style`]\n                    : '',\n                  styles.centerDiv\n                ])}\n                width={`${width}px`}\n                height={`${height}px`}>\n                <CircleInner\n                  width={`${width}px`}\n                  height={`${height}px`}\n                  class={classNames([styles.circleTrackBaseStyle, styles[`${section}Style`]])}\n                  {...getTrackProps(\n                    meterInfo,\n                    isTrackRendered,\n                    thresholdDisplay,\n                    trackColor,\n                    innerR,\n                    props.thresholds,\n                    diameter\n                  )}\n                />\n                {thresholdDisplay === 'all' &&\n                  props.thresholds &&\n                  getThresholdsProps(\n                    meterInfo,\n                    props.thresholds,\n                    isTrackRendered,\n                    trackColor,\n                    innerR,\n                    diameter\n                  ).map((threshold) => {\n                    return (\n                      <CircleInner\n                        class={classNames([styles.circleTrackBaseStyle, styles[`${section}Style`]])}\n                        {...threshold}\n                        width={`${width}px`}\n                        height={`${height}px`}\n                      />\n                    );\n                  })}\n                <CircleInner\n                  color={indicatorColor}\n                  class={classNames([\n                    styles.circleValueBaseStyle,\n                    styles[`circleValue${section}Style`],\n                    styles[`${section}Style`]\n                  ])}\n                  {...getIndicatorProps(meterInfo, indicatorSize, innerR, 2 * radius)}\n                />\n                {props.referenceLines?.map((refLine: CircularRefLine) => {\n                  return (\n                    <CircularReferenceLine\n                      {...getReferenceLinesProps(meterInfo, refLine, innerR, isXsSize, diameter)}\n                      section={section}\n                    />\n                  );\n                })}\n                {isDimsReady && props.children && centerContext && (\n                  <div class={classNames([styles.meterCircleCenterContent])}>\n                    {props.children(centerContext)}\n                  </div>\n                )}\n              </CircleWrapper>\n            </div>\n            {datatipContent}\n          </>\n        );\n      }}\n    </TrackResizeContainer>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { useUser } from '../hooks/UNSAFE_useUser';\nimport { useEffect, useRef, useState } from 'preact/hooks';\nimport { mergeProps } from '../utils/UNSAFE_mergeProps';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { CircleWrapper, CircleInner } from '../PRIVATE_Meter';\nimport { CircularReferenceLine } from './CircularReferenceLine';\n\nimport {\n  validateRange,\n  getTrackAndIndicatorColor,\n  getMeterAriaProps,\n  getCircleSection\n} from '../utils/PRIVATE_meterUtils';\n\nimport { getDimensions, getValue, getCenterContext } from './circleMeterUtils';\n\nimport {\n  getIndicatorProps,\n  getTrackProps,\n  getThresholdsProps,\n  getReferenceLinesProps,\n  MeterInfo\n} from './layoutUtils';\n\nimport {\n  usePointerEvents,\n  useKeyboardEvents,\n  useMeterDatatip\n} from '../hooks/PRIVATE_useVisMeterEvents';\n\nimport { MeterProps, CircularRefLine } from './meterCircle.types';\nimport { useTabbableMode } from '../hooks/UNSAFE_useTabbableMode';\nimport { useComponentTheme } from '../hooks/UNSAFE_useComponentTheme';\nimport { MeterCircleStyles, MeterCircleVariantOptions } from './themes/MeterCircleStyles.css';\nimport { MeterCircleRedwoodTheme } from './themes/redwood/MeterCircleTheme';\nimport { useTestId } from '../hooks/UNSAFE_useTestId';\n\ntype SizedMeterProps = MeterProps & { size?: 'sm' | 'md' | 'lg' };\n\n/**\n * A Meter circle displays information graphically in a circular bar, highlighting a specific metric value's progress in relation to its min, max, or thresholds.\n */\nexport function SizedMeterCircle({\n  max = 100,\n  min = 0,\n  value = 0,\n  step = 1,\n  size,\n  startAngle = 90,\n  angleExtent = 360,\n  isTrackRendered = true,\n  thresholdDisplay = 'all',\n  indicatorSize = 1,\n  testId,\n  ...props\n}: SizedMeterProps) {\n  const testIdProps = useTestId(testId);\n\n  validateRange(min, max, value, step);\n  const currentInputRef = useRef<number>();\n  const { direction } = useUser();\n  const isRtl = direction === 'rtl';\n\n  let sAngle = startAngle;\n  if (isRtl) {\n    sAngle = 180 - sAngle;\n  }\n\n  const section = getCircleSection(sAngle, angleExtent, isRtl);\n  const dimensionsRef = useRef(getDimensions(null, section));\n  const circleWrapperRef = useRef<HTMLDivElement>(null);\n  const [isDimsReady, setDimsReady] = useState<boolean>(false);\n\n  useEffect(() => {\n    if (props.onCommit || props.onInput || props.children) {\n      dimensionsRef.current = getDimensions(circleWrapperRef.current, section);\n      setDimsReady(true);\n    }\n  }, [size, section, props.onCommit, props.onInput, props.children]);\n\n  const getValueFromEvent = (event: PointerEvent) => {\n    const circleContainer = circleWrapperRef.current;\n    if (event.target == circleContainer) {\n      return getValue(event, min, max, step, dimensionsRef, sAngle, angleExtent, section, isRtl);\n    }\n    return;\n  };\n\n  const isPointerActiveRef = useRef(false);\n\n  const pointerEventsProps = usePointerEvents(\n    value,\n    getValueFromEvent,\n    circleWrapperRef,\n    currentInputRef,\n    isPointerActiveRef,\n    props.onCommit,\n    props.onInput\n  );\n\n  const keyboardEventsProps = useKeyboardEvents(\n    value,\n    min,\n    max,\n    step,\n    currentInputRef,\n    props.onCommit,\n    props.onInput\n  );\n\n  const { datatipContent, datatipProps } = useMeterDatatip(\n    value,\n    isPointerActiveRef,\n    props.datatip,\n    props['aria-describedby']\n  );\n\n  const ariaProps = getMeterAriaProps(\n    value,\n    min,\n    max,\n    props['aria-label'],\n    props['aria-labelledby'],\n    props.thresholds\n  );\n  const mergedProps = mergeProps(pointerEventsProps, keyboardEventsProps, datatipProps, ariaProps);\n\n  const { trackColor, indicatorColor } = getTrackAndIndicatorColor(\n    value,\n    thresholdDisplay,\n    props.trackColor,\n    props.indicatorColor,\n    props.thresholds\n  );\n\n  const orientation =\n    section === 'bottom' || section === 'top'\n      ? 'Horizontal'\n      : section === 'left' || section === 'right'\n      ? 'Vertical'\n      : 'Full';\n\n  const meterInfo = {\n    min,\n    max,\n    value,\n    startAngle: sAngle,\n    angleExtent,\n    size,\n    section,\n    isRtl,\n    innerRadius: dimensionsRef.current.innerRadius\n  } as MeterInfo;\n  const isInteractive = props.onCommit || props.onInput;\n\n  const { classes, styles } = useComponentTheme<MeterCircleVariantOptions, MeterCircleStyles>(\n    MeterCircleRedwoodTheme,\n    {\n      size,\n      interaction: isInteractive ? 'isInteractive' : undefined\n    }\n  );\n\n  const { isTabbable } = useTabbableMode();\n  const centerContext = getCenterContext(dimensionsRef, section);\n\n  return (\n    <>\n      <div\n        class={classNames([classes])}\n        tabIndex={!isTabbable ? -1 : 0}\n        {...testIdProps}\n        {...mergedProps}>\n        <CircleWrapper\n          wrapperRef={circleWrapperRef}\n          class={classNames([\n            styles.circleWrapperBaseStyle,\n            props.referenceLines && props.referenceLines.length > 0\n              ? size && styles[`${size}${section}Style`]\n              : '',\n            styles[`meterCircle${orientation}SizeStyle`]\n          ])}>\n          <CircleInner\n            class={classNames([styles.circleTrackBaseStyle, styles[`${section}Style`]])}\n            {...getTrackProps(\n              meterInfo,\n              isTrackRendered,\n              thresholdDisplay,\n              trackColor,\n              props.innerRadius,\n              props.thresholds\n            )}\n          />\n          {thresholdDisplay === 'all' &&\n            props.thresholds &&\n            getThresholdsProps(\n              meterInfo,\n              props.thresholds,\n              isTrackRendered,\n              trackColor,\n              props.innerRadius\n            ).map((threshold) => {\n              return (\n                <CircleInner\n                  class={classNames([styles.circleTrackBaseStyle, styles[`${section}Style`]])}\n                  {...threshold}\n                />\n              );\n            })}\n\n          <CircleInner\n            color={indicatorColor}\n            class={classNames([\n              styles.circleValueBaseStyle,\n              styles[`circleValue${section}Style`],\n              styles[`${section}Style`]\n            ])}\n            {...getIndicatorProps(meterInfo, indicatorSize, props.innerRadius)}\n          />\n          {props.referenceLines?.map((refLine: CircularRefLine) => {\n            return (\n              <CircularReferenceLine\n                {...getReferenceLinesProps(meterInfo, refLine, props.innerRadius)}\n                section={section}\n              />\n            );\n          })}\n          {isDimsReady && props.children && centerContext && (\n            <div class={classNames([styles.meterCircleCenterContent])}>\n              {props.children(centerContext)}\n            </div>\n          )}\n        </CircleWrapper>\n      </div>\n      {datatipContent}\n    </>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { FitMeterCircle } from './FitMeterCircle';\nimport { SizedMeterCircle } from './SizedMeterCircle';\nimport { MeterProps } from './meterCircle.types';\n\n/**\n * A Meter circle displays information graphically in a circular bar, highlighting a specific metric value's progress in relation to its min, max, or thresholds.\n */\nexport function MeterCircle({\n  size,\n  max = 100,\n  min = 0,\n  value = 0,\n  step = 1,\n  startAngle = 90,\n  angleExtent = 360,\n  isTrackRendered = true,\n  thresholdDisplay = 'all',\n  indicatorSize = 1,\n  ...props\n}: MeterProps) {\n  if (size === 'fit') {\n    return (\n      <FitMeterCircle\n        min={min}\n        value={value}\n        max={max}\n        step={step}\n        startAngle={startAngle}\n        angleExtent={angleExtent}\n        isTrackRendered={isTrackRendered}\n        thresholdDisplay={thresholdDisplay}\n        indicatorSize={indicatorSize}\n        {...props}\n      />\n    );\n  }\n  return (\n    <SizedMeterCircle\n      size={size || 'lg'}\n      min={min}\n      value={value}\n      max={max}\n      step={step}\n      startAngle={startAngle}\n      angleExtent={angleExtent}\n      isTrackRendered={isTrackRendered}\n      thresholdDisplay={thresholdDisplay}\n      indicatorSize={indicatorSize}\n      {...props}\n    />\n  );\n}\n"],"names":["CircularReferenceLine","color","angle","radius","length","section","centerCoord","getCenterCoord","yOffset","y","Math","sin","PI","xOffset","x","cos","_jsx","class","classNames","styles","referenceBaseLineStyle","undefined","referenceBorderStyle","style","left","top","width","transform","backgroundColor","getVisThresholdColor","getDimensions","element","height","innerRadius","outerRadius","circleTrack","children","rect","getBoundingClientRect","round","getInnerAndOuterRadius","clientWidth","clientHeight","getValue","event","min","max","step","dimensionsRef","startAngle","angleExtent","isRtl","dims","current","center","convertToPolar","offsetX","offsetY","positiveAngle","getPositiveAngle","val","clockwiseArc","getAngleExtentFromDelta","delta","getStartAngleForValue","value","getCenterContext","cx","cy","innerX","innerY","innerW","innerH","outerX","outerY","outerW","outerH","sqrt","outerBounds","innerBounds","METER_CIRCLE_XS_REF_PROTUSION","METER_CIRCLE_SM_REF_PROTUSION","getSizeVar","size","diameter","meterCircleVars","sizes","getTrackSizeVar","trackSizes","trackSize","getInnerRadius","getTrackSize","getRefLineLength","isXsSize","xUnits","getThresholdsProps","meterInfo","thresholds","isTrackRendered","trackColor","innerDim","thresholdProps","validThresholds","filter","threshold","sort","a","b","numOfThreshold","i","startValue","diff","thresholdStart","thresholdExtent","startOffset","extentOffset","getThresholdsBuffer","clipPath","getClipPath","push","getReferenceLinesProps","refLine","getTrackProps","thresholdDisplay","colorSchemeVars","dvt","contrastLine","getIndicatorProps","indicatorSize","fitDiameter","valueExtent","validIndicatorSize","isHoriz","isVert","valueTrackSize","firstThreshold","lastThreshold","offset","getWidthAndHeight","XS_BREAKPOINT","FIT_INNERRADIUS","FitMeterCircle","testId","props","testIdProps","useTestId","validateRange","isInteractive","onCommit","onInput","classes","useComponentTheme","MeterCircleRedwoodTheme","interaction","TrackResizeContainer","_width","_height","direction","useUser","sAngle","getCircleSection","_w","innerR","w","h","hasReferenceLine","getWidthAndHeightWithReferenceLine","referenceLines","currentInputRef","useRef","circleWrapperRef","isDimsReady","setDimsReady","useState","useEffect","isPointerActiveRef","pointerEventsProps","usePointerEvents","circleContainer","target","keyboardEventsProps","useKeyboardEvents","datatipContent","datatipProps","useMeterDatatip","datatip","ariaProps","getMeterAriaProps","mergedProps","mergeProps","indicatorColor","getTrackAndIndicatorColor","isTabbable","useTabbableMode","centerContext","_jsxs","jsxs","_Fragment","Fragment","meterCircleFullSizeStyle","centerDiv","tabIndex","CircleWrapper","wrapperRef","circleWrapperBaseStyle","CircleInner","circleTrackBaseStyle","map","jsx","circleValueBaseStyle","meterCircleCenterContent","SizedMeterCircle","orientation"],"mappings":"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"}