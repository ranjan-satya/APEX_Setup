{"version":3,"file":"utils-c37303f8.js","sources":["../../src/PRIVATE_VisSVGText/utils/truncation.ts","../../src/PRIVATE_VisSVGText/utils/utils.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { GetTextDimensionsType } from '../../hooks/PRIVATE_useTextDimensions';\n\nconst ELLIPSIS = '\\u2026';\n\nconst MAX_MULTILINE_THRESHOLD = 3;\n\n/**\n * Checks if the text lines ends with ellipses and\n * hence if they need tooltip.\n * @param lines\n * @returns\n */\nexport function endsWithEllipsis(lines: string[]) {\n  const lastLine = lines[lines.length - 1];\n  return lastLine?.endsWith(ELLIPSIS);\n}\n\n/**\n * Truncates the text in a single line.\n * @param text The untruncated text.\n * @param maxWidth The max available width.\n * @param maxHeight The max available height.\n * @param minChars The min chars before ellisis is introduced.\n * @param getTextDimensions\n * @returns\n */\nexport function truncateSingleLineText(\n  text: string,\n  textStyle: Record<string, any>,\n  maxWidth: number,\n  maxHeight: number,\n  minChars: number,\n  getTextDimensions: GetTextDimensionsType\n) {\n  if (!getTextDimensions) {\n    return '';\n  }\n\n  if (maxWidth <= 0) {\n    return '';\n  }\n\n  let dims = getTextDimensions(text, textStyle);\n\n  if (dims.width <= maxWidth) return text;\n\n  if (dims.height > maxHeight) return '';\n\n  // Determine avg pixels per char and make an initial guess at the truncation\n  const textString = text;\n  const textLength = text.length;\n  const avgPixelsPerChar = dims.width / getTextLength(text);\n  let maxNumChars = Math.max(Math.floor(maxWidth / avgPixelsPerChar) - 2, minChars);\n\n  let truncatedTextString = textString.substring(0, maxNumChars) + ELLIPSIS;\n\n  // Add characters if initial guess is too short.\n  // Keep track of the previous string and dims in case we overshoot\n  let prevTextString = truncatedTextString;\n  dims = getTextDimensions(truncatedTextString, textStyle);\n  let prevDims = dims;\n  while (dims.width < maxWidth) {\n    if (maxNumChars >= textString.length) break;\n\n    // Calculate the availWidth and use that to estimate the number of characters to increment\n    const availWidth = maxWidth - dims.width;\n\n    // estimatedIncrement: The smaller of the chars remaining and the estimate of characters than can fit\n    const estimatedIncrement = Math.min(\n      textLength - maxNumChars,\n      Math.max(Math.floor(availWidth / avgPixelsPerChar), 1)\n    );\n\n    // Add chars and measure again\n    maxNumChars += estimatedIncrement;\n    truncatedTextString = textString.substring(0, maxNumChars) + ELLIPSIS;\n    dims = getTextDimensions(truncatedTextString, textStyle);\n\n    // If we overshot and the increment was only 1, then restore the old string\n    if (estimatedIncrement == 1 && dims.width > maxWidth) {\n      truncatedTextString = prevTextString;\n      dims = prevDims;\n      break;\n    }\n\n    // Otherwise update the previous string and dims\n    prevTextString = truncatedTextString;\n    prevDims = dims;\n  }\n\n  // Remove characters if initial guess is too long\n  while (dims.width > maxWidth) {\n    if (maxNumChars <= minChars) {\n      truncatedTextString = '';\n      break;\n    }\n\n    // Truncate 1 char at a time\n    maxNumChars -= 1;\n    truncatedTextString = textString.substring(0, maxNumChars) + ELLIPSIS;\n    dims = getTextDimensions(truncatedTextString, textStyle);\n  }\n\n  return truncatedTextString;\n}\n\n/**\n * Returns the length of the string after replacing zero length chars.\n * @param textString\n * @returns The length of the string.\n */\nfunction getTextLength(textString: string) {\n  textString = textString.replace(/[\\u200A\\u200B\\u200C\\u200D\\u200E\\u200F\\uFEFF]/g, '');\n  return textString.length;\n}\n\n/**\n * Truncates the string recursively.\n * @returns\n */\nfunction truncatedMultilineTextRecursive(\n  splits: string[],\n  textStyle: Record<string, any>,\n  maxWidth: number,\n  maxHeight: number,\n  minChars: number,\n  getTextDimensions: GetTextDimensionsType,\n  layer = 1\n) {\n  const fullText = splits.join(' ');\n\n  const { width, height } = getTextDimensions(fullText, textStyle);\n\n  if (height > maxHeight) {\n    return [];\n  }\n\n  if (width <= maxWidth) {\n    return [splits.join(' ')];\n  }\n\n  let currentIndex = 0;\n  let lastUntrucatedLine = '';\n\n  while (currentIndex < splits.length) {\n    const currentLine = splits.slice(0, currentIndex + 1).join(' ');\n    const truncated = truncateSingleLineText(\n      currentLine,\n      textStyle,\n      maxWidth,\n      maxHeight,\n      minChars,\n      getTextDimensions\n    );\n\n    const isTruncated = truncated != currentLine;\n    const doesNotFit = truncated === '';\n\n    if (isTruncated) {\n      const newSplits = splits.slice(currentIndex);\n      const otherLines: string[] =\n        layer < MAX_MULTILINE_THRESHOLD\n          ? truncatedMultilineTextRecursive(\n              newSplits,\n              textStyle,\n              maxWidth,\n              maxHeight - 12,\n              minChars,\n              getTextDimensions,\n              layer + 1\n            )\n          : [];\n      if (otherLines.length === 0) {\n        return [truncated];\n      } else {\n        return [lastUntrucatedLine, ...otherLines];\n      }\n    } else if (doesNotFit) {\n      return [];\n    } else {\n      currentIndex += 1;\n      lastUntrucatedLine = currentLine;\n    }\n  }\n\n  // shouldn't actually reach here.\n  return [splits.join(' ')];\n}\n\n/**\n * Returns the array of lines of texts.\n * @param splits The words in the text.\n * @param maxWidth The max available width.\n * @param maxHeight The max available height.\n * @param minChars The min number of chars before ellipsis is shown.\n * @param getTextDimensions The function used to measure the dimension of a text.\n * @returns\n */\nexport function truncateMultilineText(\n  text: string,\n  textStyle: Record<string, any>,\n  maxWidth: number,\n  maxHeight: number,\n  minChars: number,\n  getTextDimensions: GetTextDimensionsType\n) {\n  const splits = text.split(/\\s+/);\n  return truncatedMultilineTextRecursive(\n    splits,\n    textStyle,\n    maxWidth,\n    maxHeight,\n    minChars,\n    getTextDimensions,\n    1\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { AxisPosition } from '../../utils/UNSAFE_visTypes/chart';\nimport { cloneDimension } from '../../utils/PRIVATE_visLayoutUtils';\nimport { TextDimensions, GetTextDimensionsType } from '../../hooks/PRIVATE_useTextDimensions';\nimport { endsWithEllipsis, truncateMultilineText, truncateSingleLineText } from './truncation';\nimport { Dimension } from '../../utils/UNSAFE_visTypes/common';\n\nconst REPRESENTATIVE_TEXT = 'MV';\n\n/**\n * Returns the (x, y) coordinate of the text given the width and height of the chart.\n * @param position\n * @param availSpace\n * @param textDims\n * @returns\n */\nexport const positionMultilineText = (\n  lines: string[],\n  dims: Dimension[],\n  lineHeight: number,\n  position: AxisPosition,\n  availSpace: Dimension,\n  isRtl: boolean\n) => {\n  const space = cloneDimension(availSpace);\n  return lines.map((_, i) => {\n    const textCoord = centerTextInAvailSpace(position, space, isRtl, dims[i]);\n\n    if (position === 'top') {\n      space.y += lineHeight;\n      space.height -= lineHeight;\n    } else if (position === 'left') {\n      space.x += lineHeight;\n      space.width -= lineHeight;\n    } else if (position === 'bottom') {\n      space.height -= lineHeight;\n    } else {\n      space.width -= lineHeight;\n    }\n\n    return textCoord;\n  });\n};\n\n/**\n * Returns the x and y positon for a centered text.\n * @param position\n * @param availSpace\n * @param isRtl\n * @param textDims\n * @returns\n */\nexport function centerTextInAvailSpace(\n  position: AxisPosition,\n  availSpace: Dimension,\n  isRtl: boolean,\n  textDims: { width: number; height: number }\n) {\n  let x: number;\n  let y: number;\n\n  if (position === 'left') {\n    x = availSpace.x + textDims.height / 2 - (isRtl ? textDims.height / 2 : 0);\n    y = availSpace.y + availSpace.height / 2;\n  } else if (position === 'right') {\n    x = availSpace.x + availSpace.width - (isRtl ? textDims.height / 2 : 0);\n    y = availSpace.y + availSpace.height / 2;\n  } else if (position === 'top') {\n    x = availSpace.x + availSpace.width / 2;\n    y = availSpace.y + textDims.height / 2;\n  } else {\n    x = availSpace.x + availSpace.width / 2;\n    y = availSpace.y + availSpace.height - textDims.height / 2;\n  }\n\n  return { x, y };\n}\n\n/**\n * Returns the props for the text component.\n */\nexport function getTextProps(\n  lines: string[],\n  textStyle: Record<string, any>,\n  bounds: TextDimensions,\n  isRotated: boolean,\n  isRtl: boolean,\n  getTextDimension: GetTextDimensionsType\n) {\n  let { x, y } = bounds;\n\n  const lineHeight = getTextDimension(REPRESENTATIVE_TEXT, textStyle).width;\n\n  const props: any = [];\n\n  lines.forEach((line, i) => {\n    const transform = isRotated\n      ? `matrix(0, ${isRtl ? 1 : -1}, ${isRtl ? -1 : 1}, 0, ${x}, ${y})`\n      : undefined;\n\n    props.push({\n      text: line,\n      x: isRotated ? undefined : x,\n      y: isRotated ? undefined : y + i * lineHeight,\n      transform: isRotated ? transform : undefined\n    });\n\n    x += isRotated ? lineHeight : 0;\n    y += isRotated ? 0 : lineHeight;\n  });\n  return props;\n}\n\n/**\n * Returns the text info for the given text.\n */\nexport function getTextInfo(\n  text: string,\n  textStyle: Record<string, any>,\n  width: number,\n  height: number,\n  isMultiline: boolean,\n  getTextDimension: GetTextDimensionsType\n) {\n  const lines = isMultiline\n    ? truncateMultilineText(text, textStyle, width, height, 1, getTextDimension)\n    : [truncateSingleLineText(text, textStyle, width, height, 1, getTextDimension)];\n\n  const lineHeight = getTextDimension(REPRESENTATIVE_TEXT, textStyle).width;\n  const dims = lines.map((line) => getTextDimension(line, textStyle));\n\n  const didNotFit = lines.every((line) => line === '');\n\n  const maxWidth = Math.max(\n    ...dims.map((dim) => {\n      return dim.width;\n    })\n  );\n\n  return {\n    lines,\n    dims,\n    didNotFit,\n    height: lines.length * lineHeight,\n    width: maxWidth,\n    isMultiline: lines.length > 1,\n    lineHeight,\n    isTruncated: endsWithEllipsis(lines)\n  };\n}\n"],"names":[],"mappings":"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"}