{"version":3,"file":"UNSAFE_DrawerLayout.js","sources":["../../src/UNSAFE_DrawerLayout/DrawerLayout.tsx"],"sourcesContent":["import { JSX, ComponentChildren, RefObject } from 'preact';\nimport { useState, useRef, useEffect, useCallback } from 'preact/hooks';\nimport { normalizePosition } from '../utils/PRIVATE_floatingUtils';\nimport { Floating, ShiftOptions, RtlSide } from '../UNSAFE_Floating';\nimport { Layer } from '../UNSAFE_Layer';\nimport { getAutofocusFocusables, focusOn, focusWithin } from '../utils/PRIVATE_tabbableUtils';\nimport { getClientHints } from '#utils/PRIVATE_clientHints';\n\n// Hooks\nimport { useAnimation } from '../hooks/UNSAFE_useAnimation';\nimport { useUser } from '../hooks/UNSAFE_useUser';\nimport { useTestId, TestIdProps } from '../hooks/UNSAFE_useTestId';\nimport { useBreakpointValues } from '../hooks/UNSAFE_useBreakpointValues';\nimport { useResizeObserver } from '../hooks/UNSAFE_useResizeObserver';\n\n// Style imports\nimport { useComponentTheme } from '../hooks/UNSAFE_useComponentTheme';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { DrawerLayoutStyles } from './themes/DrawerLayoutStyles.css';\nimport { DrawerLayoutRedwoodTheme } from './themes/redwood/DrawerLayoutTheme';\n\n// Types\ntype IntrinsicProps = Pick<JSX.HTMLAttributes<HTMLDivElement>, 'children'>;\ntype Placement = 'start' | 'end' | 'bottom';\ntype Status = 'unmounted' | 'initial' | 'opening' | 'open' | 'closing';\n\ntype OnCloseDetail = {\n  placement: Placement;\n  reason: 'escapeKey';\n};\ntype OnTransitionEndDetail = {\n  placement: Placement;\n  value: boolean;\n};\ntype DisplayMode = 'overlay' | 'reflow';\ntype ResolvedDisplayMode = 'full-overlay' | 'overlay' | 'reflow';\ntype Visibility = 'hidden' | 'visible';\n\ntype Props = IntrinsicProps & {\n  /**\n   * The content node to be shown within the Start Drawer\n   */\n  startDrawer?: ComponentChildren;\n  /**\n   * The content node to be shown within the End Drawer\n   */\n  endDrawer?: ComponentChildren;\n  /**\n   * The content node to be shown within the Bottom Drawer\n   */\n  bottomDrawer?: ComponentChildren;\n  /**\n   * Specifies whether Start drawer is open.\n   */\n  isStartOpen?: boolean;\n  /**\n   * Specifies the display mode of the Start drawer.\n   *\n   * Supported values are:\n   * <p><code>overlay</code>, <code>reflow</code></p>\n   * Default is <code>undefined</code>.\n   */\n  startDisplay?: DisplayMode;\n  /**\n   * Specifies whether End drawer is open.\n   */\n  isEndOpen?: boolean;\n  /**\n   * Specifies the display mode of the End drawer.\n   *\n   * Supported values are:\n   * <p><code>overlay</code>, <code>reflow</code></p>\n   * Default is <code>undefined</code>.\n   */\n  endDisplay?: DisplayMode;\n  /**\n   * Specifies whether Bottom drawer is open.\n   */\n  isBottomOpen?: boolean;\n  /**\n   * Specifies the display mode of the Bottom drawer.\n   *\n   * Supported values are:\n   * <p><code>overlay</code>, <code>reflow</code></p>\n   * Default is <code>undefined</code>.\n   */\n  bottomDisplay?: DisplayMode;\n  /**\n   * Specifies callback triggered when a user tries to close a Drawer through UI interaction.\n   * The parent should listen to this event and close the Drawer. If the parent fails to remove\n   * the Popup, then no change will be done in the UI by the component.\n   *\n   * Supported detail values are:\n   * <p><code>placement: start | end | bottom</code></p>\n   * <p><code>reason: escapeKey</code></p>\n   */\n  onClose?: (detail: OnCloseDetail) => void;\n  /**\n   * Specifies callback triggered after the animation ends.\n   *\n   * Supported detail values are:\n   * <p><code>placement: start | end | bottom</code></p>\n   * <p><code>value: boolean</code></p>\n   */\n  onTransitionEnd?: (detail: OnTransitionEndDetail) => void;\n} & TestIdProps;\n\n/**\n * A drawer layout adds expandable side contents (drawers) alongside some primary content.\n *\n * These drawers automatically swap 'reflow' and 'overlay' display mode based on width of the page and can be placed at the 'start', 'end' or 'bottom' edge.\n */\nexport const DrawerLayout = ({\n  children,\n  startDrawer,\n  endDrawer,\n  bottomDrawer,\n  isStartOpen = false,\n  isEndOpen = false,\n  isBottomOpen = false,\n  startDisplay,\n  endDisplay,\n  bottomDisplay,\n  onClose,\n  onTransitionEnd,\n  testId // ...props\n}: Props) => {\n  // Constants\n  const zeroPx = '0px';\n  const duration = 250;\n  const verticalBreakpoint = 600;\n  const stringStart = 'start';\n  const stringEnd = 'end';\n  const stringBottom = 'bottom';\n  const stringInitial = 'initial';\n  const stringOpening = 'opening';\n  const stringOpen = 'open';\n  const stringClosing = 'closing';\n  const stringUnmounted = 'unmounted';\n  const stringFullOverlay = 'full-overlay';\n  const stringOverlay = 'overlay';\n  const stringReflow = 'reflow';\n  const stringHidden = 'hidden';\n  const stringVisible = 'visible';\n\n  // Initialize states\n  const [startDrawerStatus, setStartDrawerStatus] = useState<Status>(\n    isStartOpen ? stringInitial : stringUnmounted\n  );\n  const [endDrawerStatus, setEndDrawerStatus] = useState<Status>(\n    isEndOpen ? stringInitial : stringUnmounted\n  );\n  const [bottomDrawerStatus, setBottomDrawerStatus] = useState<Status>(\n    isBottomOpen ? stringInitial : stringUnmounted\n  );\n  const [startVisibility, setStartVisibility] = useState<Visibility>(stringHidden);\n  const [endVisibility, setEndVisibility] = useState<Visibility>(stringHidden);\n  const [bottomVisibility, setBottomVisibility] = useState<Visibility>(stringHidden);\n\n  const [startOffset, setStartOffset] = useState<number>();\n  const [endOffset, setEndOffset] = useState<number>();\n  const [bottomOffset, setBottomOffset] = useState<number>();\n\n  // Breakpoints:\n  // sm: 0-600px (full-overlay)\n  // md: 600-1024px (overlay)\n  // lg: >1024px (reflow)\n  const displayMode: ResolvedDisplayMode = useBreakpointValues({\n    sm: stringFullOverlay,\n    md: stringOverlay,\n    lg: stringReflow\n  });\n  const [viewportDisplayModeHorizontal, setViewportDisplayModeHorizontal] =\n    useState<ResolvedDisplayMode>(displayMode);\n  const [viewportDisplayModeVertical, setViewportDisplayModeVertical] =\n    useState<ResolvedDisplayMode>(displayMode);\n  useEffect(() => {\n    // Size breakpoint crossed\n    setViewportDisplayModeHorizontal(displayMode);\n  }, [displayMode]);\n\n  // Refs\n  const rootRef = useRef<HTMLDivElement>(null);\n  const centerRef = useRef<HTMLDivElement>(null);\n  const startDrawerRef = useRef<HTMLDivElement>(null);\n  const endDrawerRef = useRef<HTMLDivElement>(null);\n  const bottomDrawerRef = useRef<HTMLDivElement>(null);\n\n  const getElementHeight = (element: HTMLDivElement): number => {\n    return element ? Math.round(element.offsetHeight) : 0;\n  };\n\n  const getElementHeightPx = useCallback((element: HTMLDivElement) => {\n    return `${getElementHeight(element)}px`;\n  }, []);\n\n  const getElementWidth = useCallback((element: HTMLDivElement): number => {\n    return element ? Math.round(element.getBoundingClientRect().width) : 0;\n  }, []);\n\n  const getElementWidthPx = useCallback(\n    (element: HTMLDivElement): string => {\n      return `${getElementWidth(element)}px`;\n    },\n    [getElementWidth]\n  );\n\n  // Normalizing position\n  const { direction } = useUser();\n  const isLtr = direction === 'ltr';\n\n  const getNormalizedPlacement = useCallback(\n    (placement: Placement): RtlSide => {\n      return normalizePosition(placement, direction);\n    },\n    [direction]\n  );\n\n  const getTranslateX = (placement: Placement, ref: any): string => {\n    return `${getNormalizedPlacement(placement) === 'right' ? '' : '-'}${getElementWidthPx(\n      ref.current as HTMLDivElement\n    )}`;\n  };\n\n  const getTranslateY = (ref: any): string => {\n    return getElementHeightPx(ref.current as HTMLDivElement);\n  };\n\n  const isSidePlacement = (placement: Placement): boolean => {\n    return [stringStart, stringEnd].indexOf(placement) > -1;\n  };\n\n  const isBottomPlacement = (placement: Placement): boolean => {\n    return placement === stringBottom;\n  };\n\n  const isAnimationPending = (status: Status): boolean => {\n    return [stringOpening, stringClosing].indexOf(status) > -1;\n  };\n\n  const isDrawerAnimationPending = (placement: Placement): boolean => {\n    switch (placement) {\n      case stringStart:\n        return isAnimationPending(startDrawerStatus);\n      case stringEnd:\n        return isAnimationPending(endDrawerStatus);\n      case stringBottom:\n        return isAnimationPending(bottomDrawerStatus);\n    }\n  };\n\n  const isDrawerOpen = (placement: Placement): boolean => {\n    switch (placement) {\n      case stringStart:\n        return isStartOpen;\n      case stringEnd:\n        return isEndOpen;\n      case stringBottom:\n        return isBottomOpen;\n    }\n  };\n\n  const getDrawerVisibility = (placement: Placement): Visibility => {\n    switch (placement) {\n      case stringStart:\n        return startVisibility;\n      case stringEnd:\n        return endVisibility;\n      case stringBottom:\n        return bottomVisibility;\n    }\n  };\n\n  const setDrawerVisibility = (placement: Placement, visibility: Visibility): void => {\n    switch (placement) {\n      case stringStart:\n        return setStartVisibility(visibility);\n      case stringEnd:\n        return setEndVisibility(visibility);\n      case stringBottom:\n        return setBottomVisibility(visibility);\n    }\n  };\n\n  const getDrawerRef = (placement: Placement) => {\n    switch (placement) {\n      case stringStart:\n        return startDrawerRef;\n      case stringEnd:\n        return endDrawerRef;\n      case stringBottom:\n        return bottomDrawerRef;\n    }\n  };\n\n  const getDrawerEl = (placement: Placement) => {\n    return getDrawerRef(placement).current;\n  };\n\n  const getAnimatedNodeRef = (placement: Placement) => {\n    switch (placement) {\n      case stringStart:\n        return startAnimatedNodeRef;\n      case stringEnd:\n        return endAnimatedNodeRef;\n      case stringBottom:\n        return bottomAnimatedNodeRef;\n    }\n  };\n\n  const getDrawerStatus = (placement: Placement) => {\n    switch (placement) {\n      case stringStart:\n        return startDrawerStatus;\n      case stringEnd:\n        return endDrawerStatus;\n      case stringBottom:\n        return bottomDrawerStatus;\n    }\n  };\n\n  const setDrawerStatus = (placement: Placement, status: Status): void => {\n    switch (placement) {\n      case stringStart:\n        setStartDrawerStatus(status);\n        break;\n      case stringEnd:\n        setEndDrawerStatus(status);\n        break;\n      case stringBottom:\n        setBottomDrawerStatus(status);\n        break;\n    }\n  };\n\n  const resetAnimatedNodeRef = (placement: Placement): void => {\n    switch (placement) {\n      case stringStart:\n        startAnimatedNodeRef(null);\n        break;\n      case stringEnd:\n        endAnimatedNodeRef(null);\n        break;\n      case stringBottom:\n        bottomAnimatedNodeRef(null);\n        break;\n    }\n  };\n\n  const getDrawerDisplayProp = (placement: Placement) => {\n    switch (placement) {\n      case stringStart:\n        return startDisplay;\n      case stringEnd:\n        return endDisplay;\n      case stringBottom:\n        return bottomDisplay;\n    }\n  };\n\n  const getDrawerDisplayMode = (placement: Placement): ResolvedDisplayMode => {\n    const displayProp = getDrawerDisplayProp(placement);\n    if (displayProp) {\n      return displayProp;\n    } else {\n      if (isSidePlacement(placement)) {\n        return viewportDisplayModeHorizontal;\n      }\n      return viewportDisplayModeVertical;\n    }\n  };\n\n  // Animation config\n  const getAnimationStates = (placement: Placement, ref: RefObject<HTMLElement>): any => {\n    const bottomPlacement: boolean = isBottomPlacement(placement);\n    if (getDrawerDisplayMode(placement) === stringReflow) {\n      // Reflow display mode\n      // Effect: Expand/Collapse\n      if (bottomPlacement) {\n        return {\n          opening: () => {\n            return {\n              from: {\n                maxHeight: zeroPx,\n                overflowX: 'hidden'\n              },\n              to: {\n                maxHeight: getElementHeightPx(ref.current as HTMLDivElement),\n                overflowX: 'hidden'\n              },\n              options: {\n                duration: duration\n              }\n            };\n          },\n          closing: () => {\n            return {\n              from: {\n                maxHeight: getElementHeightPx(ref.current as HTMLDivElement)\n              },\n              to: {\n                maxHeight: zeroPx,\n                overflowX: 'hidden'\n              },\n              options: {\n                duration: duration\n              }\n            };\n          }\n        };\n      } else {\n        return {\n          opening: () => {\n            return {\n              from: {\n                maxWidth: zeroPx,\n                overflowY: 'hidden'\n              },\n              to: {\n                maxWidth: getElementWidthPx(ref.current as HTMLDivElement),\n                overflowY: 'hidden'\n              },\n              options: {\n                duration: duration\n              }\n            };\n          },\n          closing: () => {\n            return {\n              from: {\n                maxWidth: getElementWidthPx(ref.current as HTMLDivElement)\n              },\n              to: {\n                maxWidth: zeroPx,\n                overflowY: 'hidden'\n              },\n              options: {\n                duration: duration\n              }\n            };\n          }\n        };\n      }\n    } else {\n      // FullOverlay or Overlay display mode\n      // Effect: Slidein/Slideout\n      if (bottomPlacement) {\n        return {\n          opening: () => {\n            return {\n              from: {\n                translateY: getTranslateY(ref)\n              },\n              to: {\n                translateY: zeroPx\n              },\n              options: {\n                duration: duration\n              }\n            };\n          },\n          closing: () => {\n            return {\n              from: {\n                translateY: zeroPx\n              },\n              to: {\n                translateY: getTranslateY(ref)\n              },\n              options: {\n                duration: duration\n              }\n            };\n          }\n        };\n      } else {\n        return {\n          opening: () => {\n            return {\n              from: {\n                translateX: getTranslateX(placement, ref)\n              },\n              to: {\n                translateX: zeroPx\n              },\n              options: {\n                duration: duration\n              }\n            };\n          },\n          closing: () => {\n            return {\n              from: {\n                translateX: zeroPx\n              },\n              to: {\n                translateX: getTranslateX(placement, ref)\n              },\n              options: {\n                duration: duration\n              }\n            };\n          }\n        };\n      }\n    }\n  };\n\n  const handleFocus = (placement: Placement) => {\n    // Set focus to the first match:\n    const drawerRef: RefObject<any> = getDrawerRef(placement);\n\n    // 1. First element inside the drawer matching [autofocus]\n    const autofocusItems: HTMLElement[] = getAutofocusFocusables(drawerRef.current);\n    if (autofocusItems.length > 0) {\n      focusOn(autofocusItems[0]);\n      return;\n    }\n    // 2. Tabbable element inside the content element\n    // 3. The drawer itself\n    focusWithin(drawerRef.current);\n  };\n\n  // Custom hook to be shared for each side\n  // It can't be a function as a hook can only be called within a custom hook\n  function useNodeRef(placement: Placement, ref: RefObject<HTMLElement>) {\n    const isOpen: boolean = isDrawerOpen(placement);\n    const status = getDrawerStatus(placement);\n    return useAnimation<Status, HTMLDivElement>(status, {\n      animationStates: getAnimationStates(placement, ref),\n      isAnimatedOnMount: true,\n      onAnimationEnd: () => {\n        if (status === stringOpening) {\n          setDrawerStatus(placement, stringOpen);\n          handleFocus(placement);\n          onTransitionEnd?.({\n            placement: placement,\n            value: true\n          });\n        } else if (!isOpen) {\n          resetAnimatedNodeRef(placement);\n          setDrawerVisibility(placement, stringHidden);\n          setDrawerStatus(placement, stringUnmounted);\n          onTransitionEnd?.({\n            placement: placement,\n            value: false\n          });\n        }\n      }\n    }).nodeRef;\n  }\n\n  // Drawer refs\n  const startAnimatedNodeRef = useNodeRef(stringStart, startDrawerRef);\n  const endAnimatedNodeRef = useNodeRef(stringEnd, endDrawerRef);\n  const bottomAnimatedNodeRef = useNodeRef(stringBottom, bottomDrawerRef);\n\n  //testId support\n  const testIdProps = useTestId(testId);\n\n  // Custom hook to be shared for each side\n  // It can't be a function as a hook can only be called within a custom hook\n  function useDrawerStatus(placement: Placement): void {\n    const isOpen = isDrawerOpen(placement);\n    const drawerStatus = getDrawerStatus(placement);\n    useEffect(() => {\n      // Ignore initial render\n      // 1. Ignore status update on initial render\n      if (drawerStatus === stringUnmounted && !isOpen) {\n        return;\n      }\n\n      // 2. Unmounted\n      // Mount visually hidden component.\n      // Component gets mounted, but will be visually hidden to avoid flickering.\n      // Flickering happens because it gets rendered before animation hook repositions\n      // it in next render cycle\n      if (drawerStatus === stringUnmounted && isOpen) {\n        setDrawerStatus(placement, stringInitial);\n        return;\n      }\n\n      // 3. Initial\n      // Setup animation\n      // Component has been mounted.\n      // We will kick out animation as node is already present in DOM.\n      // To avoid flickering, we still keep it visually hidden until the next render cycle.\n      if (drawerStatus === stringInitial && isOpen) {\n        const drawerRef = getDrawerRef(placement);\n        const animatedNodeRef = getAnimatedNodeRef(placement);\n        animatedNodeRef(drawerRef.current);\n        setDrawerStatus(placement, stringOpening);\n        return;\n      }\n\n      // 4. Opening\n      // Unhide component. It becomes visible.\n      if (drawerStatus === stringOpening && isOpen) {\n        setDrawerVisibility(placement, stringVisible);\n        return;\n      }\n\n      // 5. Open\n      // Status 'open' is set in 'onAnimationEnd' handler\n\n      // 6. Closing\n      if (!isOpen) {\n        setDrawerStatus(placement, stringClosing);\n      }\n    }, [isOpen, drawerStatus, placement]);\n  }\n\n  // Drawers' status handler±\n  useDrawerStatus(stringStart);\n  useDrawerStatus(stringEnd);\n  useDrawerStatus(stringBottom);\n\n  // Keydown handlers\n  const handleKeyDownStart = (event: Event): void => {\n    handleKeyDown(stringStart, event);\n  };\n  const handleKeyDownEnd = (event: Event): void => {\n    handleKeyDown(stringEnd, event);\n  };\n  const handleKeyDownBottom = (event: Event): void => {\n    handleKeyDown(stringBottom, event);\n  };\n\n  const handleKeyDown = (placement: Placement, event: any): void => {\n    if (event.code === 'Escape') {\n      // Handle only in overlay mode\n      if (isOverlay(placement)) {\n        onClose?.({\n          placement,\n          reason: 'escapeKey'\n        });\n      }\n    }\n  };\n\n  // Styles\n  const { classes, styles } = useComponentTheme<never, DrawerLayoutStyles>(\n    DrawerLayoutRedwoodTheme\n  );\n\n  const getVisibilityClass = (visibility: Visibility) => {\n    return visibility === stringHidden ? styles.visibilityHidden : styles.visibilityVisible;\n  };\n\n  const isOverlay = (placement: Placement) => {\n    return [stringFullOverlay, stringOverlay].indexOf(getDrawerDisplayMode(placement)) > -1;\n  };\n\n  const isFullOverlay = (placement: Placement): boolean => {\n    return getDrawerDisplayMode(placement) === stringFullOverlay;\n  };\n\n  const getDrawerClassNames = (placement: Placement): string => {\n    // Visibility style is always added\n    const visibility: Visibility = getDrawerVisibility(placement);\n    const classNamesArr: string[] = [getVisibilityClass(visibility)];\n\n    // Styles for overlay vs. full-overlay vs. reflow\n    if (isOverlay(placement)) {\n      classNamesArr.push(styles.overlayDrawer);\n      if (isSidePlacement(placement) && !isFullOverlay(placement)) {\n        classNamesArr.push(styles.overlaySideDrawerNonFullWidth);\n      }\n    } else {\n      classNamesArr.push(styles.reflowDrawer);\n    }\n\n    // Styles for animation\n    if (isDrawerAnimationPending(placement)) {\n      classNamesArr.push(styles.animatedDrawer);\n    }\n\n    const getPlacementSpecificStyles = (placement: Placement): string => {\n      switch (placement) {\n        case stringStart:\n          if (isOverlay(stringStart)) {\n            return isLtr ? styles.overlayDrawerLeft : styles.overlayDrawerRight;\n          } else {\n            return isLtr ? styles.reflowDrawerLeft : styles.reflowDrawerRight;\n          }\n        case stringEnd:\n          if (isOverlay(stringEnd)) {\n            return isLtr ? styles.overlayDrawerRight : styles.overlayDrawerLeft;\n          } else {\n            return isLtr ? styles.reflowDrawerRight : styles.reflowDrawerLeft;\n          }\n        case stringBottom:\n          return isOverlay(stringBottom) ? styles.overlayDrawerBottom : styles.reflowDrawerBottom;\n      }\n    };\n    // Placement specific styles\n    classNamesArr.push(getPlacementSpecificStyles(placement));\n\n    return classNames(classNamesArr);\n  };\n\n  const getDrawerProp = (placement: Placement) => {\n    switch (placement) {\n      case stringStart:\n        return startDrawer;\n      case stringEnd:\n        return endDrawer;\n      case stringBottom:\n        return bottomDrawer;\n    }\n  };\n\n  const getKeyDownHandler = (placement: Placement) => {\n    switch (placement) {\n      case stringStart:\n        return handleKeyDownStart;\n      case stringEnd:\n        return handleKeyDownEnd;\n      case stringBottom:\n        return handleKeyDownBottom;\n    }\n  };\n\n  // Single drawer template\n  const renderDrawer = (placement: Placement) => {\n    return (\n      <div\n        ref={getDrawerRef(placement)}\n        className={getDrawerClassNames(placement)}\n        tabIndex={isOverlay(placement) ? -1 : undefined}\n        onKeyDown={getKeyDownHandler(placement)}>\n        {getDrawerProp(placement)}\n      </div>\n    );\n  };\n\n  const clientHints = getClientHints();\n\n  const getViewportHeight = useCallback((): number => {\n    if (clientHints.platform === 'ios') {\n      // On ios window.innerHeight is not recommended way of measuring the viewport\n      return document.documentElement.clientHeight;\n    }\n    return window.innerHeight;\n  }, [clientHints.platform]);\n\n  const handleVerticalResize = useCallback(() => {\n    const viewportHeight = getViewportHeight();\n    if (viewportHeight >= verticalBreakpoint) {\n      if (viewportDisplayModeVertical != stringReflow) {\n        setViewportDisplayModeVertical(stringReflow);\n      }\n    } else {\n      if (viewportDisplayModeVertical != stringOverlay) {\n        setViewportDisplayModeVertical(stringOverlay);\n      }\n    }\n  }, [viewportDisplayModeVertical, getViewportHeight]);\n\n  // Window resize listener\n  // useBreakpoint hook is designed for horizontal breakpoints only\n  // This listener is used for 600px (overlay vs. reflow) breakpoint\n  // used for bottom drawer\n  useEffect(() => {\n    const resizeObserver = new ResizeObserver(() => {\n      handleVerticalResize();\n    });\n    resizeObserver.observe(document.body);\n    // Deregister resize observer when Drawer layout unmounts\n    return () => {\n      resizeObserver.unobserve(document.body);\n    };\n  }, [handleVerticalResize]);\n\n  const getOffset = (placement: Placement): number => {\n    const drawerEl = getDrawerEl(placement);\n    if (drawerEl) {\n      return isSidePlacement(placement) ? -getElementWidth(drawerEl) : -getElementHeight(drawerEl);\n    }\n    return 0;\n  };\n\n  const getOffsetState = (placement: Placement) => {\n    switch (placement) {\n      case stringStart:\n        return startOffset;\n      case stringEnd:\n        return endOffset;\n      case stringBottom:\n        return bottomOffset;\n    }\n  };\n\n  const setSideOverlayDrawerFullHeight = useCallback(\n    (placement: Placement) => {\n      // By default PopupElements have no predefined height.\n      // In 'overlay' mode drawers should be\n      // of the same height as their parent <oj-drawer-layout>\n      const centerSectionHeight = getElementHeightPx(centerRef.current as HTMLDivElement);\n\n      const drawerEl = getDrawerRef(placement).current;\n      if (drawerEl && isDrawerOpen(placement) && isOverlay(placement)) {\n        drawerEl.style.height = centerSectionHeight;\n      }\n    },\n    [getElementHeightPx, isDrawerOpen, isOverlay]\n  );\n\n  const handleSideDrawerFullWidth = (placement: Placement) => {\n    const drawerEl = getDrawerRef(placement).current;\n    if (drawerEl) {\n      if (isDrawerOpen(placement)) {\n        const drawerInlineStyle = drawerEl.style;\n        if (isFullOverlay(placement)) {\n          drawerInlineStyle.width = getElementWidthPx(rootRef.current as HTMLDivElement);\n        } else {\n          drawerInlineStyle.removeProperty('width');\n        }\n      }\n    }\n  };\n\n  const setBottomOverlayDrawerWidth = useCallback(() => {\n    const bottomDrawerElement = bottomDrawerRef.current;\n    if (bottomDrawerElement && isDrawerOpen(stringBottom) && isOverlay(stringBottom)) {\n      const centerSectionWidth = getElementWidthPx(centerRef.current as HTMLDivElement);\n      bottomDrawerElement.style.width = centerSectionWidth;\n    }\n  }, [getElementWidthPx, isDrawerOpen, isOverlay]);\n\n  const setDrawerSize = (placement: Placement) => {\n    if (isSidePlacement(placement)) {\n      setSideOverlayDrawerFullHeight(placement);\n      handleSideDrawerFullWidth(placement);\n    }\n    if (isBottomPlacement(placement)) {\n      setBottomOverlayDrawerWidth();\n    }\n  };\n\n  const handleDrawerLayoutResize = useCallback(() => {\n    // If the DrawerLayout (page content) changes size,\n    // adjust OVERLAY side drawers (start/end) height to fit the drawer\n    // Note that these two functions checks that 'overlay' condition is fulfilled\n    setSideOverlayDrawerFullHeight(stringStart);\n    setSideOverlayDrawerFullHeight(stringEnd);\n    setBottomOverlayDrawerWidth();\n  }, [setSideOverlayDrawerFullHeight, setBottomOverlayDrawerWidth]);\n  // DrawerLayout resize observer\n  useResizeObserver(rootRef, handleDrawerLayoutResize);\n\n  const setOffsetState = (placement: Placement) => {\n    const offset = getOffset(placement);\n    switch (placement) {\n      case stringStart:\n        setStartOffset(offset);\n        break;\n      case stringEnd:\n        setEndOffset(offset);\n        break;\n      case stringBottom:\n        setBottomOffset(offset);\n        break;\n    }\n  };\n\n  // Start drawer resize observer\n  const handleStartDrawerResize = () => {\n    setOffsetState(stringStart);\n  };\n  useResizeObserver(startDrawerRef, handleStartDrawerResize);\n\n  // End drawer resize observer\n  const handleEndDrawerResize = () => {\n    setOffsetState(stringEnd);\n  };\n  useResizeObserver(endDrawerRef, handleEndDrawerResize);\n\n  // Bottom drawer resize observer\n  const handleBottomDrawerResize = () => {\n    setOffsetState(stringBottom);\n  };\n  useResizeObserver(bottomDrawerRef, handleBottomDrawerResize);\n\n  const getReflowOrOverlayDrawer = (placement: Placement) => {\n    const shiftOptions: ShiftOptions = {\n      mainAxis: false,\n      crossAxis: false\n    };\n\n    const flipOptions = {\n      mainAxis: false,\n      crossAxis: false\n    };\n\n    // Reflow vs. overlay drawer\n    if (isOverlay(placement)) {\n      setDrawerSize(placement);\n\n      // Initial offset\n      if (!getOffsetState(placement)) {\n        setOffsetState(placement);\n      }\n\n      return (\n        // Reconciliation issue. Reparented node must\n        // be a single child of a <div>\n        <div>\n          <Layer>\n            <Floating\n              anchorRef={placement === stringBottom ? centerRef : rootRef}\n              placement={placement}\n              class={isDrawerAnimationPending(placement) ? styles.floating : ''}\n              offsetValue={getOffsetState(placement)}\n              flipOptions={flipOptions}\n              shiftOptions={shiftOptions}>\n              {renderDrawer(placement)}\n            </Floating>\n          </Layer>\n        </div>\n      );\n    } else {\n      return renderDrawer(placement);\n    }\n  };\n\n  // Render drawer conditionally\n  const getDrawer = (placement: Placement): any => {\n    const isMounted = getDrawerStatus(placement) !== stringUnmounted;\n    return isMounted ? getReflowOrOverlayDrawer(placement) : null;\n  };\n\n  return (\n    <div ref={rootRef} className={classes} {...testIdProps}>\n      {/*Start drawer*/}\n      {getDrawer(stringStart)}\n      {/*Center section*/}\n      <div ref={centerRef} className={styles.centerSection}>\n        <div className={styles.mainContent}>\n          {/*<main content*/}\n          {children}\n        </div>\n        {/*Bottom drawer*/}\n        {getDrawer(stringBottom)}\n      </div>\n      {/*End drawer*/}\n      {getDrawer(stringEnd)}\n    </div>\n  );\n};\n"],"names":["children","startDrawer","endDrawer","bottomDrawer","isStartOpen","isEndOpen","isBottomOpen","startDisplay","endDisplay","bottomDisplay","onClose","onTransitionEnd","testId","zeroPx","duration","stringStart","stringEnd","stringBottom","stringInitial","stringOpening","stringClosing","stringUnmounted","stringFullOverlay","stringOverlay","stringReflow","stringHidden","startDrawerStatus","setStartDrawerStatus","useState","endDrawerStatus","setEndDrawerStatus","bottomDrawerStatus","setBottomDrawerStatus","startVisibility","setStartVisibility","endVisibility","setEndVisibility","bottomVisibility","setBottomVisibility","startOffset","setStartOffset","endOffset","setEndOffset","bottomOffset","setBottomOffset","displayMode","useBreakpointValues","sm","md","lg","viewportDisplayModeHorizontal","setViewportDisplayModeHorizontal","viewportDisplayModeVertical","setViewportDisplayModeVertical","useEffect","rootRef","useRef","centerRef","startDrawerRef","endDrawerRef","bottomDrawerRef","getElementHeight","element","Math","round","offsetHeight","getElementHeightPx","useCallback","getElementWidth","getBoundingClientRect","width","getElementWidthPx","direction","useUser","isLtr","getNormalizedPlacement","placement","normalizePosition","getTranslateX","ref","current","getTranslateY","isSidePlacement","indexOf","isBottomPlacement","isAnimationPending","status","isDrawerAnimationPending","isDrawerOpen","setDrawerVisibility","visibility","getDrawerRef","getDrawerStatus","setDrawerStatus","getDrawerDisplayMode","displayProp","getDrawerDisplayProp","getAnimationStates","bottomPlacement","opening","from","maxHeight","overflowX","to","options","closing","maxWidth","overflowY","translateY","translateX","useNodeRef","isOpen","useAnimation","animationStates","isAnimatedOnMount","onAnimationEnd","drawerRef","autofocusItems","getAutofocusFocusables","length","focusOn","focusWithin","handleFocus","value","startAnimatedNodeRef","endAnimatedNodeRef","bottomAnimatedNodeRef","resetAnimatedNodeRef","nodeRef","testIdProps","useTestId","useDrawerStatus","drawerStatus","animatedNodeRef","getAnimatedNodeRef","handleKeyDownStart","event","handleKeyDown","handleKeyDownEnd","handleKeyDownBottom","code","isOverlay","reason","classes","styles","useComponentTheme","DrawerLayoutRedwoodTheme","getVisibilityClass","visibilityHidden","visibilityVisible","isFullOverlay","getDrawerClassNames","getDrawerVisibility","classNamesArr","push","overlayDrawer","overlaySideDrawerNonFullWidth","reflowDrawer","animatedDrawer","overlayDrawerLeft","overlayDrawerRight","reflowDrawerLeft","reflowDrawerRight","overlayDrawerBottom","reflowDrawerBottom","getPlacementSpecificStyles","classNames","getDrawerProp","getKeyDownHandler","renderDrawer","_jsx","className","tabIndex","undefined","onKeyDown","clientHints","getClientHints","getViewportHeight","platform","document","documentElement","clientHeight","window","innerHeight","handleVerticalResize","resizeObserver","ResizeObserver","observe","body","unobserve","getOffset","drawerEl","getDrawerEl","getOffsetState","setSideOverlayDrawerFullHeight","centerSectionHeight","style","height","setBottomOverlayDrawerWidth","bottomDrawerElement","centerSectionWidth","setDrawerSize","drawerInlineStyle","removeProperty","handleSideDrawerFullWidth","handleDrawerLayoutResize","useResizeObserver","setOffsetState","offset","getDrawer","shiftOptions","mainAxis","crossAxis","flipOptions","jsx","Layer","Floating","anchorRef","class","floating","offsetValue","getReflowOrOverlayDrawer","_jsxs","jsxs","centerSection","mainContent"],"mappings":"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"}