{"version":3,"file":"FocusTrap-0a03f5a2.js","sources":["../../src/UNSAFE_FocusTrap/FocusTrap.tsx"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { ComponentChildren, RefObject } from 'preact';\nimport { useCallback, useRef } from 'preact/compat';\nimport { FocusableElement, focusOn, isTabbableElement } from '../utils/PRIVATE_tabbableUtils';\nimport { FocusTracker } from '../PRIVATE_FocusTracker';\n\ntype Props = {\n  children: ComponentChildren;\n  /**\n   * Optional Ref to an element to focus on when component mounts\n   * @default - undefined - behavior is to focus on first tabbableElement\n   */\n  autoFocusRef?: RefObject<HTMLElement | null>;\n\n  /**\n   * Sets whether focus is managed and whether guards are present\n   * @default false\n   */\n  isDisabled?: boolean;\n\n  /**\n   * Why a isDisabled prop as compared to ONLY supporting conditional rendering?\n   *\n   *   1) We need an actual HTML Element for the trap, conditional rendering an element potentially breaks consumer CSS\n   *   2) Conditional rendering can short-circuit event bubbling in preact and lead to expected events not bubbling.\n   */\n\n  /**\n   * Optional Ref to element to focus on when component un-mounts, false to disable.\n   * @default - undefined - behavior is to focus on the original activeElement when focus trap was enabled\n   */\n  restoreFocusRef?: RefObject<HTMLElement> | false;\n};\n\n/**\n * Trap focus within a DOM node.  When a user hits Tab or Shift+Tab, focus remains in the focus trap.\n */\nexport const FocusTrap = ({\n  autoFocusRef,\n  children,\n  isDisabled = false,\n  restoreFocusRef\n}: Props) => {\n  const originalActiveElementRef = useRef<FocusableElement | null>(null);\n  const lastActiveElementRef = useRef<FocusableElement | null>(null);\n\n  /**\n   * contain focus if trap is enabled, and target is not already contained\n   *\n   * calling cases for side-effect of setting focus\n   *   - on initial mount of (enabled) trap, where target is not inside trap\n   *   - on enabling of a disabled trap, where target is not inside trap\n   *   - target of click event is outside of trap.\n   */\n  const conditionallyContainFocus = useCallback(\n    (\n      hasFocusWithin: boolean,\n      currentActiveElement: FocusableElement | null,\n      tabbableElements: FocusableElement[]\n    ) => {\n      //  short-circuit, currentActiveElement not valid\n      if (isDisabled || !currentActiveElement) return;\n\n      // just update ref if currentActiveElement is a child of the tracker\n      if (hasFocusWithin) {\n        lastActiveElementRef.current = currentActiveElement;\n        return;\n      }\n\n      // set focus to last active tab-stop if lastElement is defined and inside trap\n      if (lastActiveElementRef.current) {\n        focusOn(lastActiveElementRef.current);\n      } else if (tabbableElements.length > 0) {\n        // otherwise just contain focus within trap as target is outside enabled trap and we have no last-known tab-stop\n        focusOn(tabbableElements[0]);\n      }\n    },\n    [isDisabled]\n  );\n\n  // loop focus from start edge\n  const handleFocusStartEdge = useCallback((detail: { tabbableElements: FocusableElement[] }) => {\n    const tabbableCount = detail.tabbableElements.length;\n    if (tabbableCount > 0) {\n      focusOn(detail.tabbableElements[tabbableCount - 1]);\n    }\n  }, []);\n\n  // loop focus from end edge\n  const handleFocusEndEdge = useCallback((detail: { tabbableElements: FocusableElement[] }) => {\n    const tabbableCount = detail.tabbableElements.length;\n    if (tabbableCount > 0) {\n      focusOn(detail.tabbableElements[0]);\n    }\n  }, []);\n\n  // handle enable case and initial render\n  const handleStartTracking = useCallback(\n    (detail: {\n      activeElement: FocusableElement;\n      hasFocusWithin: boolean;\n      tabbableElements: FocusableElement[];\n    }) => {\n      originalActiveElementRef.current = detail.activeElement;\n\n      // init focus\n      if (autoFocusRef && autoFocusRef.current) {\n        focusOn(autoFocusRef.current);\n      } else {\n        conditionallyContainFocus(\n          detail.hasFocusWithin,\n          detail.activeElement,\n          detail.tabbableElements\n        );\n      }\n    },\n    [autoFocusRef, conditionallyContainFocus]\n  );\n\n  // handle disable case\n  const handleStopTracking = useCallback(\n    (detail: { hasFocusWithin: boolean; lastActiveElement: FocusableElement | null }) => {\n      lastActiveElementRef.current = detail.lastActiveElement;\n      if (restoreFocusRef !== false) {\n        restoreFocusForCleanup(restoreFocusRef?.current || originalActiveElementRef.current);\n      }\n    },\n    [restoreFocusRef]\n  );\n\n  return (\n    <FocusTracker\n      isDisabled={isDisabled}\n      onStartTracking={handleStartTracking}\n      onStopTracking={handleStopTracking}\n      onFocusStartEdge={handleFocusStartEdge}\n      onFocusEndEdge={handleFocusEndEdge}>\n      {children}\n    </FocusTracker>\n  );\n};\n\n// setTimeout ensures that unmount lifecycle has completed\nconst restoreFocusForCleanup = (element: FocusableElement | null) => {\n  if (element && isTabbableElement(element)) {\n    setTimeout(() => {\n      focusOn(element);\n    }, 0);\n  }\n};\n"],"names":["useRef","useCallback","focusOn","_jsx","FocusTracker","isTabbableElement"],"mappings":"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"}