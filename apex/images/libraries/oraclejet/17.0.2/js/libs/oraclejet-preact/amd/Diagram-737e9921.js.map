{"version":3,"file":"Diagram-737e9921.js","sources":["../../src/UNSAFE_Diagram/utils/diagramUtils.ts","../../src/UNSAFE_Diagram/DiagramNodeElement.tsx","../../src/UNSAFE_Diagram/DiagramNodeLayer.tsx","../../src/UNSAFE_Diagram/DiagramLinkElement.tsx","../../src/UNSAFE_Diagram/DiagramLinkLayer.tsx","../../src/UNSAFE_Diagram/DiagramLabel.tsx","../../src/UNSAFE_Diagram/DiagramLabelLayer.tsx","../../src/UNSAFE_Diagram/DiagramLayers.tsx","../../src/UNSAFE_Diagram/DiagramPanZoomContainer.tsx","../../src/UNSAFE_Diagram/utils/navUtils.ts","../../src/UNSAFE_Diagram/hooks/useDiagramNavigation.ts","../../src/UNSAFE_Diagram/hooks/useEvents.ts","../../src/UNSAFE_Diagram/hooks/useDiagramDatatip.ts","../../src/UNSAFE_Diagram/hooks/usePointerGesture.ts","../../src/UNSAFE_Diagram/utils/panUtils.ts","../../src/UNSAFE_Diagram/hooks/useDragPan.ts","../../src/UNSAFE_Diagram/hooks/useDrag.ts","../../src/UNSAFE_Diagram/utils/zoomUtils.ts","../../src/UNSAFE_Diagram/hooks/usePinch.ts","../../src/UNSAFE_Diagram/hooks/usePinchZoom.ts","../../src/UNSAFE_Diagram/hooks/usePanZoom.ts","../../src/UNSAFE_Diagram/hooks/useWheelZoom.ts","../../src/UNSAFE_Diagram/hooks/useWheel.ts","../../src/UNSAFE_Diagram/DiagramWithDimensions.tsx","../../src/UNSAFE_Diagram/hooks/useDiagramSelection.ts","../../src/UNSAFE_Diagram/Diagram.tsx"],"sourcesContent":["import type {\n  Pan,\n  Zoom,\n  DiagramNodeData,\n  DiagramLinkData,\n  DiagramLayoutOutput,\n  ItemInfo,\n  Bounds,\n  Position,\n  Dimensions,\n  DatatipContext,\n  DiagramLabelStyles,\n  DiagramLabelPosition\n} from '../diagram.types';\nimport type { Ref } from 'preact/hooks';\nimport type { BundleType } from '../../resources/nls/bundle';\nimport type {\n  Font,\n  GetTextDimensionsType,\n  TextDimensions\n} from '../../hooks/PRIVATE_useTextDimensions';\nimport { ComponentChildren } from 'preact';\nimport { Property } from 'csstype';\nimport { generateAriaLabel } from '#utils/UNSAFE_visUtils/accUtils';\n\nconst ZOOM_TO_FIT_PADDING = 20;\n/**\n * Returns the pan properties for the diagram.\n */\nexport function getPanProps(props: Pan, contentBounds: Bounds) {\n  return {\n    panning: props.panning ? props.panning : 'off',\n    panDirection: props.panDirection ? props.panDirection : 'any',\n    centerX: props.centerX !== undefined ? props.centerX : contentBounds.w / 2 + contentBounds.x,\n    centerY: props.centerY !== undefined ? props.centerY : contentBounds.h / 2 + contentBounds.y,\n    onPan: props.onPan\n  };\n}\n\n/**\n * Returns the zoom properties for the diagram.\n */\nexport function getZoomProps(props: Zoom, width: number, height: number, contentBounds: Bounds) {\n  const minZoom = props.minZoom ? props.minZoom : getZoomToFitZoom(width, height, contentBounds);\n  const maxZoom = props.maxZoom !== undefined ? props.maxZoom : 1;\n  const zoom = props.zoomValue ? props.zoomValue : getZoomToFitZoom(width, height, contentBounds);\n  return {\n    zooming: props.zooming ? props.zooming : 'off',\n    // default value of 0 indicates zoom-to-fit level\n    minZoom: minZoom,\n    maxZoom: maxZoom,\n    // zoom value of 0 will default to zoom to fit\n    zoomValue: constrainZoom(zoom, minZoom, maxZoom),\n    onZoom: props.onZoom\n  };\n}\n\n/**\n * Constructs the json object to be passed into the layout function\n */\nexport function constructLayoutJSON<\n  K1,\n  K2,\n  D1 extends DiagramNodeData<K1>,\n  D2 extends DiagramLinkData<K2, K1>\n>(\n  nodes: D1[],\n  nodeItems: Map<K1, D1>,\n  linkItems: Map<K2, D2>,\n  dimensions: Dimensions[],\n  width: number,\n  height: number,\n  getTextDimensions?: GetTextDimensionsType\n) {\n  const labelDims: Map<K1 | K2, TextDimensions> = new Map();\n  const nodeKeys = Array.from(nodeItems.keys());\n  for (const id of nodeKeys) {\n    const item = nodeItems.get(id as K1);\n    if (item && getTextDimensions && item.label) {\n      const label = item.label;\n      const fontProps = _getFontProps(item.labelStyle);\n      labelDims.set(id as K1 | K2, getTextDimensions(label, fontProps));\n    }\n  }\n  const linkKeys = Array.from(linkItems.keys());\n  for (const id of linkKeys) {\n    const item = linkItems.get(id as K2);\n    if (item && getTextDimensions && item.label) {\n      const label = item.label;\n      const fontProps = _getFontProps(item.labelStyle);\n      labelDims.set(id as K1 | K2, getTextDimensions(label, fontProps));\n    }\n  }\n  const getLabelDimensions = function (data: D1 | D2) {\n    return labelDims.get(data.id);\n  };\n  const getNodeDimensions = function (data: D1) {\n    for (let i = 0; i < nodes.length; i++) {\n      if (data.id === nodes[i].id) {\n        return dimensions[i];\n      }\n    }\n    return dimensions[0];\n  };\n\n  return {\n    layoutJSON: {\n      getNodeDimensions: getNodeDimensions,\n      getLabelDimensions: getLabelDimensions,\n      componentSize: {\n        width: width,\n        height: height\n      }\n    },\n    labelDims: labelDims\n  };\n}\n\n/**\n * Deconstructs the output of the layout function\n */\nexport function deconstructLayoutJSON<\n  K1,\n  K2,\n  D1 extends DiagramNodeData<K1>,\n  D2 extends DiagramLinkData<K2, K1>\n>(layoutJSON: DiagramLayoutOutput, nodeData: D1[], linkData: D2[]) {\n  const nodes = layoutJSON.nodes;\n  const links = layoutJSON.links;\n  const positions: Position[] = [];\n  const nodeLabelPos: (DiagramLabelPosition | undefined)[] = [];\n  const linkLabelPos: DiagramLabelPosition[] = [];\n  let hasNodeLabels = false;\n  let hasLinkLabels = false;\n  let node, link;\n  for (let i = 0; i < nodeData.length; i++) {\n    node = nodes[nodeData[i].id as string | number];\n    positions.push(node.position);\n    if (node.label) hasNodeLabels = true;\n    nodeLabelPos.push(node.label);\n  }\n  if (links) {\n    for (let i = 0; i < linkData.length; i++) {\n      link = links[linkData[i].id as string | number];\n      if (link.label) hasLinkLabels = true;\n      linkLabelPos.push(link.label);\n    }\n  }\n  return {\n    nodePoints: positions,\n    nodeLabelPos: hasNodeLabels ? nodeLabelPos : undefined,\n    linkLabelPos: hasLinkLabels ? linkLabelPos : undefined\n  };\n}\n\n/**\n * Merges the node points into the dimensions\n */\nexport function mergeDimensions(dimensions: Dimensions[], nodePoints: Position[]) {\n  const newBounds: Bounds[] = [];\n  for (let i = 0; i < dimensions.length; i++) {\n    const point = nodePoints[i];\n    const dim = dimensions[i];\n    newBounds.push({ x: point.x, y: point.y, w: dim.w, h: dim.h });\n  }\n  return newBounds;\n}\n\n/**\n * Returns the text for the diagram datatip.\n */\nexport function getDatatipContent<\n  K1,\n  K2,\n  D1 extends DiagramNodeData<K1>,\n  D2 extends DiagramLinkData<K2, K1>\n>(\n  nodesMap: Map<K1, D1>,\n  linksMap: Map<K2, D2>,\n  focusedItem?: ItemInfo<K1, K2>,\n  hoveredItem?: ItemInfo<K1, K2>,\n  datatip?: (detail: DatatipContext<D1, D2>) => {\n    content: ComponentChildren;\n    borderColor?: Property.BorderColor;\n  }\n) {\n  let itemInfo;\n  const isPointerActive = hoveredItem?.isCurrent;\n  if (isPointerActive && hoveredItem.id != null) {\n    itemInfo = hoveredItem;\n  }\n  if (focusedItem && focusedItem.isCurrent) {\n    itemInfo = focusedItem;\n  }\n  if (itemInfo && datatip) {\n    return datatip(\n      itemInfo.isNode\n        ? { data: nodesMap.get(itemInfo.id as K1) as D1, type: 'node' }\n        : { data: linksMap.get(itemInfo.id as K2) as D2, type: 'link' }\n    );\n  }\n  if (itemInfo) {\n    const text = (\n      itemInfo.isNode ? nodesMap.get(itemInfo.id as K1) : linksMap.get(itemInfo.id as K2)\n    )?.accessibleLabel;\n    return {\n      content: text\n    };\n  }\n  return;\n}\n\n/**\n * Creates a map with key id and value node or link data\n */\nexport function createItemMap<\n  K1,\n  K2,\n  D1 extends DiagramNodeData<K1>,\n  D2 extends DiagramLinkData<K2, K1>\n>(items: (D1 | D2)[]) {\n  const itemIdToDataMap = new Map();\n  const itemIdToIndexMap = new Map();\n  const itemIndexToIdMap = new Map();\n  for (let i = 0; i < items.length; i++) {\n    itemIdToDataMap.set(items[i].id, items[i]);\n    itemIdToIndexMap.set(items[i].id, i);\n    itemIndexToIdMap.set(i, items[i].id);\n  }\n  return {\n    itemIdToDataMap,\n    itemIdToIndexMap,\n    itemIndexToIdMap\n  };\n}\n\n/**\n * Filter out links with no start or end nodes\n */\nexport function filterLinksWithNoEndNodes<K2, K1, D1, D2 extends DiagramLinkData<K2, K1>>(\n  links: D2[],\n  nodesMap: Map<K1, D1>\n) {\n  const newLinks: D2[] = [];\n  for (let i = 0; i < links.length; i++) {\n    const link = links[i];\n    if (nodesMap.get(link.startNode) && nodesMap.get(link.endNode)) {\n      newLinks.push(link);\n    }\n  }\n  return newLinks;\n}\n\n/**\n * Pulls out the dimensions from an array of bounds\n */\nexport function getDimensionsFromBounds(bounds: Bounds[]) {\n  const dims: Dimensions[] = [];\n  for (let i = 0; i < bounds.length; i++) {\n    dims.push({ w: bounds[i].w, h: bounds[i].h });\n  }\n  return dims;\n}\n\n/**\n * Returns true if event is a selection event\n */\nexport function isSelectionEvent(event: KeyboardEvent): boolean {\n  if (event.altKey && (event.key === '≥' || event.key === '≤')) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Returns the center position of the node or link\n * For links, draws a straight line between the centers of the start/end node\n * and returns the center of that line\n */\nexport function getFocusedItemBounds<K1, K2, D2 extends DiagramLinkData<K2, K1>>(\n  focusedItemInfo: ItemInfo<K1, K2>,\n  bounds: Bounds[],\n  links: D2[],\n  nodeIdToIndexMap: Map<K1, number>,\n  linkIdToIndexMap: Map<K2, number>\n) {\n  if (focusedItemInfo.isNode) {\n    const idx = nodeIdToIndexMap.get(focusedItemInfo.id as K1);\n    // Return the first element if cannot find the Node index\n    return bounds[idx || 0];\n  } else {\n    // Center of a straight line between start/end node centers\n    const link = links[linkIdToIndexMap.get(focusedItemInfo.id as K2) || 0];\n    const startNB = bounds[nodeIdToIndexMap.get(link.startNode) || 0];\n    const endNB = bounds[nodeIdToIndexMap.get(link.endNode) || 0];\n    const startNCenter = { x: startNB.x + startNB.w / 2, y: startNB.y + startNB.h / 2 };\n    const endNCenter = { x: endNB.x + endNB.w / 2, y: endNB.y + endNB.h / 2 };\n    const minX = Math.min(startNCenter.x, endNCenter.x);\n    const minY = Math.min(startNCenter.y, endNCenter.y);\n    return {\n      x: minX,\n      y: minY,\n      w: Math.abs(startNCenter.x - endNCenter.x),\n      h: Math.abs(startNCenter.y - endNCenter.y)\n    };\n  }\n}\n/**\n * Combines the node and link ids into one array\n */\nexport function combineIds<K1, K2>(nodeIds?: K1[], linkIds?: K2[]) {\n  const combinedIds: (K1 | K2)[] = [];\n  if (nodeIds) {\n    for (let i = 0; i < nodeIds.length; i++) {\n      combinedIds.push(nodeIds[i]);\n    }\n  }\n  if (linkIds) {\n    for (let i = 0; i < linkIds.length; i++) {\n      combinedIds.push(linkIds[i]);\n    }\n  }\n  return combinedIds;\n}\n\n/**\n * Returns the bounds of the diagram content\n */\nexport function getContentBounds(nodeBounds: Bounds[], labelBounds?: Bounds): Bounds {\n  if (nodeBounds.length === 0) return { x: 0, w: Infinity, y: 0, h: Infinity };\n  let minX = Infinity;\n  let minY = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n  let dims;\n  for (let i = 0; i < nodeBounds.length; i++) {\n    dims = nodeBounds[i];\n    minX = dims.x < minX ? dims.x : minX;\n    minY = dims.y < minY ? dims.y : minY;\n    maxX = dims.x + dims.w > maxX ? dims.x + dims.w : maxX;\n    maxY = dims.y + dims.h > maxY ? dims.y + dims.h : maxY;\n  }\n  if (labelBounds) {\n    minX = labelBounds.x < minX ? labelBounds.x : minX;\n    minY = labelBounds.y < minY ? labelBounds.y : minY;\n    maxX = labelBounds.x + labelBounds.w > maxX ? labelBounds.x + labelBounds.w : maxX;\n    maxY = labelBounds.y + labelBounds.h > maxY ? labelBounds.y + labelBounds.h : maxY;\n  }\n  return { x: minX, w: maxX - minX, y: minY, h: maxY - minY };\n}\n\n/**\n * Returns the label bounds\n */\nexport function getAllLabelBounds<\n  K1,\n  K2,\n  D1 extends DiagramNodeData<K1>,\n  D2 extends DiagramLinkData<K2, K1>\n>(\n  labelDims: Map<K1 | K2, TextDimensions>,\n  nodes: D1[],\n  links: D2[],\n  nodeLabelPos: (DiagramLabelPosition | undefined)[] = [],\n  linkLabelPos: DiagramLabelPosition[] = [],\n  isRTL: boolean\n) {\n  if (nodeLabelPos.length === 0 && linkLabelPos.length === 0) return undefined;\n  let minX = Infinity;\n  let minY = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n  let dims, label;\n  for (let i = 0; i < nodeLabelPos.length; i++) {\n    label = nodeLabelPos[i];\n    if (!label) continue;\n    dims = getLabelBounds(label, labelDims.get(nodes[i].id)!, isRTL);\n    minX = dims.x < minX ? dims.x : minX;\n    minY = dims.y < minY ? dims.y : minY;\n    maxX = dims.x + dims.w > maxX ? dims.x + dims.w : maxX;\n    maxY = dims.y + dims.h > maxY ? dims.y + dims.h : maxY;\n  }\n  for (let i = 0; i < linkLabelPos.length; i++) {\n    label = linkLabelPos[i];\n    if (!label) continue;\n    dims = getLabelBounds(label, labelDims.get(links[i].id)!, isRTL);\n    minX = dims.x < minX ? dims.x : minX;\n    minY = dims.y < minY ? dims.y : minY;\n    maxX = dims.x + dims.w > maxX ? dims.x + dims.w : maxX;\n    maxY = dims.y + dims.h > maxY ? dims.y + dims.h : maxY;\n  }\n  return { x: minX, w: maxX - minX, y: minY, h: maxY - minY };\n}\n\nfunction getLabelBounds(label: DiagramLabelPosition, dims: TextDimensions, isRTL: boolean) {\n  const labelPos = getLabelPosition(dims, label, isRTL);\n  const isRotating = label.rotationAngle;\n  if (!isRotating) {\n    return { x: labelPos.x, y: labelPos.y, w: dims.width, h: dims.height };\n  } else {\n    // Find the 4 corners of the label bounds relative to the rotation point\n    const rotationPoint = label.rotationPoint\n      ? label.rotationPoint\n      : { x: dims.width / 2, y: dims.height / 2 };\n    const angle = label.rotationAngle!;\n    const topLeft = getCoordsRelToRotPoint({ x: 0, y: 0 }, rotationPoint);\n    const topRight = getCoordsRelToRotPoint({ x: dims.width, y: 0 }, rotationPoint);\n    const bottomLeft = getCoordsRelToRotPoint({ x: 0, y: dims.height }, rotationPoint);\n    const bottomRight = getCoordsRelToRotPoint({ x: dims.width, y: dims.height }, rotationPoint);\n    const rotTopLeft = rotatePoint(topLeft, angle);\n    const rotBotLeft = rotatePoint(bottomLeft, angle);\n    const rotTopRight = rotatePoint(topRight, angle);\n    const rotBotRight = rotatePoint(bottomRight, angle);\n    const points = [rotTopLeft, rotBotLeft, rotTopRight, rotBotRight].map((pos: Position) => {\n      return {\n        x: pos.x + labelPos.x + rotationPoint.x,\n        y: pos.y + labelPos.y + rotationPoint.y\n      };\n    });\n    return getBoundsFromPoints(points);\n  }\n}\n\nfunction getCoordsRelToRotPoint(labelPoint: Position, rotPoint: Position) {\n  return { x: labelPoint.x - rotPoint.x, y: labelPoint.y - rotPoint.y };\n}\n\nfunction rotatePoint(pos: Position, angle: number) {\n  return {\n    x: pos.x * Math.cos(angle) - pos.y * Math.sin(angle),\n    y: pos.x * Math.sin(angle) + pos.y * Math.cos(angle)\n  };\n}\n\nfunction getBoundsFromPoints(points: Position[]) {\n  let minX = points[0].x;\n  let minY = points[0].y;\n  let maxX = points[0].x;\n  let maxY = points[0].y;\n  for (let i = 1; i < points.length; i++) {\n    const point = points[i];\n    if (point.x < minX) minX = point.x;\n    else if (point.x > maxX) maxX = point.x;\n    if (point.y < minY) minY = point.y;\n    else if (point.y > maxY) maxY = point.y;\n  }\n  return {\n    x: minX,\n    y: minY,\n    w: maxX - minX,\n    h: maxY - minY\n  };\n}\n\n/**\n * Returns the position of the label\n * @param dimensions\n * @param positionProps\n * @returns position of the label\n */\nexport function getLabelPosition(\n  dimensions: TextDimensions,\n  positionProps: DiagramLabelPosition,\n  isRTL: boolean\n) {\n  const position = positionProps.position;\n  const hAlign = positionProps.hAlign ? positionProps.hAlign : isRTL ? 'right' : 'left';\n  const vAlign = positionProps.vAlign;\n  let x, y;\n  if (hAlign === 'center') {\n    x = position.x - dimensions.width / 2;\n  } else if (hAlign === 'right') {\n    x = position.x - dimensions.width;\n  } else {\n    x = position.x;\n  }\n\n  if (vAlign === 'middle') {\n    y = position.y - dimensions.height / 2;\n  } else if (vAlign === 'bottom') {\n    y = position.y - dimensions.height;\n  } else if (vAlign === 'baseline') {\n    y = position.y + dimensions.y;\n  } else {\n    y = position.y;\n  }\n  return {\n    x: x,\n    y: y\n  };\n}\n\n/**\n * Converts centerX,Y coordinates to panX,Y coordinates\n */\nexport function centerXYToPanXY(\n  centerX: number,\n  centerY: number,\n  zoom: number,\n  width: number,\n  height: number\n) {\n  return {\n    panX: width / 2 - centerX * zoom,\n    panY: height / 2 - centerY * zoom\n  };\n}\n/**\n * Converts panX,Y coordinates to centerX,Y coordinates\n */\nexport function panXYToCenterXY(\n  panX: number,\n  panY: number,\n  zoom: number,\n  width: number,\n  height: number\n) {\n  return {\n    centerX: (width / 2 - panX) / zoom,\n    centerY: (height / 2 - panY) / zoom\n  };\n}\n\n/**\n * Compares if two ItemInfo are equal\n */\nexport function isEqualItem<K1, K2>(item1?: ItemInfo<K1, K2>, item2?: ItemInfo<K1, K2>) {\n  return item1?.id === item2?.id && item1?.isNode === item2?.isNode;\n}\n\n/**\n * Returns the item info of the data-oj-node or data-oj-link attribute for a given element.\n */\nexport function getNavigableInfo<K1, K2>(\n  element: HTMLElement,\n  rootElementRef?: Ref<HTMLDivElement>\n): ItemInfo<K1, K2> {\n  let isNode = false;\n  let elem = element;\n  let navigableId;\n  while (!navigableId) {\n    navigableId = elem.dataset['node'];\n    if (navigableId) {\n      isNode = true;\n    } else {\n      navigableId = elem.dataset['link'];\n    }\n    if (!navigableId) {\n      if (elem.parentElement && elem.parentElement !== rootElementRef?.current) {\n        elem = elem.parentElement;\n      } else {\n        break;\n      }\n    }\n  }\n  return {\n    id: navigableId as K1 | K2,\n    isNode: isNode\n  };\n}\n\n/**\n * Returns the id of the focused item.\n */\nexport function getFocusedItem<K1, K2>(\n  focusedItemInfo: ItemInfo<K1, K2>,\n  hoveredItemInfo?: ItemInfo<K1, K2>\n) {\n  let focused;\n  if (focusedItemInfo.isCurrent && focusedItemInfo.isFocusVisible) {\n    focused = focusedItemInfo.id;\n  } else if (hoveredItemInfo?.isCurrent) {\n    focused = hoveredItemInfo.id;\n  }\n  return focused;\n}\n\n/**\n * Returns the aria label\n */\nexport function getItemAriaLabel(\n  translations: BundleType,\n  supportsSelection: boolean,\n  isSelected?: boolean,\n  accessibleLabel?: string\n) {\n  return generateAriaLabel(translations, accessibleLabel || '', {\n    isSelected: !supportsSelection ? undefined : isSelected\n  });\n}\n\n/**\n * Returns the zoom to fit zoom level\n */\nexport function getZoomToFitZoom(width: number, height: number, contentBounds: Bounds) {\n  const zoomX = (width - 2 * ZOOM_TO_FIT_PADDING) / contentBounds.w;\n  const zoomY = (height - 2 * ZOOM_TO_FIT_PADDING) / contentBounds.h;\n  return Math.min(zoomX, zoomY);\n}\n\n/**\n * Constrains the zoom level\n */\nfunction constrainZoom(zoom: number, minZoom: number, maxZoom: number) {\n  let newZoom = Math.max(minZoom, zoom);\n  newZoom = Math.min(maxZoom, newZoom);\n  return newZoom;\n}\n\n/**\n * Returns the font props for a node or link\n */\nfunction _getFontProps(styles?: DiagramLabelStyles) {\n  const fontProps: Font = {};\n  if (!styles) return fontProps;\n  if (styles.fontFamily) fontProps.fontFamily = styles.fontFamily;\n  if (styles.fontSize) fontProps.fontSize = styles.fontSize;\n  if (styles.fontStyle) fontProps.fontStyle = styles.fontStyle;\n  if (styles.fontWeight) fontProps.fontWeight = styles.fontWeight;\n  return fontProps;\n}\n\n/**\n * Returns the panX, panY, and zoom when zooming and centering an item\n */\nexport function zoomAndCenterItemFromInfo<K1, K2, D2 extends DiagramLinkData<K2, K1>>(\n  info: ItemInfo<K1, K2>,\n  linkIdToDataMap: Map<K2, D2>,\n  bounds: Bounds[],\n  nodeIdToIndex: Map<K1, number>,\n  width: number,\n  height: number,\n  maxZoom: number\n) {\n  const isNode = info.isNode;\n  let totalBounds;\n  if (isNode) {\n    const nodeIndex = nodeIdToIndex.get(info.id as K1)!;\n    totalBounds = bounds[nodeIndex];\n  } else {\n    const link = linkIdToDataMap.get(info.id as K2)!;\n    const startNodeBounds = bounds[nodeIdToIndex.get(link.startNode)!];\n    const endNodeBounds = bounds[nodeIdToIndex.get(link.endNode)!];\n    const minX = Math.min(startNodeBounds.x, endNodeBounds.x);\n    const minY = Math.min(startNodeBounds.y, endNodeBounds.y);\n    const maxX = Math.max(\n      startNodeBounds.x + startNodeBounds.w,\n      endNodeBounds.x + startNodeBounds.w\n    );\n    const maxY = Math.max(startNodeBounds.y + startNodeBounds.h, endNodeBounds.y + endNodeBounds.h);\n    totalBounds = { x: minX, y: minY, w: maxX - minX, h: maxY - minY };\n  }\n  return getPanZoomToCenterNode(totalBounds, maxZoom, width, height);\n}\n\n/**\n * Returns the pan and zoom values in order\n * to center a node or link\n */\nfunction getPanZoomToCenterNode(bounds: Bounds, maxZoom: number, width: number, height: number) {\n  const zoomX = (width - 2 * ZOOM_TO_FIT_PADDING) / bounds.w;\n  const zoomY = (height - 2 * ZOOM_TO_FIT_PADDING) / bounds.h;\n  const zoom = Math.min(zoomX, zoomY, maxZoom);\n  const cX = bounds.w / 2 + bounds.x;\n  const cY = bounds.h / 2 + bounds.y;\n  return { centerX: cX, centerY: cY, zoom: zoom };\n}\n","import type { Position, State, NodeRendererContext } from './diagram.types';\nimport { useResizeObserver } from '../hooks/UNSAFE_useResizeObserver';\nimport { useCallback, useRef } from 'preact/hooks';\nimport { getItemAriaLabel } from './utils/diagramUtils';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { itemStyles } from './themes/DiagramStyles.css';\nimport { ComponentChildren } from 'preact';\nimport { useTranslationBundle } from '../hooks/UNSAFE_useTranslationBundle';\nimport type { BundleType } from '../resources/nls/bundle';\n\n/**\n * Props for node component\n */\ntype NodeProps<K1, D1> = {\n  id: K1;\n  position: Position;\n  label?: string;\n  state: State;\n  previousState: State;\n  isDimmed?: boolean;\n  activeId?: string;\n  accessibleLabel?: string;\n  nodeIndex: number;\n  data: D1;\n  nodeRenderer: (context: NodeRendererContext<D1>) => ComponentChildren;\n  onNodeSizeChanged: (width: number, height: number, idx: number) => void;\n  supportsSelection: boolean;\n};\n\nexport const DiagramNodeElement = <K1, D1>({\n  id,\n  state,\n  previousState,\n  position,\n  activeId,\n  nodeRenderer,\n  onNodeSizeChanged,\n  nodeIndex,\n  data,\n  accessibleLabel,\n  isDimmed,\n  supportsSelection\n}: NodeProps<K1, D1>) => {\n  const { nodeStyles, dimmedItemStyle } = itemStyles;\n  const context = {\n    state: state,\n    previousState: previousState,\n    data: data\n  };\n\n  const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\n  const ref = useRef<HTMLDivElement>(null);\n  // TODO JET-62472 change to one resize observer function\n  const optionsRef = useRef({ box: 'border-box' as const });\n  useResizeObserver(\n    ref,\n    useCallback(\n      (entry: ResizeObserverEntry) => {\n        const boxSize = entry.borderBoxSize;\n        const width = boxSize[0].inlineSize;\n        const height = boxSize[0].blockSize;\n        onNodeSizeChanged(width, height, nodeIndex);\n      },\n      [nodeIndex, onNodeSizeChanged]\n    ),\n    optionsRef.current\n  );\n  return (\n    <div\n      ref={ref}\n      key={id}\n      class={classNames([nodeStyles, isDimmed ? dimmedItemStyle : undefined])}\n      data-node={id}\n      role=\"img\"\n      aria-label={getItemAriaLabel(\n        translations,\n        supportsSelection,\n        state.selected,\n        accessibleLabel\n      )}\n      style={{\n        top: position.y,\n        left: position.x\n      }}\n      id={state.focused || state.hovered ? activeId : undefined}>\n      {nodeRenderer(context)}\n    </div>\n  );\n};\n","import { ComponentChildren } from 'preact';\nimport type { States, NodeRendererContext, Bounds, DiagramNodeData } from './diagram.types';\nimport { DiagramNodeElement } from './DiagramNodeElement';\nimport { layerStyles } from './themes/DiagramStyles.css';\n\ntype Props<K1, K2, D1> = {\n  nodes: D1[];\n  states: States<K1, K2>;\n  previousStates: States<K1, K2>;\n  nodeRenderer: (context: NodeRendererContext<D1>) => ComponentChildren;\n  onNodeSizeChanged: (width: number, height: number, idx: number) => void;\n  nodeBounds?: Bounds[];\n  supportsSelection: boolean;\n};\n\nexport function DiagramNodeLayer<K1, K2, D1 extends DiagramNodeData<K1>>({\n  nodes,\n  states,\n  previousStates,\n  nodeRenderer,\n  nodeBounds,\n  onNodeSizeChanged,\n  supportsSelection\n}: Props<K1, K2, D1>) {\n  return (\n    <div class={layerStyles}>\n      {nodes.map((node, i) => {\n        // this is for initial render before the layout function so render all nodes at 0,0\n        const position =\n          nodeBounds && nodeBounds[i] ? { x: nodeBounds[i].x, y: nodeBounds[i].y } : { x: 0, y: 0 };\n        const state = {\n          selected: states.selectedNodeIds.includes(node.id),\n          focused: states.focusedId === node.id,\n          hovered: states.hoveredId === node.id,\n          zoom: states.zoom\n        };\n        const previousState = {\n          selected: previousStates.selectedNodeIds.includes(node.id),\n          focused: previousStates.focusedId === node.id,\n          hovered: previousStates.hoveredId === node.id,\n          zoom: previousStates.zoom\n        };\n        return (\n          <DiagramNodeElement\n            id={node.id}\n            position={position}\n            state={state}\n            previousState={previousState}\n            isDimmed={\n              states.highlightedIds.length !== 0 && !states.highlightedIds.includes(node.id)\n            }\n            activeId={states.activeId}\n            nodeRenderer={nodeRenderer}\n            onNodeSizeChanged={onNodeSizeChanged}\n            nodeIndex={i}\n            accessibleLabel={node.accessibleLabel}\n            data={node}\n            supportsSelection={supportsSelection}\n          />\n        );\n      })}\n    </div>\n  );\n}\n","import type { State, LinkRendererContext } from './diagram.types';\nimport { getItemAriaLabel } from './utils/diagramUtils';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { itemStyles } from './themes/DiagramStyles.css';\nimport { ComponentChildren } from 'preact';\nimport { useTranslationBundle } from '../hooks/UNSAFE_useTranslationBundle';\nimport type { BundleType } from '../resources/nls/bundle';\n\n/**\n * Props for Link\n */\nexport type LinkProps<K2, D2> = {\n  id: K2;\n  label?: string;\n  state: State;\n  previousState: State;\n  isDimmed?: boolean;\n  activeId?: string;\n  accessibleLabel?: string;\n  data: D2;\n  linkRenderer: (context: LinkRendererContext<D2>) => ComponentChildren;\n  supportsSelection: boolean;\n};\n\nexport const DiagramLinkElement = <K2, D2>({\n  id,\n  state,\n  previousState,\n  activeId,\n  data,\n  linkRenderer,\n  accessibleLabel,\n  isDimmed,\n  supportsSelection\n}: LinkProps<K2, D2>) => {\n  const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\n  const { dimmedItemStyle, linkStyles } = itemStyles;\n  const context = {\n    state: state,\n    previousState: previousState,\n    data: data\n  };\n  return (\n    <g\n      key={id}\n      id={state.focused ? activeId : undefined}\n      aria-label={getItemAriaLabel(\n        translations,\n        supportsSelection,\n        state.selected,\n        accessibleLabel\n      )}\n      data-link={id}\n      role=\"img\"\n      class={classNames([linkStyles, isDimmed && dimmedItemStyle])}>\n      {linkRenderer(context)}\n    </g>\n  );\n};\n","import { ComponentChildren } from 'preact';\nimport type { States, LinkRendererContext, DiagramLinkData } from './diagram.types';\nimport { DiagramLinkElement } from './DiagramLinkElement';\nimport { layerStyles } from './themes/DiagramStyles.css';\n\ntype Props<K2, K1, D2> = {\n  links: D2[];\n  states: States<K1, K2>;\n  previousStates: States<K1, K2>;\n  linkRenderer: (context: LinkRendererContext<D2>) => ComponentChildren;\n  width: number;\n  height: number;\n  supportsSelection: boolean;\n};\n\nexport function DiagramLinkLayer<\n  K2,\n  K1,\n  D2 extends DiagramLinkData<K2, K1> = DiagramLinkData<K2, K1>\n>({\n  links,\n  states,\n  previousStates,\n  linkRenderer,\n  width,\n  height,\n  supportsSelection\n}: Props<K2, K1, D2>) {\n  return (\n    <svg class={layerStyles} width={width} height={height}>\n      {links.map((link) => {\n        const state = {\n          selected: states.selectedLinkIds.includes(link.id),\n          focused: states.focusedId === link.id,\n          hovered: states.hoveredId === link.id,\n          zoom: states.zoom\n        };\n        const previousState = {\n          selected: previousStates.selectedLinkIds.includes(link.id),\n          focused: previousStates.focusedId === link.id,\n          hovered: previousStates.hoveredId === link.id,\n          zoom: previousStates.zoom\n        };\n        return (\n          <DiagramLinkElement\n            id={link.id}\n            label={link.label}\n            state={state}\n            previousState={previousState}\n            isDimmed={\n              states.highlightedIds.length !== 0 && !states.highlightedIds.includes(link.id)\n            }\n            activeId={states.activeId}\n            accessibleLabel={link.accessibleLabel}\n            data={link}\n            linkRenderer={linkRenderer}\n            supportsSelection={supportsSelection}\n          />\n        );\n      })}\n    </svg>\n  );\n}\n","import type { DiagramLabelPosition, DiagramLabelStyles } from './diagram.types';\nimport { getLabelPosition } from './utils/diagramUtils';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { labelStyles } from './themes/DiagramStyles.css';\nimport type { TextDimensions } from '../hooks/PRIVATE_useTextDimensions';\nimport { Property } from 'csstype';\n\n/**\n * Props for the label component\n */\ntype LabelProps = {\n  styles?: LabelStyles;\n  text: string;\n  position: DiagramLabelPosition;\n  dimensions: TextDimensions;\n  isRTL: boolean;\n};\n\n/**\n * Label styles\n */\ntype LabelStyles = DiagramLabelStyles & {\n  borderStyle?: Property.BorderStyle;\n};\n\nexport const DiagramLabel = ({ text, position, styles, dimensions, isRTL }: LabelProps) => {\n  const { labelStyle, labelBorderStyle } = labelStyles;\n\n  const labelPosition = getLabelPosition(dimensions, position, isRTL);\n  const labelRotation = getLabelRotation(position);\n  return (\n    <div\n      class={classNames([labelStyle, styles && styles.borderColor && labelBorderStyle])}\n      style={{\n        top: labelPosition.y,\n        left: labelPosition.x,\n        ...styles,\n        ...labelRotation\n      }}>\n      {text}\n    </div>\n  );\n};\n\n/**\n * Returns the label rotation props\n * @param position\n * @returns rotation props\n */\nfunction getLabelRotation(position: DiagramLabelPosition) {\n  const rotationAngle = position.rotationAngle;\n  const rotationPoint = position.rotationPoint;\n  const rotation: {\n    transform?: string;\n    'transform-origin'?: string;\n  } = {};\n  if (rotationAngle) {\n    rotation['transform'] = `rotate(${rotationAngle}deg)`;\n  }\n  if (rotationPoint) {\n    rotation['transform-origin'] = `${rotationPoint.x}px ${rotationPoint.y}px`;\n  }\n  return rotation;\n}\n","import type { DiagramLabelPosition, DiagramNodeData, DiagramLinkData } from './diagram.types';\nimport { DiagramLabel } from './DiagramLabel';\nimport type { TextDimensions } from '../hooks/PRIVATE_useTextDimensions';\nimport { layerStyles } from './themes/DiagramStyles.css';\nimport { useUser } from '../hooks/UNSAFE_useUser';\n\ntype Props<K1, K2, D1, D2> = {\n  labelPosition: (DiagramLabelPosition | undefined)[];\n  itemProps: (D1 | D2)[];\n  labelDimensions: Map<K1 | K2, TextDimensions>;\n};\n\nexport function DiagramLabelLayer<\n  K1,\n  K2,\n  D1 extends DiagramNodeData<K1>,\n  D2 extends DiagramLinkData<K2, K1>\n>({ labelPosition, itemProps, labelDimensions }: Props<K1, K2, D1, D2>) {\n  const { direction } = useUser();\n  return (\n    <div class={layerStyles}>\n      {itemProps.map((item, i) => {\n        if (item.label && labelPosition[i]) {\n          return (\n            <DiagramLabel\n              styles={item.labelStyle}\n              text={item.label}\n              position={labelPosition[i]!}\n              dimensions={labelDimensions.get(item.id)!}\n              isRTL={direction === 'rtl'}\n            />\n          );\n        }\n        return undefined;\n      })}\n    </div>\n  );\n}\n","import type {\n  NodeRendererContext,\n  LinkRendererContext,\n  States,\n  Bounds,\n  DiagramLabelPosition,\n  DiagramNodeData,\n  DiagramLinkData\n} from './diagram.types';\nimport { DiagramNodeLayer } from './DiagramNodeLayer';\nimport { DiagramLinkLayer } from './DiagramLinkLayer';\nimport { DiagramLabelLayer } from './DiagramLabelLayer';\nimport { ComponentChildren } from 'preact';\nimport type { TextDimensions } from '../hooks/PRIVATE_useTextDimensions';\n\n/**\n * Props for Diagram layers component\n */\ntype DiagramLayersProps<K1, K2, D1, D2> = {\n  nodes: D1[];\n  links: D2[];\n  nodeRenderer: (context: NodeRendererContext<D1>) => ComponentChildren;\n  linkRenderer?: (context: LinkRendererContext<D2>) => ComponentChildren;\n  states: States<K1, K2>;\n  previousStates: States<K1, K2>;\n  nodeBounds: Bounds[];\n  // width height are for svg for links\n  width: number;\n  height: number;\n  onNodeSizeChanged: (width: number, height: number, idx: number) => void;\n  nodeLabelPositions?: (DiagramLabelPosition | undefined)[];\n  linkLabelPositions?: (DiagramLabelPosition | undefined)[];\n  labelDimensions?: Map<K1 | K2, TextDimensions>;\n  supportsSelection: boolean;\n};\n\nexport function DiagramLayers<\n  K1,\n  K2,\n  D1 extends DiagramNodeData<K1>,\n  D2 extends DiagramLinkData<K2, K1>\n>({\n  nodes,\n  links,\n  nodeRenderer,\n  linkRenderer,\n  states,\n  previousStates,\n  nodeBounds,\n  onNodeSizeChanged,\n  width,\n  height,\n  nodeLabelPositions,\n  linkLabelPositions,\n  labelDimensions,\n  supportsSelection\n}: DiagramLayersProps<K1, K2, D1, D2>) {\n  return (\n    <>\n      {links.length > 0 && linkRenderer && width !== Infinity && (\n        <DiagramLinkLayer\n          links={links}\n          states={states}\n          previousStates={previousStates}\n          linkRenderer={linkRenderer}\n          width={width}\n          height={height}\n          supportsSelection={supportsSelection}\n        />\n      )}\n      <DiagramNodeLayer\n        nodes={nodes}\n        nodeBounds={nodeBounds}\n        states={states}\n        previousStates={previousStates}\n        nodeRenderer={nodeRenderer}\n        onNodeSizeChanged={onNodeSizeChanged}\n        supportsSelection={supportsSelection}\n      />\n      {labelDimensions ? (\n        <div>\n          {nodeLabelPositions ? (\n            <DiagramLabelLayer\n              labelPosition={nodeLabelPositions}\n              itemProps={nodes}\n              labelDimensions={labelDimensions}\n            />\n          ) : undefined}\n          {links && linkLabelPositions ? (\n            <DiagramLabelLayer\n              labelPosition={linkLabelPositions}\n              itemProps={links}\n              labelDimensions={labelDimensions}\n            />\n          ) : undefined}\n        </div>\n      ) : undefined}\n    </>\n  );\n}\n","import { ComponentChildren } from 'preact';\nimport { centerXYToPanXY } from './utils/diagramUtils';\nimport { panZoomStyles } from './themes/DiagramStyles.css';\n\ntype Props = {\n  centerX: number;\n  centerY: number;\n  zoom: number;\n  width: number;\n  height: number;\n  children: ComponentChildren;\n};\n\nexport function DiagramPanZoomContainer({\n  centerX,\n  centerY,\n  children,\n  zoom,\n  width,\n  height\n}: Props) {\n  const panValues = centerXYToPanXY(centerX, centerY, zoom, width, height);\n  return (\n    <div\n      class={panZoomStyles}\n      style={{\n        //TODO JET-62471 look at using matrices or both in transform instead\n        translate: `${panValues.panX}px ${panValues.panY}px`,\n        transform: `scale(${zoom})`\n      }}>\n      {children}\n    </div>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport type { DiagramNodeData, DiagramLinkData, Bounds, ItemInfo } from '../diagram.types';\n\n/**\n * Navigation direction\n */\nexport type NavDirection = 'right' | 'left' | 'up' | 'down';\n\ntype linkDetailType<K2> = {\n  id: K2;\n  angle: number;\n  distance: number;\n  /**\n   * Ingoing = 1, outgoing = 0\n   */\n  direction: 0 | 1;\n};\n\n/**\n * Returns the node data based on node info in a diagram.\n * @param itemInfo\n * @returns\n */\nexport function getNodeDetailFromInfo<K1, K2, D1 extends DiagramNodeData<K1>>(\n  itemInfo: ItemInfo<K1, K2>,\n  nodes: D1[]\n): D1 | undefined {\n  let node;\n  for (let i = 0; i < nodes.length; i++) {\n    node = nodes[i];\n    if (itemInfo.id === node.id) {\n      return node;\n    }\n  }\n  return undefined;\n}\n\n/**\n * Returns the link data based on link info in a diagram.\n * @param itemInfo\n * @returns\n */\nexport function getLinkDetailFromInfo<K1, K2, D2 extends DiagramLinkData<K2, K1>>(\n  itemInfo: ItemInfo<K1, K2>,\n  links: D2[]\n): D2 | undefined {\n  let link;\n  for (let i = 0; i < links.length; i++) {\n    link = links[i];\n    if (itemInfo.id === link.id) {\n      return link;\n    }\n  }\n  return undefined;\n}\n\n/**\n * Creates a map with key node id and value node bounds\n */\nexport function createNodeBoundsMap<K1, D1 extends DiagramNodeData<K1>>(\n  nodes: D1[],\n  bounds: Bounds[]\n) {\n  const nodeBounds: Map<K1, Bounds> = new Map();\n  for (let i = 0; i < nodes.length; i++) {\n    nodeBounds.set(nodes[i].id, bounds[i]);\n  }\n  return nodeBounds;\n}\n\n/**\n * Utility method that adds sorting attributes of each link to an array\n */\nexport function addSortingAttributes<\n  K1,\n  K2,\n  D1 extends DiagramNodeData<K1>,\n  D2 extends DiagramLinkData<K2, K1>\n>(node: D1, listOfLinks: D2[], nodes: D1[], nodeBounds: Map<K1, Bounds>) {\n  let angle, distance, direction;\n  const linkDetail: linkDetailType<K2>[] = [];\n  for (let i = 0; i < listOfLinks.length; i++) {\n    const link = listOfLinks[i];\n    angle = _getClockwiseAngle(node, link, nodes, nodeBounds);\n    distance = _getNodesDistance(link, nodes, nodeBounds);\n    direction = _getLinkDirection(node, link);\n    linkDetail.push({ id: link.id, angle: angle, distance: distance, direction: direction });\n  }\n  return linkDetail;\n}\n\n/**\n * Returns a function that compares two link around a given node\n * The links are analyzed by angle, distance from the node and direction. The sorting attributes are added to the links before sorting.\n */\nexport function getLinkComparator<K2>() {\n  return (link1: linkDetailType<K2>, link2: linkDetailType<K2>) => {\n    const { angle: linkAngle1, distance: linkDistance1, direction: linkDirection1 } = link1;\n    const { angle: linkAngle2, distance: linkDistance2, direction: linkDirection2 } = link2;\n    let res = -1;\n\n    if (!_anglesAreEqualWithinTolerance(linkAngle1, linkAngle2) && linkAngle1 > linkAngle2) {\n      res = 1;\n    } else if (_anglesAreEqualWithinTolerance(linkAngle1, linkAngle2)) {\n      //check distance and direction\n      if (linkDistance1 > linkDistance2) {\n        res = 1;\n      } else if (linkDistance2 == linkDistance1 && linkDirection1 > linkDirection2) {\n        //outgoing to ingoing\n        res = 1;\n      } else if (linkDistance2 == linkDistance1 && linkDirection1 == linkDirection2) {\n        res = 0;\n      }\n    }\n    return res;\n  };\n}\n\n/**\n * Returns navigable links for a given node\n */\nexport function getNavigableLinksForNodeId<K1, K2, D2 extends DiagramLinkData<K2, K1>>(\n  nodeId: K1,\n  listOfLinks: D2[]\n) {\n  const links: D2[] = [];\n  listOfLinks.forEach((link) => {\n    const startId = link.startNode;\n    const endId = link.endNode;\n\n    if (startId == nodeId || endId == nodeId) links.push(link);\n  });\n  return links;\n}\n\n/**\n * Get the clockwise angle for the link given node as a center\n */\nfunction _getClockwiseAngle<\n  K1,\n  K2,\n  D1 extends DiagramNodeData<K1>,\n  D2 extends DiagramLinkData<K2, K1>\n>(node: D1, link: D2, nodes: D1[], nodeBounds: Map<K1, Bounds>) {\n  //find opposite node\n  let currNode;\n  let startNode = nodes[0];\n  let endNode = nodes[0];\n  for (let i = 0; i < nodes.length; i++) {\n    currNode = nodes[i];\n    if (currNode.id === link.startNode) {\n      startNode = currNode;\n    } else if (currNode.id === link.endNode) {\n      endNode = currNode;\n    }\n  }\n  const oppositeNode = node.id == startNode.id ? endNode : startNode;\n\n  const p1 = _getNodeCenter(node, nodeBounds);\n  const p2 = _getNodeCenter(oppositeNode, nodeBounds);\n  let angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);\n  angle = angle < 0 ? angle + Math.PI * 2 : angle;\n  return angle;\n}\n\n/**\n * Get the distance between start and end nodes for the given link\n */\nfunction _getNodesDistance<\n  K1,\n  K2,\n  D1 extends DiagramNodeData<K1>,\n  D2 extends DiagramLinkData<K2, K1>\n>(link: D2, nodes: D1[], nodeBounds: Map<K1, Bounds>) {\n  let currNode;\n  let startNode = nodes[0];\n  let endNode = nodes[0];\n  for (let i = 0; i < nodes.length; i++) {\n    currNode = nodes[i];\n    if (currNode.id === link.startNode) {\n      startNode = currNode;\n    } else if (currNode.id === link.endNode) {\n      endNode = currNode;\n    }\n  }\n  const p1 = _getNodeCenter(startNode, nodeBounds);\n  const p2 = _getNodeCenter(endNode, nodeBounds);\n  return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));\n}\n\n/**\n * Get link direction for the given node.  1 if the node is the end node\n * and 0 if it is the start node\n */\nfunction _getLinkDirection<\n  K1,\n  K2,\n  D1 extends DiagramNodeData<K1>,\n  D2 extends DiagramLinkData<K2, K1>\n>(node: D1, link: D2): 0 | 1 {\n  if (link.endNode === node.id) {\n    return 1;\n  }\n  return 0;\n}\n\n/**\n * Get node center\n */\nfunction _getNodeCenter<K1, D1 extends DiagramNodeData<K1>>(node: D1, nodeBounds: Map<K1, Bounds>) {\n  const nodeBB = nodeBounds.get(node.id)!;\n  return { x: nodeBB.x + nodeBB.w / 2, y: nodeBB.y + nodeBB.h / 2 };\n}\n\n/**\n * Calculates the angle weighted by distance\n */\nexport function calcDistanceAngleWeighted(\n  objectBB: Bounds,\n  currentBB: Bounds,\n  direction: NavDirection\n) {\n  // Variables used for calculating penalties when calculating distances between two navigables.\n  const optimalAngle1 = (15 / 180) * Math.PI;\n  const optimalAngle2 = (40 / 180) * Math.PI;\n  const suboptimalAnglePenalty1 = 2; // multiplier to the distance\n  const suboptimalAnglePenalty2 = 6; // multiplier to the distance\n\n  const objCenterX = objectBB.x + objectBB.w / 2;\n  const objCenterY = objectBB.y + objectBB.h / 2;\n\n  const curCenterX = currentBB.x + currentBB.w / 2;\n  const curCenterY = currentBB.y + currentBB.h / 2;\n\n  const x_dist = Math.abs(objCenterX - curCenterX);\n  const y_dist = Math.abs(objCenterY - curCenterY);\n\n  const angle = Math.atan2(y_dist, x_dist);\n\n  let distance = Math.sqrt(x_dist * x_dist + y_dist * y_dist);\n\n  // Angle penalty based on direction\n  if (\n    (angle > optimalAngle1 && (direction == 'right' || direction == 'left')) ||\n    (angle < Math.PI / 2 - optimalAngle1 && (direction == 'up' || direction == 'down'))\n  ) {\n    if (\n      (angle > optimalAngle2 && (direction == 'right' || direction == 'left')) ||\n      (angle < Math.PI / 2 - optimalAngle2 && (direction == 'up' || direction == 'down'))\n    ) {\n      distance *= suboptimalAnglePenalty2;\n    } else {\n      distance *= suboptimalAnglePenalty1;\n    }\n  }\n\n  return distance;\n}\n\n/**\n * Given a direction, is a certain node is a valid destination to navigate to\n */\nexport function isValidDestination(\n  objBB: Bounds,\n  curBB: Bounds,\n  direction: NavDirection,\n  compareCenters: boolean\n) {\n  // compare the centers of the navigable and to be valid, the navigable must be in the right direction\n  // without tolerance\n  if (compareCenters) {\n    const objCenterX = objBB.x + 0.5 * objBB.w;\n    const curCenterX = curBB.x + 0.5 * curBB.w;\n    const objCenterY = objBB.y + 0.5 * objBB.h;\n    const curCenterY = curBB.y + 0.5 * curBB.h;\n\n    switch (direction) {\n      case 'up':\n        return objCenterY < curCenterY;\n      case 'down':\n        return objBB.y > curCenterY;\n      case 'right':\n        return objCenterX > curCenterX;\n      case 'left':\n        return objCenterX < curCenterX;\n      default:\n        break;\n    }\n    return true;\n  }\n\n  switch (direction) {\n    case 'up':\n      return objBB.y < curBB.y || _areEqualWithinTolerance(objBB.y, curBB.y);\n    case 'down':\n      return objBB.y > curBB.y || _areEqualWithinTolerance(objBB.y, curBB.y);\n    case 'right':\n      return objBB.x > curBB.x || _areEqualWithinTolerance(objBB.x, curBB.x);\n    case 'left':\n      return objBB.x < curBB.x || _areEqualWithinTolerance(objBB.x, curBB.x);\n    default:\n      break;\n  }\n  return true;\n}\n\n/**\n * Returns true if two nodes are in contact\n */\nexport function calcInContact(objRect: Bounds, curRect: Bounds, direction: NavDirection) {\n  switch (direction) {\n    case 'up':\n      return (\n        _isVerticallyAligned(objRect, curRect) &&\n        (curRect.y <= objRect.y + objRect.h ||\n          _areEqualWithinTolerance(curRect.y, objRect.y + objRect.h))\n      );\n    case 'down':\n      return (\n        _isVerticallyAligned(objRect, curRect) &&\n        (objRect.y <= curRect.y + curRect.h ||\n          _areEqualWithinTolerance(objRect.y, curRect.y + curRect.h))\n      );\n    case 'right':\n      return (\n        _isHorizontallyAligned(objRect, curRect) &&\n        (objRect.x <= curRect.x + curRect.w ||\n          _areEqualWithinTolerance(objRect.x, curRect.x + curRect.w))\n      );\n    case 'left':\n      return (\n        _isHorizontallyAligned(objRect, curRect) &&\n        (curRect.x <= objRect.x + objRect.w ||\n          _areEqualWithinTolerance(curRect.x, objRect.x + objRect.w))\n      );\n    default:\n      break;\n  }\n\n  return false;\n}\n\nfunction _isVerticallyAligned(rect1: Bounds, rect2: Bounds) {\n  return (\n    (rect1.x >= rect2.x && rect1.x <= rect2.x + rect2.w) ||\n    (rect2.x >= rect1.x && rect2.x <= rect1.x + rect1.w)\n  );\n}\n\nfunction _isHorizontallyAligned(rect1: Bounds, rect2: Bounds) {\n  return (\n    (rect1.y >= rect2.y && rect1.y <= rect2.y + rect2.h) ||\n    (rect2.y >= rect1.y && rect2.y <= rect1.y + rect1.h)\n  );\n}\n\nfunction _areEqualWithinTolerance(a: number, b: number) {\n  return Math.abs(a - b) <= 0.0000001;\n}\n\nfunction _anglesAreEqualWithinTolerance(a1: number, a2: number) {\n  let res = Math.abs(a1 - a2) <= 0.0000001;\n  if (!res) {\n    res = Math.abs(Math.PI * 2 + Math.min(a1, a2) - Math.max(a1, a2)) <= 0.0000001;\n  }\n  return res;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport {\n  NavDirection,\n  addSortingAttributes,\n  calcDistanceAngleWeighted,\n  calcInContact,\n  createNodeBoundsMap,\n  getLinkComparator,\n  getNavigableLinksForNodeId,\n  getNodeDetailFromInfo,\n  isValidDestination\n} from '../utils/navUtils';\nimport type { DiagramNodeData, DiagramLinkData, Bounds, ItemInfo } from '../diagram.types';\nimport { useRef } from 'preact/hooks';\n\nexport function useDiagramNavigation<\n  K1,\n  K2,\n  D1 extends DiagramNodeData<K1>,\n  D2 extends DiagramLinkData<K2, K1>\n>(nodes: D1[], links: D2[], bounds: Bounds[], linkIdToDataMap: Map<K2, D2>) {\n  const currentKeyboardFocusNode = useRef<K1>();\n  const nodeBoundsById = createNodeBoundsMap<K1, D1>(nodes, bounds);\n\n  function getNextNavigableNode(\n    direction: NavDirection,\n    compareCenters: boolean,\n    current?: D1,\n    listOfObjects?: D1[]\n  ) {\n    if (!listOfObjects) return current;\n\n    if (!current) return listOfObjects[0];\n    const currBB = nodeBoundsById.get(current.id);\n    if (!currBB) return listOfObjects[0];\n\n    let nextObject = current; //init to current object\n    let nextDistance = Number.MAX_VALUE;\n\n    // If an object is in contact it overrules all other attributes\n    // Only another in contact object with better attributes will have higher precedence\n    let nextInContact = false;\n\n    // Whether or not the for loop has encountered the current object\n    let hasFoundCurrent = false;\n\n    let object, inContact, distance;\n    for (let i = 0; i < listOfObjects.length; i++) {\n      object = listOfObjects[i];\n\n      if (object === current) {\n        hasFoundCurrent = true;\n        continue;\n      }\n      const objBB = nodeBoundsById.get(object.id);\n      if (!objBB) continue;\n\n      const objBounds = { x: objBB.x, y: objBB.y, w: objBB.w, h: objBB.h };\n      const currBounds = { x: currBB.x, y: currBB.y, w: currBB.w, h: currBB.h };\n      if (!isValidDestination(objBounds, currBounds, direction, compareCenters)) continue;\n\n      inContact = calcInContact(objBounds, currBounds, direction);\n\n      if (nextInContact && !inContact) continue;\n\n      distance = calcDistanceAngleWeighted(objBounds, currBounds, direction);\n\n      if (distance == 0 && !hasFoundCurrent) continue;\n\n      // Make sure incontact flag have highest precedence\n      if (\n        (!nextInContact && inContact) ||\n        (distance < nextDistance && ((nextInContact && inContact) || !nextInContact))\n      ) {\n        nextDistance = distance;\n        nextObject = object;\n        nextInContact = inContact;\n      }\n    }\n    return nextObject;\n  }\n\n  /**\n   * Get next navigavle link depending on direction - clockwise or conter clockwise.\n   * The decision is made based on location of nodes centers rather than link paths or link angles.\n   */\n  function getNextNavigableLink(\n    direction: string,\n    listOfNodes: D1[],\n    currentLink?: D2,\n    listOfLinks?: D2[]\n  ) {\n    if (!listOfLinks) return currentLink;\n\n    if (!currentLink) return listOfLinks[0];\n    const keyboardFocusNode = currentKeyboardFocusNode.current;\n    const nodeId = keyboardFocusNode ? keyboardFocusNode : currentLink.startNode;\n    const node = getNodeDetailFromInfo({ id: nodeId, isNode: true }, listOfNodes);\n\n    if (!node) return currentLink;\n    const adjLinks = getNavigableLinksForNodeId(node.id, listOfLinks);\n    listOfLinks = adjLinks;\n    const linksWithSortingAttributes = addSortingAttributes<K1, K2, D1, D2>(\n      node,\n      listOfLinks,\n      listOfNodes,\n      nodeBoundsById\n    );\n    linksWithSortingAttributes.sort(getLinkComparator());\n    //clockwise direction\n    const bForward = direction == 'down' ? true : false;\n    let index = 0;\n    for (let i = 0; i < linksWithSortingAttributes.length; i++) {\n      const link = linksWithSortingAttributes[i];\n      if (link.id === currentLink.id) {\n        if (bForward) index = i == linksWithSortingAttributes.length - 1 ? 0 : i + 1;\n        else index = i == 0 ? linksWithSortingAttributes.length - 1 : i - 1;\n        break;\n      }\n    }\n    return linksWithSortingAttributes[index];\n  }\n\n  /**\n   * Returns the link detail when a node to link navigation occurs\n   */\n  function navigateFromNodeToLink(listOfLinks: D2[], event: KeyboardEvent, node?: D1) {\n    if (!node) return undefined;\n    const adjLinks = getNavigableLinksForNodeId(node.id, listOfLinks);\n    if (adjLinks.length < 1) return undefined;\n    let link = adjLinks[0];\n    const nodeBB = nodeBoundsById.get(node.id)!;\n    let object, currNode, currNodeBB, currNodeBBCenterX;\n    const nodeCenterX = nodeBB.x + nodeBB.w / 2;\n    currentKeyboardFocusNode.current = node.id;\n    for (let i = 0; i < adjLinks.length; i++) {\n      object = adjLinks[i];\n      currNode = object.startNode === node.id ? object.endNode : object.startNode;\n      currNodeBB = nodeBoundsById.get(currNode);\n      currNodeBBCenterX = currNodeBB!.x + currNodeBB!.w / 2;\n      if (\n        // equivalent of ≤ and ≥\n        (event.altKey && event.code === 'Comma' && currNodeBBCenterX <= nodeCenterX) ||\n        (event.altKey && event.code === 'Period' && currNodeBBCenterX >= nodeCenterX)\n      ) {\n        link = object;\n        break;\n      }\n    }\n    return { id: link.id, isNode: false };\n  }\n\n  /**\n   * Returns the node detail when a link to node navigation occurs\n   */\n  function navigateFromLinkToNode(linkId: K2, event: KeyboardEvent) {\n    const key = event.key;\n    const linkData = linkIdToDataMap.get(linkId)!;\n    const startNodeBB = nodeBoundsById.get(linkData.startNode);\n    const endNodeBB = nodeBoundsById.get(linkData.endNode);\n    if (!startNodeBB || !endNodeBB) return undefined;\n    const startNodeCenterX = startNodeBB.x + startNodeBB.w / 2;\n    const endNodeCenterX = endNodeBB.x + endNodeBB.w / 2;\n    const newNode =\n      (endNodeCenterX > startNodeCenterX && key === 'ArrowRight') ||\n      (endNodeCenterX < startNodeCenterX && key === 'ArrowLeft')\n        ? linkData.endNode\n        : linkData.startNode;\n    return { id: newNode, isNode: true };\n  }\n\n  return {\n    isNode: (itemInfo: ItemInfo<K1, K2>): boolean => {\n      let node, link;\n      for (let i = 0; i < nodes.length; i++) {\n        node = nodes[i];\n        link = links[i];\n        if (itemInfo.id === node.id) {\n          return true;\n        }\n        if (itemInfo.id === link.id) {\n          return true;\n        }\n      }\n      return false;\n    },\n    getNextNavigableNode,\n    getNextNavigableLink,\n    navigateFromNodeToLink,\n    navigateFromLinkToNode\n  };\n}\n","import {\n  ItemInfo,\n  ItemHoverDetail,\n  ItemFocusDetail,\n  Bounds,\n  DiagramNodeData,\n  DiagramLinkData\n} from '../diagram.types';\nimport { useRef, useState } from 'preact/hooks';\nimport { isEqualItem, getNavigableInfo, zoomAndCenterItemFromInfo } from '../utils/diagramUtils';\nimport { getRandomId } from '../../utils/PRIVATE_visLayoutUtils/layoutUtils';\nimport { getNodeDetailFromInfo, getLinkDetailFromInfo } from '../utils/navUtils';\nimport { useDiagramNavigation } from './useDiagramNavigation';\nimport type { NavDirection } from '../utils/navUtils';\nimport { useVisHover } from '#hooks/PRIVATE_useVisHover';\nimport { mergeProps } from '#utils/UNSAFE_mergeProps';\n\nconst DEFAULT_KB_PAN = 15;\nconst DEFAULT_KB_ZOOM = 0.15;\n\nexport function useEvents<\n  K1,\n  K2,\n  D1 extends DiagramNodeData<K1>,\n  D2 extends DiagramLinkData<K2, K1>\n>(\n  touchResponse: 'touchStart' | 'touchHold',\n  initNode: D1,\n  nodes: D1[],\n  links: D2[],\n  nodeBounds: Bounds[],\n  linkIdToDataMap: Map<K2, D2>,\n  nodeIdToDataMap: Map<K1, D1>,\n  nodeIdToIndexMap: Map<K1, number>,\n  width: number,\n  height: number,\n  maxZoom: number,\n  onItemHover?: (detail: ItemHoverDetail<K1, K2, D1, D2>) => void,\n  onItemFocus?: (detail: ItemFocusDetail<K1, K2, D1, D2>) => void,\n  kbPanCallback?: (props: {\n    dPan?: { dx: number; dy: number };\n    nPan?: { cx: number; cy: number };\n    center?: boolean;\n  }) => void,\n  kbZoomCallback?: (props: { dZoom?: number; nZoom?: number }) => void\n) {\n  const {\n    getNextNavigableNode,\n    getNextNavigableLink,\n    navigateFromNodeToLink,\n    navigateFromLinkToNode\n  } = useDiagramNavigation<K1, K2, D1, D2>(nodes, links, nodeBounds, linkIdToDataMap);\n  const [focusedItemInfo, setfocusedItemInfo] = useState<ItemInfo<K1, K2>>({\n    id: initNode.id,\n    isNode: true\n  });\n  const [hoveredItemInfo, sethoveredItemInfo] = useState<ItemInfo<K1, K2>>();\n  const activeId = useRef<string>();\n\n  const cancelEvent = (event: Event) => {\n    event.preventDefault();\n    event.stopPropagation();\n  };\n\n  const keyDownHandler = (event: KeyboardEvent) => {\n    const key = event.key;\n    let eventConsumed = false;\n    // tabbing out of the diagram\n    if (key === 'TAB') {\n      return;\n    }\n    // if this a switch from node to link or vice versa\n    if (isChangeItemType(event)) {\n      const nextItemInfo = focusedItemInfo.isNode\n        ? navigateFromNodeToLink(links, event, getNodeDetailFromInfo(focusedItemInfo, nodes))\n        : navigateFromLinkToNode(focusedItemInfo.id as K2, event);\n      handleKeyboardInput(nextItemInfo);\n      eventConsumed = true;\n    } else if (isNavigationEvent(key)) {\n      const nextItemInfo = handleKeyboardNavigationEvent(key);\n      handleKeyboardInput(nextItemInfo);\n      eventConsumed = true;\n    } else {\n      switch (key) {\n        case 'PageUp': {\n          kbPanCallback &&\n            kbPanCallback({\n              dPan: {\n                dx: event.shiftKey ? -DEFAULT_KB_PAN : 0,\n                dy: event.shiftKey ? 0 : -DEFAULT_KB_PAN\n              }\n            });\n          eventConsumed = true;\n          break;\n        }\n        case 'PageDown': {\n          kbPanCallback &&\n            kbPanCallback({\n              dPan: {\n                dx: event.shiftKey ? DEFAULT_KB_PAN : 0,\n                dy: event.shiftKey ? 0 : DEFAULT_KB_PAN\n              }\n            });\n          eventConsumed = true;\n          eventConsumed = true;\n          break;\n        }\n        case '+':\n        case '=': {\n          kbZoomCallback && kbZoomCallback({ dZoom: DEFAULT_KB_ZOOM });\n          eventConsumed = true;\n          break;\n        }\n        case '-':\n        case '_': {\n          kbZoomCallback && kbZoomCallback({ dZoom: -DEFAULT_KB_ZOOM });\n          eventConsumed = true;\n          break;\n        }\n        case '0': {\n          if (event.ctrlKey && event.altKey) {\n            const { centerX, centerY, zoom } = zoomAndCenterItemFromInfo(\n              focusedItemInfo,\n              linkIdToDataMap,\n              nodeBounds,\n              nodeIdToIndexMap,\n              width,\n              height,\n              maxZoom\n            );\n            kbZoomCallback && kbZoomCallback({ nZoom: zoom });\n            kbPanCallback && kbPanCallback({ nPan: { cx: centerX, cy: centerY } });\n          } else {\n            // zoom to fit\n            kbZoomCallback && kbZoomCallback({});\n            kbPanCallback && kbPanCallback({ center: true });\n          }\n          eventConsumed = true;\n        }\n      }\n    }\n    if (eventConsumed) {\n      cancelEvent(event);\n    }\n  };\n\n  const keyUpHandler = (event: KeyboardEvent) => {\n    const key = event.code;\n    switch (key) {\n      case 'Tab': {\n        updatefocusedItemInfo({\n          ...focusedItemInfo,\n          isCurrent: true,\n          isFocusVisible: true\n        });\n        break;\n      }\n    }\n  };\n\n  const blurHandler = () => {\n    if (hoveredItemInfo != null || focusedItemInfo.isCurrent) {\n      onItemFocus?.({ id: undefined, data: undefined });\n    }\n    const itemInfo = { ...focusedItemInfo, isCurrent: false, isFocusVisible: false };\n    setfocusedItemInfo(itemInfo);\n  };\n\n  const onHover = (event: PointerEvent) => {\n    const itemInfo = getNavigableInfo<K1, K2>(event.target as HTMLElement);\n    if (itemInfo && !isEqualItem(itemInfo, hoveredItemInfo)) {\n      sethoveredItemInfo({ ...itemInfo, isCurrent: true });\n      activeId.current = getRandomId();\n      setfocusedItemInfo({ ...focusedItemInfo, isCurrent: false });\n      if (itemInfo.isNode) {\n        onItemHover?.({\n          id: itemInfo.id,\n          type: 'node',\n          data: nodeIdToDataMap.get(itemInfo.id as K1)\n        });\n      } else {\n        onItemHover?.({\n          id: itemInfo.id,\n          type: 'link',\n          data: linkIdToDataMap.get(itemInfo.id as K2)\n        });\n      }\n    }\n  };\n\n  const onHoverLeave = () => {\n    sethoveredItemInfo(undefined);\n    activeId.current = undefined;\n    onItemHover?.({ id: undefined, data: undefined });\n  };\n\n  const hoverHandlers = useVisHover(onHover, undefined, onHoverLeave, touchResponse);\n\n  const pointerUpHandler = (event: PointerEvent) => {\n    const itemInfo = getNavigableInfo<K1, K2>(event.target as HTMLElement);\n    if (itemInfo.id != null) {\n      setfocusedItemInfo(itemInfo);\n      activeId.current = getRandomId();\n    }\n  };\n\n  function updatefocusedItemInfo(itemInfo: ItemInfo<K1, K2>) {\n    if (itemInfo.isNode) {\n      onItemFocus?.({\n        id: itemInfo.id,\n        type: 'node',\n        data: nodeIdToDataMap.get(itemInfo.id as K1)\n      });\n    } else {\n      onItemFocus?.({\n        id: itemInfo.id,\n        type: 'link',\n        data: linkIdToDataMap.get(itemInfo.id as K2)\n      });\n    }\n    activeId.current = getRandomId();\n    setfocusedItemInfo(itemInfo);\n  }\n\n  function handleKeyboardInput(item?: ItemInfo<K1, K2>) {\n    if (!item) return;\n    if (!isEqualItem(item, focusedItemInfo)) {\n      item.isCurrent = true;\n      item.isFocusVisible = true;\n      if (hoveredItemInfo) {\n        sethoveredItemInfo({ ...hoveredItemInfo, isCurrent: false });\n      }\n      updatefocusedItemInfo(item);\n    }\n  }\n\n  function isNavigationEvent(key: string) {\n    switch (key) {\n      case 'ArrowDown':\n      case 'ArrowUp':\n      case 'ArrowRight':\n      case 'ArrowLeft': {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  function isChangeItemType(event: KeyboardEvent) {\n    const key = event.code;\n    // check if switching from node to link\n    // equivalent of ≤ and ≥\n    if (focusedItemInfo.isNode && event.altKey && (key === 'Period' || key === 'Comma')) {\n      return true;\n      // check if switching from link to node\n    } else if (!focusedItemInfo.isNode && (key === 'ArrowLeft' || key === 'ArrowRight')) {\n      return true;\n    }\n    return false;\n  }\n\n  function handleKeyboardNavigationEvent(key: string) {\n    let direction: NavDirection = 'down';\n    switch (key) {\n      case 'ArrowDown': {\n        direction = 'down';\n        break;\n      }\n      case 'ArrowUp': {\n        direction = 'up';\n        break;\n      }\n      case 'ArrowRight': {\n        direction = 'right';\n        break;\n      }\n      case 'ArrowLeft': {\n        direction = 'left';\n        break;\n      }\n    }\n    if (focusedItemInfo.isNode) {\n      const itemDetail = getNextNavigableNode(\n        direction,\n        true,\n        getNodeDetailFromInfo(focusedItemInfo, nodes),\n        nodes\n      );\n      return itemDetail ? { id: itemDetail.id, isNode: true } : focusedItemInfo;\n    } else {\n      const linkDetail = getLinkDetailFromInfo(focusedItemInfo, links);\n      const itemDetail = getNextNavigableLink(direction, nodes, linkDetail, links);\n      return itemDetail ? { id: itemDetail.id } : { id: focusedItemInfo.id };\n    }\n  }\n\n  return {\n    focusedItemInfo,\n    hoveredItemInfo,\n    activeId: activeId.current,\n    eventsProps: mergeProps(hoverHandlers, {\n      onKeyUp: keyUpHandler,\n      onKeyDown: keyDownHandler,\n      onBlur: blurHandler,\n      onPointerUp: pointerUpHandler\n    })\n  };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type {\n  ItemInfo,\n  Bounds,\n  DatatipContext,\n  DiagramNodeData,\n  DiagramLinkData\n} from '../diagram.types';\nimport type { Ref } from 'preact/hooks';\nimport { calculateOffset, useDatatip } from '../../hooks/PRIVATE_useDatatip';\nimport type { Pan } from '../utils/panUtils';\nimport { useUser } from '../../hooks/UNSAFE_useUser';\nimport { getDatatipContent } from '../utils/diagramUtils';\nimport { ComponentChildren } from 'preact';\nimport { Property } from 'csstype';\n\ntype props<K1, K2, D1, D2> = {\n  touchResponse: 'touchStart' | 'touchHold';\n  datatip?: (context: DatatipContext<D1, D2>) => {\n    content: ComponentChildren;\n    borderColor?: Property.BorderColor;\n  };\n  text?: string;\n  focusedItemInfo: ItemInfo<K1, K2>;\n  focusedItemBoundsRef: Ref<Bounds | null>;\n  panState: Pan;\n  zoom: number;\n  width: number;\n  nodesMap: Map<K1, D1>;\n  linksMap: Map<K2, D2>;\n  hoveredItem?: ItemInfo<K1, K2>;\n};\n\n/**\n * Returns the datatip.\n * @param text The text string for the diagram item.\n * @param rootRef The ref for root of the diagram.\n * @param focusedItemBoundsRef The ref for focused item bounds.\n * @param focusedItemInfo The ItemInfo for focused item.\n * @returns\n */\nexport const useDiagramDatatip = <\n  K1,\n  K2,\n  D1 extends DiagramNodeData<K1>,\n  D2 extends DiagramLinkData<K2, K1>\n>({\n  touchResponse,\n  datatip,\n  focusedItemBoundsRef,\n  focusedItemInfo,\n  panState,\n  zoom,\n  width,\n  nodesMap,\n  linksMap,\n  hoveredItem\n}: props<K1, K2, D1, D2>) => {\n  const { direction } = useUser();\n  const isRtl = direction === 'rtl';\n\n  const datatipC = getDatatipContent(nodesMap, linksMap, focusedItemInfo, hoveredItem, datatip);\n\n  const elementBounds = focusedItemInfo?.isCurrent\n    ? {\n        x: focusedItemBoundsRef.current!.x * zoom + panState.panX,\n        y: focusedItemBoundsRef.current!.y * zoom + panState.panY,\n        width: focusedItemBoundsRef.current!.w * zoom,\n        height: focusedItemBoundsRef.current!.h * zoom\n      }\n    : undefined;\n\n  const { datatipContent, datatipProps } = useDatatip({\n    content: datatipC?.content,\n    borderColor: datatipC?.borderColor,\n    placement: 'top-start',\n    offset: calculateOffset(isRtl, width, elementBounds),\n    anchor: focusedItemInfo?.isCurrent ? 'element' : 'pointer',\n    touchResponse\n  });\n  return { datatipContent: datatipContent, datatipProps: datatipProps };\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { Ref, useRef } from 'preact/hooks';\n\ntype PointerGesture = {\n  pointers: PointerEvent[];\n};\n\ntype UsePointerGestureOptions = {\n  captureTargetRef: Ref<HTMLDivElement>;\n  numPointers: number;\n  onPointerGestureDown?: (detail: PointerGesture) => void;\n  onPointerGestureMove?: (detail: PointerGesture) => void;\n  onPointerGestureEnd?: (detail: PointerGesture) => void;\n  onExtraneousPointerDown?: (detail: PointerGesture) => void;\n  isDisabled?: boolean;\n};\n\nconst usePointerGesture = ({\n  captureTargetRef,\n  numPointers = 1,\n  onPointerGestureDown,\n  onPointerGestureMove,\n  onPointerGestureEnd,\n  onExtraneousPointerDown,\n  isDisabled = false\n}: UsePointerGestureOptions) => {\n  const activePointers = useRef<PointerEvent[]>([]);\n\n  if (isDisabled) {\n    activePointers.current = [];\n  }\n\n  const onPointerDown = (e: PointerEvent) => {\n    activePointers.current.push(e);\n    if (activePointers.current.length === numPointers) {\n      onPointerGestureDown && onPointerGestureDown({ pointers: activePointers.current });\n    } else if (activePointers.current.length > numPointers) {\n      onExtraneousPointerDown && onExtraneousPointerDown({ pointers: activePointers.current });\n    }\n  };\n\n  const onPointerMove = (e: PointerEvent) => {\n    if (activePointers.current.length === 0) return;\n\n    const index = activePointers.current.findIndex(\n      (pointerEvent) => pointerEvent.pointerId === e.pointerId\n    );\n    if (index === -1) return;\n\n    activePointers.current[index] = e;\n    if (activePointers.current.length === numPointers) {\n      activePointers.current.forEach((e) =>\n        captureTargetRef.current!.setPointerCapture(e.pointerId)\n      );\n\n      onPointerGestureMove && onPointerGestureMove({ pointers: activePointers.current });\n    }\n  };\n\n  const onPointerUp = (e: PointerEvent) => {\n    const index = activePointers.current.findIndex(\n      (pointerEvent) => pointerEvent.pointerId === e.pointerId\n    );\n    if (index === -1) return;\n\n    activePointers.current[index] = e;\n    if (activePointers.current.length === numPointers) {\n      onPointerGestureEnd && onPointerGestureEnd({ pointers: activePointers.current });\n    }\n    activePointers.current.splice(index, 1);\n  };\n\n  const onPointerCancel = onPointerUp;\n  const onPointerLeave = onPointerUp;\n\n  return isDisabled\n    ? {}\n    : {\n        onPointerDown,\n        onPointerMove,\n        onPointerUp,\n        onPointerCancel,\n        onPointerLeave\n      };\n};\n\nexport { usePointerGesture };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { Bounds, PanState } from '../diagram.types';\nimport { panXYToCenterXY } from './diagramUtils';\nexport type PanBounds = {\n  minX: number;\n  minY: number;\n  maxX: number;\n  maxY: number;\n};\n\n/**\n * The pan values that describes where the diagram content\n * is panned\n */\nexport type Pan = {\n  panX: number;\n  panY: number;\n};\n\nconst constrainPan = (\n  previousPan: Pan,\n  nextPan: Pan,\n  panBounds: PanBounds,\n  panDirection: 'x' | 'y' | 'any'\n) => {\n  const panX = panDirection !== 'y' ? nextPan.panX : previousPan.panX;\n  const panY = panDirection !== 'x' ? nextPan.panY : previousPan.panY;\n  return {\n    panX: panX > panBounds.maxX || panX < panBounds.minX ? previousPan.panX : panX,\n    panY: panY > panBounds.maxY || panY < panBounds.minY ? previousPan.panY : panY\n  };\n};\n\nexport const pan = (\n  previousPan: Pan,\n  nextPan: Pan,\n  panDirection: 'x' | 'y' | 'any',\n  zoom: number,\n  width: number,\n  height: number,\n  panBounds?: PanBounds,\n  onPanChange?: (detail: PanState) => void\n) => {\n  if (!panBounds) {\n    //On initial render before nodes are rendered\n    return { newPan: { panX: 0, panY: 0 } };\n  }\n  const newPan = constrainPan(previousPan, nextPan, panBounds, panDirection);\n  const isPanChanged = newPan.panX !== previousPan.panX || newPan.panY !== previousPan.panY;\n  const center = panXYToCenterXY(newPan.panX, newPan.panY, zoom, width, height);\n  isPanChanged &&\n    onPanChange &&\n    onPanChange({\n      centerX: center.centerX,\n      centerY: center.centerY\n    });\n  return { newPan };\n};\n\nexport const getPanBounds = (\n  width: number,\n  height: number,\n  elemBounds: Bounds,\n  panType: string,\n  zoom: number,\n  minZoom: number,\n  initPanZoomState: {\n    zoom: number;\n    centerX?: number;\n    centerY?: number;\n  }\n): PanBounds => {\n  const { x, y, w, h } = elemBounds;\n  let minX, maxX, minY, maxY;\n  if (panType === 'centerContent') {\n    minX = width / 2 - (w + x) * zoom;\n    minY = height / 2 - (h + y) * zoom;\n    maxX = width / 2 - x * zoom;\n    maxY = height / 2 - y * zoom;\n  } else {\n    // panType equals fixed\n    const zoomRatio = zoom / minZoom;\n    // Find left corner of the content at min zoom and content is centered\n    const minZoomX = (width - w * minZoom) / 2 - x * minZoom;\n    const minZoomY = (height - h * minZoom) / 2 - y * minZoom;\n    // When we pan all the way to the right, the left corner of displayable area is 0,0 as in min zoom.\n    // When we pan all the way to the left, lets find the corner of the displayable area\n    const leftCornerX = width - width * zoomRatio;\n    const leftCornerY = height - height * zoomRatio;\n    // Now we have everything to calculate pan zoom constraints\n    minX = leftCornerX + minZoomX * zoomRatio;\n    minY = leftCornerY + minZoomY * zoomRatio;\n    maxX = minZoomX * zoomRatio;\n    maxY = minZoomY * zoomRatio;\n  }\n  const initZoom = initPanZoomState.zoom;\n  const initCenterX = initPanZoomState.centerX;\n  const initCenterY = initPanZoomState.centerY;\n  // If an initial panZoomState is set, should expand pan bounds to include it\n  let dx, dy;\n  if (initCenterX) {\n    const boundsX = initCenterX * initZoom - width / 2;\n    if (-boundsX * initZoom < minX) {\n      dx = minX - boundsX * initZoom;\n      minX -= dx;\n      maxX += dx;\n    } else if (-boundsX * initZoom > maxX) {\n      dx = -boundsX * initZoom - maxX;\n      minX -= dx;\n      maxX += dx;\n    }\n  }\n  if (initCenterY) {\n    const boundsY = initCenterY * initZoom - height / 2;\n    if (-boundsY * initZoom < minY) {\n      dy = minY - boundsY * initZoom;\n      minY -= dy;\n      maxY += dy;\n    } else if (-boundsY * initZoom > maxY) {\n      dy = -boundsY * initZoom - maxY;\n      minY -= dy;\n      maxY += dy;\n    }\n  }\n  return {\n    minX: minX,\n    maxX: maxX,\n    minY: minY,\n    maxY: maxY\n  };\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { PanState } from '../diagram.types';\n\nimport { Ref, useRef } from 'preact/hooks';\nimport { useDrag } from './useDrag';\nimport { PanBounds, pan } from '../utils/panUtils';\nimport { centerXYToPanXY } from '../utils/diagramUtils';\n/**\n * Options for useDragPan hook\n */\ntype UseDragPanOptions = {\n  panProps: {\n    panning: 'centerContent' | 'fixed' | 'off';\n    centerX: number;\n    centerY: number;\n    panDirection: 'x' | 'y' | 'any';\n    onPan?: (detail: PanState) => void;\n  };\n  captureTargetRef: Ref<HTMLDivElement>;\n  panBounds?: PanBounds;\n  onDragPanStart?: () => void;\n  onDragPanEnd?: () => void;\n  zoom: number;\n  width: number;\n  height: number;\n};\n\nconst useDragPan = ({\n  panProps,\n  captureTargetRef,\n  panBounds,\n  width,\n  height,\n  zoom,\n  onDragPanStart,\n  onDragPanEnd\n}: UseDragPanOptions) => {\n  const prevPanState = useRef({ panX: 0, panY: 0 });\n  const initialPanState = useRef({ panX: 0, panY: 0 });\n  const dragProps = useDrag({\n    captureTargetRef,\n    onDragStart: () => {\n      const panValues = centerXYToPanXY(panProps.centerX, panProps.centerY, zoom, width, height);\n      initialPanState.current = {\n        panX: panValues.panX,\n        panY: panValues.panY\n      };\n      onDragPanStart && onDragPanStart();\n    },\n    onDragMove: ({ dx, dy }) => {\n      const nextPan = {\n        panX: initialPanState.current.panX + dx,\n        panY: initialPanState.current.panY + dy\n      };\n      const { newPan } = pan(\n        prevPanState.current,\n        nextPan,\n        panProps.panDirection,\n        zoom,\n        width,\n        height,\n        panBounds,\n        panProps.onPan\n      );\n      prevPanState.current = newPan;\n    },\n    onDragEnd: ({ originalEvent }) => {\n      // If panning occurred, call preventDefault to prevent selection from occurring\n      if (\n        initialPanState.current.panX !== prevPanState.current.panX ||\n        initialPanState.current.panY !== prevPanState.current.panY\n      )\n        originalEvent.preventDefault();\n      onDragPanEnd && onDragPanEnd();\n    },\n    isDisabled: panProps.panning === 'off'\n  });\n\n  return dragProps;\n};\n\nexport { useDragPan };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { Ref, useRef } from 'preact/hooks';\nimport { usePointerGesture } from './usePointerGesture';\n/**\n * Draggable region\n */\ntype DraggableRegion = {\n  xMin: number;\n  xMax: number;\n  yMin: number;\n  yMax: number;\n};\n\ntype DragDetail = {\n  x: number;\n  y: number;\n  dx: number;\n  dy: number;\n  regionOffsetX: number;\n  regionOffsetY: number;\n  originalEvent: PointerEvent;\n};\n\ntype UseDragOptions = {\n  captureTargetRef: Ref<HTMLDivElement>;\n  draggableRegion?: DraggableRegion;\n  onDragStart?: (detail: Omit<DragDetail, 'dx' | 'dy'>) => void;\n  onDragMove?: (detail: DragDetail) => void;\n  onDragEnd?: (detail: DragDetail) => void;\n  isDisabled?: boolean;\n};\n/**\n * Whether point with coordinates are in the draggable region\n */\nconst inDraggableRegion = (x: number, y: number, region?: DraggableRegion) => {\n  if (!region) return true;\n  const { xMin, xMax, yMin, yMax } = region;\n  return x >= xMin && x <= xMax && y >= yMin && y <= yMax;\n};\n\n/**\n * Returns region offset\n */\nconst getRegionOffset = (x: number, y: number, region?: DraggableRegion) => {\n  if (!region) return { regionOffsetX: x, regionOffsetY: y };\n  return { regionOffsetX: x - region.xMin, regionOffsetY: y - region.yMin };\n};\n\nconst useDrag = ({\n  captureTargetRef,\n  draggableRegion,\n  onDragStart,\n  onDragMove,\n  onDragEnd,\n  isDisabled = false\n}: UseDragOptions) => {\n  const inactiveState = { isDragging: false, x0: -1, y0: -1, regionOffsetX: -1, regionOffsetY: -1 };\n  const dragState = useRef(inactiveState);\n\n  const handlePointerEvent = (e: PointerEvent, cb?: (detail: DragDetail) => void) => {\n    const { isDragging, x0, y0, regionOffsetX, regionOffsetY } = dragState.current;\n    if (!isDragging) return;\n    const x = e.pageX;\n    const y = e.pageY;\n    cb && cb({ x, y, dx: x - x0, dy: y - y0, regionOffsetX, regionOffsetY, originalEvent: e });\n  };\n\n  const dragProps = usePointerGesture({\n    captureTargetRef,\n    numPointers: 1, // Only allow 1 pointer dragging\n    onExtraneousPointerDown: () => {\n      dragState.current = inactiveState;\n    },\n    onPointerGestureDown: ({ pointers: [e] }) => {\n      const x = e.pageX;\n      const y = e.pageY;\n      if (e.button !== 0 || !inDraggableRegion(x, y, draggableRegion)) return;\n      const { regionOffsetX, regionOffsetY } = getRegionOffset(x, y, draggableRegion);\n      dragState.current = { isDragging: true, x0: x, y0: y, regionOffsetX, regionOffsetY };\n      onDragStart && onDragStart({ x, y, regionOffsetX, regionOffsetY, originalEvent: e });\n    },\n    onPointerGestureMove: ({ pointers: [e] }) => {\n      handlePointerEvent(e, onDragMove);\n    },\n    onPointerGestureEnd: ({ pointers: [e] }) => {\n      handlePointerEvent(e, onDragEnd);\n      dragState.current = inactiveState;\n    }\n  });\n\n  return isDisabled ? {} : dragProps;\n};\n\nexport { useDrag };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nexport const ZOOM_INCREMENT = 0.05;\n\nexport const zoom = (\n  nextZoom: number,\n  zoom: number,\n  minZoom: number,\n  maxZoom: number,\n  onZoomChange?: (detail: { zoomValue: number }) => void\n) => {\n  const newZoom = nextZoom > maxZoom || nextZoom < minZoom ? zoom : nextZoom;\n  const isZoomChanged = newZoom !== zoom;\n  isZoomChanged &&\n    onZoomChange &&\n    onZoomChange({\n      zoomValue: newZoom\n    });\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { Ref, useRef } from 'preact/hooks';\nimport { usePointerGesture } from './usePointerGesture';\n\ntype Point = { x: number; y: number };\n\nconst getMidpoint = (p1: Point, p2: Point) => ({ x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 });\nconst getDistance = (p1: Point, p2: Point) => Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p2.y) ** 2);\n\ntype PinchDetail = {\n  origin: Point;\n  delta: number;\n};\n\ntype UsePinchOptions = {\n  captureTargetRef: Ref<HTMLDivElement>;\n  onPinchZoomStart?: (detail: PinchDetail) => void;\n  onPinchZoomChange?: (detail: PinchDetail) => void;\n  onPinchZoomEnd?: () => void;\n  isDisabled?: boolean;\n};\n\nconst usePinch = ({\n  captureTargetRef,\n  onPinchZoomStart,\n  onPinchZoomChange,\n  onPinchZoomEnd,\n  isDisabled = false\n}: UsePinchOptions) => {\n  const origin = useRef({ x: -1, y: -1 });\n  const prevDistance = useRef(-1);\n  const reset = () => {\n    origin.current = { x: -1, y: -1 };\n    prevDistance.current = -1;\n  };\n\n  if (isDisabled) reset();\n\n  const pinchProps = usePointerGesture({\n    captureTargetRef,\n    numPointers: 2, // Pinch gesture requires 2 pointers\n    onPointerGestureDown: ({ pointers: [pointer1, pointer2] }) => {\n      const p1 = { x: pointer1.offsetX, y: pointer1.offsetY };\n      const p2 = { x: pointer2.offsetX, y: pointer2.offsetY };\n      origin.current = getMidpoint(p1, p2);\n      prevDistance.current = getDistance(p1, p2);\n      onPinchZoomStart &&\n        onPinchZoomStart({\n          origin: origin.current,\n          delta: 0\n        });\n    },\n    onPointerGestureMove: ({ pointers: [pointer1, pointer2] }) => {\n      const p1 = { x: pointer1.offsetX, y: pointer1.offsetY };\n      const p2 = { x: pointer2.offsetX, y: pointer2.offsetY };\n      const distance = getDistance(p1, p2);\n      const delta = distance - prevDistance.current;\n      prevDistance.current = distance;\n      onPinchZoomChange &&\n        onPinchZoomChange({\n          origin: origin.current,\n          delta\n        });\n    },\n    onPointerGestureEnd: () => {\n      reset();\n      onPinchZoomEnd && onPinchZoomEnd();\n    }\n  });\n\n  return isDisabled ? {} : pinchProps;\n};\n\nexport { usePinch };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { Ref } from 'preact/hooks';\nimport { usePinch } from './usePinch';\nimport { zoom, ZOOM_INCREMENT } from '../utils/zoomUtils';\n\ntype UsePinchZoomOptions = {\n  captureTargetRef: Ref<HTMLDivElement>;\n  zooming: 'on' | 'off';\n  minZoom: number;\n  maxZoom: number;\n  zoomValue: number;\n  onZoom?: (detail: { zoomValue: number }) => void;\n};\n\nconst usePinchZoom = ({\n  captureTargetRef,\n  zooming,\n  minZoom,\n  maxZoom,\n  zoomValue,\n  onZoom\n}: UsePinchZoomOptions) => {\n  const pinchProps = usePinch({\n    captureTargetRef,\n    onPinchZoomChange: ({ delta }) => {\n      const newZoom = zoomValue * (1 + ZOOM_INCREMENT * delta);\n      zoom(newZoom, zoomValue, minZoom, maxZoom, onZoom);\n    },\n    isDisabled: zooming === 'off'\n  });\n\n  return pinchProps;\n};\n\nexport { usePinchZoom };\n","import { Pan, Zoom, Bounds } from '../diagram.types';\nimport { Ref, useState, useRef } from 'preact/hooks';\nimport { useDragPan } from './useDragPan';\nimport { useWheelZoom } from './useWheelZoom';\nimport { usePinchZoom } from './usePinchZoom';\n\nimport {\n  centerXYToPanXY,\n  getPanProps,\n  getZoomProps,\n  getZoomToFitZoom\n} from '../utils/diagramUtils';\nimport { PanBounds, getPanBounds, pan } from '../utils/panUtils';\nimport { zoom } from '../utils/zoomUtils';\nimport { mergeProps } from '../../utils/UNSAFE_mergeProps';\n\nimport { Property } from 'csstype';\n\ntype PanZoomProps = {\n  props: Pan & Zoom;\n  captureTargetRef: Ref<HTMLDivElement>;\n  width: number;\n  height: number;\n  contentBounds: Bounds;\n};\n\nexport const usePanZoom = ({\n  props,\n  captureTargetRef,\n  width,\n  height,\n  contentBounds\n}: PanZoomProps) => {\n  const [cursor, setCursor] = useState<Property.Cursor>();\n  const zoomProps = getZoomProps(props, width, height, contentBounds);\n  const panProps = getPanProps(props, contentBounds);\n  const panBounds = useRef<PanBounds>();\n  const prevZoom = useRef<number>();\n  const panning = useRef<string>();\n  const initPanZoomState = useRef({\n    zoom: props.zoomValue || 0,\n    centerX: props.centerX,\n    centerY: props.centerY\n  });\n  if (\n    contentBounds.w !== Infinity &&\n    (zoomProps.zoomValue !== prevZoom.current || panProps.panning !== panning.current)\n  ) {\n    panBounds.current = getPanBounds(\n      width,\n      height,\n      contentBounds,\n      panProps.panning,\n      zoomProps.zoomValue,\n      zoomProps.minZoom,\n      initPanZoomState.current\n    );\n    prevZoom.current = zoomProps.zoomValue;\n    panning.current = panProps.panning;\n  }\n  const dragPanProps = useDragPan({\n    panProps: panProps,\n    captureTargetRef: captureTargetRef,\n    panBounds: panBounds.current,\n    zoom: zoomProps.zoomValue,\n    width,\n    height,\n    onDragPanStart: () => setCursor('grabbing'),\n    onDragPanEnd: () => setCursor('auto')\n  });\n  //dZoom or nZoom is required\n  const kbZoomCallback = (props: { dZoom?: number; nZoom?: number }) => {\n    const newZoom = props.dZoom\n      ? zoomProps.zoomValue + props.dZoom\n      : getZoomToFitZoom(width, height, contentBounds);\n    zoom(\n      props.nZoom ? props.nZoom : newZoom,\n      zoomProps.zoomValue,\n      zoomProps.minZoom,\n      zoomProps.maxZoom,\n      zoomProps.onZoom\n    );\n  };\n  const prevPanState = useRef({ panX: 0, panY: 0 });\n\n  // dPan or nPan is required\n  const kbPanCallback = (props: {\n    dPan?: { dx: number; dy: number };\n    nPan?: { cx: number; cy: number };\n    center?: boolean;\n  }) => {\n    let centerX;\n    let centerY;\n    if (props.center) {\n      centerX = contentBounds.x + contentBounds.w / 2;\n      centerY = contentBounds.y + contentBounds.h / 2;\n    } else if (props.dPan) {\n      centerX = panProps.centerX + props.dPan.dx;\n      centerY = panProps.centerY + props.dPan.dy;\n    } else {\n      centerX = props.nPan!.cx;\n      centerY = props.nPan!.cy;\n    }\n    const panValues = centerXYToPanXY(centerX, centerY, zoomProps.zoomValue, width, height);\n    const { newPan } = pan(\n      prevPanState.current,\n      panValues,\n      panProps.panDirection,\n      zoomProps.zoomValue,\n      width,\n      height,\n      panBounds.current,\n      panProps.onPan\n    );\n    prevPanState.current = newPan;\n  };\n  const wheelZoomProps = useWheelZoom(zoomProps);\n  const pinchZoomProps = usePinchZoom({\n    captureTargetRef,\n    zooming: zoomProps.zooming,\n    minZoom: zoomProps.minZoom,\n    maxZoom: zoomProps.maxZoom,\n    zoomValue: zoomProps.zoomValue,\n    onZoom: zoomProps.onZoom\n  });\n  const panZoomProps = mergeProps(dragPanProps, wheelZoomProps, pinchZoomProps);\n\n  return {\n    panZoomProps,\n    cursor,\n    centerX: panProps.centerX,\n    centerY: panProps.centerY,\n    zoomValue: zoomProps.zoomValue,\n    kbPanCallback: panProps.panning !== 'off' ? kbPanCallback : undefined,\n    kbZoomCallback: zoomProps.zooming !== 'off' ? kbZoomCallback : undefined\n  };\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { useWheel } from './useWheel';\nimport { zoom, ZOOM_INCREMENT } from '../utils/zoomUtils';\n\ntype UseWheelZoomOptions = {\n  zooming: 'on' | 'off';\n  minZoom: number;\n  maxZoom: number;\n  zoomValue: number;\n  onZoom?: (detail: { zoomValue: number }) => void;\n};\n\nconst useWheelZoom = ({ zooming, minZoom, maxZoom, zoomValue, onZoom }: UseWheelZoomOptions) => {\n  const wheelProps = useWheel({\n    onWheel: ({ deltaY }) => {\n      const newZoom = zoomValue * (1 + ZOOM_INCREMENT * deltaY);\n      zoom(newZoom, zoomValue, minZoom, maxZoom, onZoom);\n    },\n    isDisabled: zooming === 'off'\n  });\n\n  return wheelProps;\n};\n\nexport { useWheelZoom };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\ntype WheelDetail = {\n  x: number;\n  y: number;\n  deltaX: number;\n  deltaY: number;\n  ctrlKey: boolean;\n};\n\ntype UseWheelOptions = {\n  onWheel: (detail: WheelDetail) => void;\n  preventDefault?: boolean;\n  isDisabled?: boolean;\n};\n\nconst PX_FACTOR_PER_LINE = 15; // Value used in Toolkit\nconst PX_FACTOR_PER_PAGE = 40; // Value copied from datagrid; this is not handled in Toolkit\n\nconst getNormalizedDelta = (e: WheelEvent) => {\n  const { deltaX, deltaY, deltaMode } = e;\n\n  switch (deltaMode) {\n    case e.DOM_DELTA_PIXEL:\n      return { deltaX: -deltaX, deltaY: -deltaY };\n    case e.DOM_DELTA_LINE:\n      return { deltaX: -deltaX * PX_FACTOR_PER_LINE, deltaY: -deltaY * PX_FACTOR_PER_LINE };\n    case e.DOM_DELTA_PAGE:\n      return { deltaX: -deltaX * PX_FACTOR_PER_PAGE, deltaY: -deltaY * PX_FACTOR_PER_PAGE };\n    default:\n      return { deltaX: -deltaX, deltaY: -deltaY };\n  }\n};\n\nconst useWheel = ({\n  onWheel: onWheelCallback,\n  preventDefault = true,\n  isDisabled = false\n}: UseWheelOptions) => {\n  const onWheel = (e: WheelEvent) => {\n    const { deltaX, deltaY } = getNormalizedDelta(e);\n    if (preventDefault) e.preventDefault();\n    onWheelCallback({\n      x: e.offsetX,\n      y: e.offsetY,\n      deltaX,\n      deltaY,\n      ctrlKey: e.ctrlKey || e.metaKey\n    });\n  };\n  return isDisabled ? {} : { onWheel };\n};\n\nexport { useWheel, PX_FACTOR_PER_LINE };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type {\n  DiagramProps,\n  Bounds,\n  DiagramLabelPosition,\n  States,\n  DiagramNodeData,\n  DiagramLinkData\n} from './diagram.types';\nimport type { TextDimensions } from '../hooks/PRIVATE_useTextDimensions';\nimport { DiagramLayers } from './DiagramLayers';\nimport { DiagramPanZoomContainer } from './DiagramPanZoomContainer';\nimport { useEvents } from './hooks/useEvents';\nimport { useDiagramDatatip } from './hooks/useDiagramDatatip';\nimport { useTextDimensions } from '../hooks/PRIVATE_useTextDimensions';\nimport { usePanZoom } from './hooks/usePanZoom';\nimport { useRef, useState } from 'preact/hooks';\nimport { useUser } from '../hooks/UNSAFE_useUser';\nimport { useDiagramSelection } from './hooks/useDiagramSelection';\nimport { mergeProps } from '../utils/UNSAFE_mergeProps';\nimport {\n  constructLayoutJSON,\n  deconstructLayoutJSON,\n  createItemMap,\n  getFocusedItemBounds,\n  mergeDimensions,\n  getDimensionsFromBounds,\n  combineIds,\n  getContentBounds,\n  centerXYToPanXY,\n  filterLinksWithNoEndNodes,\n  getAllLabelBounds\n} from './utils/diagramUtils';\nimport { outerStyles } from './themes/DiagramStyles.css';\nimport { useVisTouchResponse } from '#hooks/PRIVATE_useVisTouchResponse';\nimport { merge } from '#utils/UNSAFE_stringUtils';\n\ntype DiagramWithDimensionsProps<K1, K2, D1, D2> = Omit<\n  DiagramProps<K1, K2, D1, D2>,\n  'width' | 'height'\n> & {\n  width: number;\n  height: number;\n};\n\nexport function DiagramWithDimensions<\n  K1 extends string | number,\n  K2 extends string | number,\n  D1 extends DiagramNodeData<K1> = DiagramNodeData<K1>,\n  D2 extends DiagramLinkData<K2, K1> = DiagramLinkData<K2, K1>\n>({\n  nodes = [],\n  links = [],\n  width,\n  height,\n  selectedIds = {},\n  selectionMode = 'none',\n  layout,\n  nodeRenderer,\n  linkRenderer,\n  onSelectionChange,\n  onItemHover,\n  onItemFocus,\n  highlightedIds = {},\n  datatip,\n  ...otherProps\n}: DiagramWithDimensionsProps<K1, K2, D1, D2>) {\n  const focusedItemBoundsRef = useRef<Bounds | null>(null);\n  const rootRef = useRef<HTMLDivElement>(null);\n  //TODO JET-62563 change bounds to a MAP\n  const [bounds, setBounds] = useState<Bounds[]>([]);\n  const [combinedLabelBounds, setCombinedLabelBounds] = useState<Bounds>();\n  const { direction } = useUser();\n\n  const diagramNodes = nodes;\n  const nodeMap = createItemMap<K1, K2, D1, D2>(diagramNodes);\n  const nodeIdToDataMap = nodeMap.itemIdToDataMap;\n  const diagramLinks = filterLinksWithNoEndNodes(links, nodeIdToDataMap);\n  const linkMap = createItemMap<K1, K2, D1, D2>(diagramLinks);\n  const linkIdToDataMap = linkMap.itemIdToDataMap;\n  const resizeThrottling = useRef<boolean>(false);\n  const newDimensions = getDimensionsFromBounds(bounds);\n  const { textMeasureContent, getTextDimensions } = useTextDimensions();\n  const labelDimensions = useRef<Map<K1 | K2, TextDimensions>>(new Map());\n  const nodeLabelPosRef = useRef<(DiagramLabelPosition | undefined)[] | undefined>([]);\n  const linkLabelPosRef = useRef<(DiagramLabelPosition | undefined)[] | undefined>([]);\n\n  const contentBounds = getContentBounds(bounds, combinedLabelBounds);\n  const { panZoomProps, cursor, centerX, centerY, zoomValue, kbPanCallback, kbZoomCallback } =\n    usePanZoom({\n      props: otherProps,\n      captureTargetRef: rootRef,\n      width: width,\n      height: height,\n      contentBounds\n    });\n\n  const { touchResponse, touchResponseStyle } = useVisTouchResponse({\n    type: 'auto',\n    supportsTouchDragGestures:\n      otherProps.zooming === 'on' || (!!otherProps.panning && otherProps.panning !== 'off'),\n    rootRef\n  });\n\n  const { focusedItemInfo, hoveredItemInfo, activeId, eventsProps } = useEvents<K1, K2, D1, D2>(\n    touchResponse,\n    diagramNodes[0],\n    diagramNodes,\n    diagramLinks,\n    bounds,\n    linkIdToDataMap,\n    nodeIdToDataMap,\n    nodeMap.itemIdToIndexMap,\n    width,\n    height,\n    otherProps.maxZoom || 1,\n    onItemHover,\n    onItemFocus,\n    kbPanCallback,\n    kbZoomCallback\n  );\n\n  const { selectionProps, selectionContent } = useDiagramSelection<K1, K2, D1, D2>({\n    selectedIds,\n    selectionMode,\n    nodeMap,\n    linkMap,\n    focusedItemInfo,\n    onSelectionChange,\n    rootRef\n  });\n\n  // This is for the datatip kb position\n  if (focusedItemInfo && bounds.length > 0) {\n    focusedItemBoundsRef.current = getFocusedItemBounds(\n      focusedItemInfo,\n      bounds,\n      diagramLinks,\n      nodeMap.itemIdToIndexMap,\n      linkMap.itemIdToIndexMap\n    );\n  }\n\n  const {\n    datatipContent,\n    datatipProps: { 'aria-describedby': datatipAriaDescribedby, ...datatipProps }\n  } = useDiagramDatatip({\n    touchResponse,\n    datatip,\n    focusedItemInfo,\n    focusedItemBoundsRef,\n    panState: centerXYToPanXY(centerX, centerY, zoomValue, width, height),\n    zoom: zoomValue,\n    width: width,\n    nodesMap: nodeIdToDataMap,\n    linksMap: linkIdToDataMap,\n    hoveredItem: hoveredItemInfo\n  });\n\n  const style = {\n    width: width,\n    height: height,\n    cursor: cursor,\n    ...touchResponseStyle\n  };\n\n  const states = useRef<States<K1, K2>>();\n  const previousState = states.current // states.current is previous state\n    ? states.current\n    : {\n        selectedNodeIds: [],\n        selectedLinkIds: [],\n        focusedId: undefined,\n        hoveredId: undefined,\n        activeId: undefined,\n        highlightedIds: [],\n        zoom: 0\n      };\n\n  states.current = {\n    // update states to new state\n    selectedNodeIds: selectedIds.nodes ?? [],\n    selectedLinkIds: selectedIds.links ?? [],\n    focusedId:\n      focusedItemInfo.isCurrent && focusedItemInfo.isFocusVisible ? focusedItemInfo.id : undefined,\n    hoveredId: hoveredItemInfo?.isCurrent ? hoveredItemInfo.id : undefined,\n    activeId,\n    highlightedIds: combineIds(highlightedIds.nodes, highlightedIds.links),\n    zoom: zoomValue\n  };\n\n  const mergedEventProps = mergeProps(panZoomProps, eventsProps, selectionProps, datatipProps);\n\n  // Called anytime node changes size\n  const onNodeSizeChanged = (nodeWidth: number, nodeHeight: number, idx: number) => {\n    newDimensions[idx] = { w: nodeWidth, h: nodeHeight };\n    if (resizeThrottling.current) {\n      return;\n    }\n\n    resizeThrottling.current = true;\n    // performs layout at the next available animation frame when all measurements should be ready\n    window.requestAnimationFrame(() => {\n      const { labelDims, layoutJSON } = constructLayoutJSON(\n        diagramNodes,\n        nodeIdToDataMap,\n        linkIdToDataMap,\n        newDimensions,\n        width,\n        height,\n        getTextDimensions\n      );\n      labelDimensions.current = labelDims;\n      const { nodePoints, nodeLabelPos, linkLabelPos } = deconstructLayoutJSON<K1, K2, D1, D2>(\n        layout(layoutJSON),\n        diagramNodes,\n        diagramLinks\n      );\n      nodeLabelPosRef.current = nodeLabelPos;\n      linkLabelPosRef.current = linkLabelPos;\n      const nodeBounds = mergeDimensions(newDimensions, nodePoints);\n      setBounds(nodeBounds);\n      const labelBounds = getAllLabelBounds(\n        labelDims,\n        diagramNodes,\n        diagramLinks,\n        nodeLabelPos,\n        linkLabelPos,\n        direction === 'rtl'\n      );\n      setCombinedLabelBounds(labelBounds);\n      resizeThrottling.current = false;\n    });\n  };\n  return (\n    <div\n      ref={rootRef}\n      class={outerStyles}\n      {...mergedEventProps}\n      style={style}\n      tabIndex={0}\n      role=\"application\"\n      aria-label={otherProps['aria-label']}\n      aria-labelledby={otherProps['aria-labelledby']}\n      aria-describedby={merge([otherProps['aria-describedby'], datatipAriaDescribedby])}\n      aria-activedescendant={activeId}>\n      {getTextDimensions ? (\n        <DiagramPanZoomContainer\n          centerX={centerX}\n          centerY={centerY}\n          zoom={zoomValue}\n          width={width}\n          height={height}>\n          <DiagramLayers\n            nodes={diagramNodes}\n            links={diagramLinks}\n            nodeRenderer={nodeRenderer}\n            linkRenderer={linkRenderer}\n            width={width}\n            height={height}\n            nodeBounds={bounds}\n            states={states.current!}\n            previousStates={previousState}\n            onNodeSizeChanged={onNodeSizeChanged}\n            nodeLabelPositions={nodeLabelPosRef.current}\n            linkLabelPositions={linkLabelPosRef.current}\n            labelDimensions={labelDimensions.current}\n            supportsSelection={\n              selectionMode !== 'none' ||\n              !!(selectedIds?.nodes && selectedIds.nodes.length > 0) ||\n              !!(selectedIds?.links && selectedIds.links.length > 0)\n            }\n          />\n        </DiagramPanZoomContainer>\n      ) : undefined}\n      {textMeasureContent}\n      {datatipContent}\n      {selectionContent}\n    </div>\n  );\n}\n","import { useSelection } from '../../hooks/PRIVATE_useVisSelection';\nimport type { ItemInfo } from '../diagram.types';\nimport { getNavigableInfo } from '../utils/diagramUtils';\nimport { Ref } from 'preact/hooks';\n\ntype SelectionProps<K1, K2, D1, D2> = {\n  selectedIds: {\n    nodes?: K1[];\n    links?: K2[];\n  };\n  selectionMode: 'none' | 'single' | 'multiple';\n  nodeMap: {\n    itemIdToDataMap: Map<K1, D1>;\n    itemIdToIndexMap: Map<K1, number>;\n    itemIndexToIdMap: Map<number, K1>;\n  };\n  linkMap: {\n    itemIdToDataMap: Map<K2, D2>;\n    itemIdToIndexMap: Map<K2, number>;\n    itemIndexToIdMap: Map<number, K2>;\n  };\n  focusedItemInfo: ItemInfo<K1, K2>;\n  onSelectionChange?: (detail: {\n    nodes: K1[];\n    links: K2[];\n    nodeData: (D1 | undefined)[];\n    linkData: (D2 | undefined)[];\n  }) => void;\n  rootRef: Ref<HTMLDivElement>;\n};\n\ntype EncodedNodeId = `N_${number}`;\ntype EncodedLinkId = `L_${number}`;\n\nexport function useDiagramSelection<K1, K2, D1, D2>({\n  selectedIds,\n  selectionMode,\n  nodeMap,\n  linkMap,\n  focusedItemInfo,\n  onSelectionChange,\n  rootRef\n}: SelectionProps<K1, K2, D1, D2>) {\n  const nodeIdToIndexMap = nodeMap.itemIdToIndexMap;\n  const nodeIndexToIdMap = nodeMap.itemIndexToIdMap;\n  const linkIdToIndexMap = linkMap.itemIdToIndexMap;\n  const linkIndexToIdMap = linkMap.itemIndexToIdMap;\n  const encodeNodeId = (id: K1) => `N_${nodeIdToIndexMap.get(id)}` as EncodedNodeId;\n  const decodeNodeId = (id: EncodedNodeId) => nodeIndexToIdMap.get(Number(id.slice(2)));\n  const encodeLinkId = (id: K2) => `L_${linkIdToIndexMap.get(id)}` as EncodedLinkId;\n  const decodeLinkId = (id: EncodedLinkId) => linkIndexToIdMap.get(Number(id.slice(2)));\n\n  const encodedNodesSelection = selectedIds.nodes ? selectedIds.nodes.map(encodeNodeId) : [];\n  const encodedLinksSelection = selectedIds.links ? selectedIds.links.map(encodeLinkId) : [];\n  const encodedSelection = [...encodedNodesSelection, ...encodedLinksSelection];\n  const idExtracter = (event: Event) => {\n    // return encodeNodeId(id) or encodeLinkId(id) depending on node or link selection or undefined if clicked on empty space\n    const info =\n      event.type === 'keyup'\n        ? focusedItemInfo\n        : getNavigableInfo<K1, K2>(event.target as HTMLElement, rootRef);\n    return info.id !== undefined\n      ? info.isNode\n        ? encodeNodeId(info.id as K1)\n        : encodeLinkId(info.id as K2)\n      : undefined;\n  };\n\n  const onEncodedSelectionChange = (detail: { ids: (EncodedNodeId | EncodedLinkId)[] }) => {\n    const newSelectedNodeIds = detail.ids\n      .filter((encId) => encId[0] === 'N')\n      .map((encId) => decodeNodeId(encId as EncodedNodeId)!);\n    const newSelectedLinkIds = detail.ids\n      .filter((encId) => encId[0] === 'L')\n      .map((encId) => decodeLinkId(encId as EncodedLinkId)!);\n\n    const nodeData = newSelectedNodeIds.map((selectedId) => {\n      return nodeMap.itemIdToDataMap.get(selectedId);\n    });\n    const linkData = newSelectedLinkIds.map((selectedId) => {\n      return linkMap.itemIdToDataMap.get(selectedId);\n    });\n    return (\n      onSelectionChange &&\n      onSelectionChange({\n        nodes: newSelectedNodeIds,\n        links: newSelectedLinkIds,\n        nodeData,\n        linkData\n      })\n    );\n  };\n  const getDataById = (id: EncodedNodeId | EncodedLinkId) => {\n    let data;\n    if (id[0] === 'N') {\n      const nodeId = decodeNodeId(id as EncodedNodeId)!;\n      data = nodeMap.itemIdToDataMap.get(nodeId);\n    } else if (id[0] === 'L') {\n      const linkId = decodeLinkId(id as EncodedLinkId)!;\n      data = linkMap.itemIdToDataMap.get(linkId);\n    }\n    return data;\n  };\n\n  const { selectionContent, selectionProps } = useSelection<`N_${number}` | `L_${number}`, D1 | D2>(\n    {\n      selection: encodedSelection,\n      idExtracter,\n      selectionMode,\n      getDataById,\n      onChange: onEncodedSelectionChange\n    }\n  );\n\n  return { selectionContent, selectionProps };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { DiagramProps, DiagramNodeData, DiagramLinkData } from './diagram.types';\nimport { TrackResizeContainer } from '../PRIVATE_TrackResizeContainer';\nimport { dimensionStyle } from './themes/DiagramStyles.css';\nimport { DiagramWithDimensions } from './DiagramWithDimensions';\n\n/**\n * Diagrams are used to display a set of nodes and the links between them.\n */\nexport function Diagram<\n  K1 extends string | number,\n  K2 extends string | number,\n  D1 extends DiagramNodeData<K1> = DiagramNodeData<K1>,\n  D2 extends DiagramLinkData<K2, K1> = DiagramLinkData<K2, K1>\n>({ width, height, ...otherProps }: DiagramProps<K1, K2, D1, D2>) {\n  return otherProps.nodes && otherProps.nodes.length > 0 ? (\n    <TrackResizeContainer width={width} height={height} class={dimensionStyle}>\n      {(width, height) => <DiagramWithDimensions width={width} height={height} {...otherProps} />}\n    </TrackResizeContainer>\n  ) : null;\n}\n"],"names":["ZOOM_TO_FIT_PADDING","createItemMap","items","itemIdToDataMap","Map","itemIdToIndexMap","itemIndexToIdMap","i","length","set","id","combineIds","nodeIds","linkIds","combinedIds","push","getLabelBounds","label","dims","isRTL","labelPos","getLabelPosition","rotationAngle","rotationPoint","x","width","y","height","angle","topLeft","getCoordsRelToRotPoint","topRight","bottomLeft","bottomRight","points","minX","minY","maxX","maxY","point","w","h","getBoundsFromPoints","rotatePoint","map","pos","labelPoint","rotPoint","Math","cos","sin","dimensions","positionProps","position","hAlign","vAlign","centerXYToPanXY","centerX","centerY","zoom","panX","panY","isEqualItem","item1","item2","isNode","getNavigableInfo","element","rootElementRef","navigableId","elem","dataset","parentElement","current","getItemAriaLabel","translations","supportsSelection","isSelected","accessibleLabel","generateAriaLabel","undefined","getZoomToFitZoom","contentBounds","zoomX","zoomY","min","constrainZoom","minZoom","maxZoom","newZoom","max","_getFontProps","styles","fontProps","fontFamily","fontSize","fontStyle","fontWeight","zoomAndCenterItemFromInfo","info","linkIdToDataMap","bounds","nodeIdToIndex","totalBounds","get","link","startNodeBounds","startNode","endNodeBounds","endNode","cX","cY","getPanZoomToCenterNode","DiagramNodeElement","state","previousState","activeId","nodeRenderer","onNodeSizeChanged","nodeIndex","data","isDimmed","nodeStyles","dimmedItemStyle","itemStyles","context","useTranslationBundle","ref","useRef","optionsRef","box","useResizeObserver","useCallback","entry","boxSize","borderBoxSize","inlineSize","blockSize","_jsx","class","classNames","role","selected","style","top","left","focused","hovered","children","DiagramNodeLayer","nodes","states","previousStates","nodeBounds","layerStyles","node","selectedNodeIds","includes","focusedId","hoveredId","jsx","highlightedIds","DiagramLinkElement","linkRenderer","linkStyles","DiagramLinkLayer","links","selectedLinkIds","DiagramLabel","text","labelStyle","labelBorderStyle","labelStyles","labelPosition","labelRotation","rotation","getLabelRotation","borderColor","DiagramLabelLayer","itemProps","labelDimensions","direction","useUser","item","DiagramLayers","nodeLabelPositions","linkLabelPositions","_jsxs","jsxs","_Fragment","Fragment","Infinity","DiagramPanZoomContainer","panValues","panZoomStyles","translate","transform","getNodeDetailFromInfo","itemInfo","getNavigableLinksForNodeId","nodeId","listOfLinks","forEach","startId","endId","_getClockwiseAngle","currNode","oppositeNode","p1","_getNodeCenter","p2","atan2","PI","_getNodesDistance","sqrt","pow","_getLinkDirection","nodeBB","calcDistanceAngleWeighted","objectBB","currentBB","optimalAngle1","optimalAngle2","objCenterX","objCenterY","curCenterX","curCenterY","x_dist","abs","y_dist","distance","isValidDestination","objBB","curBB","compareCenters","_areEqualWithinTolerance","calcInContact","objRect","curRect","_isVerticallyAligned","_isHorizontallyAligned","rect1","rect2","a","b","_anglesAreEqualWithinTolerance","a1","a2","res","useDiagramNavigation","currentKeyboardFocusNode","nodeBoundsById","createNodeBoundsMap","getNextNavigableNode","listOfObjects","currBB","object","inContact","nextObject","nextDistance","Number","MAX_VALUE","nextInContact","hasFoundCurrent","objBounds","currBounds","getNextNavigableLink","listOfNodes","currentLink","keyboardFocusNode","linksWithSortingAttributes","linkDetail","addSortingAttributes","sort","link1","link2","linkAngle1","linkDistance1","linkDirection1","linkAngle2","linkDistance2","linkDirection2","bForward","index","navigateFromNodeToLink","event","adjLinks","currNodeBB","currNodeBBCenterX","nodeCenterX","altKey","code","navigateFromLinkToNode","linkId","key","linkData","startNodeBB","endNodeBB","startNodeCenterX","endNodeCenterX","DEFAULT_KB_PAN","DEFAULT_KB_ZOOM","useEvents","touchResponse","initNode","nodeIdToDataMap","nodeIdToIndexMap","onItemHover","onItemFocus","kbPanCallback","kbZoomCallback","focusedItemInfo","setfocusedItemInfo","useState","hoveredItemInfo","sethoveredItemInfo","hoverHandlers","useVisHover","target","isCurrent","getRandomId","type","updatefocusedItemInfo","handleKeyboardInput","isFocusVisible","eventsProps","mergeProps","onKeyUp","onKeyDown","eventConsumed","isChangeItemType","isNavigationEvent","nextItemInfo","itemDetail","getLinkDetailFromInfo","handleKeyboardNavigationEvent","dPan","dx","shiftKey","dy","dZoom","ctrlKey","nZoom","nPan","cx","cy","center","preventDefault","stopPropagation","cancelEvent","onBlur","onPointerUp","useDiagramDatatip","datatip","focusedItemBoundsRef","panState","nodesMap","linksMap","hoveredItem","isRtl","datatipC","focusedItem","isPointerActive","content","getDatatipContent","elementBounds","datatipContent","datatipProps","useDatatip","placement","offset","calculateOffset","anchor","usePointerGesture","captureTargetRef","numPointers","onPointerGestureDown","onPointerGestureMove","onPointerGestureEnd","onExtraneousPointerDown","isDisabled","activePointers","e","findIndex","pointerEvent","pointerId","pointers","splice","onPointerDown","onPointerMove","setPointerCapture","onPointerCancel","onPointerLeave","pan","previousPan","nextPan","panDirection","panBounds","onPanChange","newPan","constrainPan","isPanChanged","panXYToCenterXY","useDragPan","panProps","onDragPanStart","onDragPanEnd","prevPanState","initialPanState","dragProps","draggableRegion","onDragStart","onDragMove","onDragEnd","inactiveState","isDragging","x0","y0","regionOffsetX","regionOffsetY","dragState","handlePointerEvent","cb","pageX","pageY","originalEvent","button","region","xMin","xMax","yMin","yMax","inDraggableRegion","getRegionOffset","useDrag","onPan","panning","nextZoom","onZoomChange","zoomValue","getDistance","usePinchZoom","zooming","onZoom","pinchProps","onPinchZoomStart","onPinchZoomChange","onPinchZoomEnd","origin","prevDistance","reset","pointer1","pointer2","offsetX","offsetY","getMidpoint","delta","usePinch","usePanZoom","props","cursor","setCursor","zoomProps","getZoomProps","getPanProps","prevZoom","initPanZoomState","elemBounds","panType","zoomRatio","minZoomX","minZoomY","initZoom","initCenterX","initCenterY","boundsX","boundsY","getPanBounds","dragPanProps","wheelZoomProps","onWheel","onWheelCallback","deltaX","deltaY","deltaMode","DOM_DELTA_PIXEL","DOM_DELTA_LINE","DOM_DELTA_PAGE","getNormalizedDelta","metaKey","useWheel","useWheelZoom","pinchZoomProps","panZoomProps","DiagramWithDimensions","selectedIds","selectionMode","layout","onSelectionChange","otherProps","rootRef","setBounds","combinedLabelBounds","setCombinedLabelBounds","diagramNodes","nodeMap","diagramLinks","newLinks","filterLinksWithNoEndNodes","linkMap","resizeThrottling","newDimensions","getDimensionsFromBounds","textMeasureContent","getTextDimensions","useTextDimensions","nodeLabelPosRef","linkLabelPosRef","labelBounds","getContentBounds","touchResponseStyle","useVisTouchResponse","supportsTouchDragGestures","selectionProps","selectionContent","nodeIndexToIdMap","linkIdToIndexMap","linkIndexToIdMap","encodeNodeId","decodeNodeId","slice","encodeLinkId","decodeLinkId","encodedSelection","useSelection","selection","idExtracter","getDataById","onChange","detail","newSelectedNodeIds","ids","filter","encId","newSelectedLinkIds","nodeData","selectedId","useDiagramSelection","startNB","endNB","startNCenter","endNCenter","getFocusedItemBounds","datatipAriaDescribedby","mergedEventProps","outerStyles","tabIndex","merge","nodeWidth","nodeHeight","idx","window","requestAnimationFrame","labelDims","layoutJSON","nodeItems","linkItems","nodeKeys","Array","from","keys","linkKeys","getNodeDimensions","getLabelDimensions","componentSize","constructLayoutJSON","nodePoints","nodeLabelPos","linkLabelPos","positions","hasNodeLabels","hasLinkLabels","deconstructLayoutJSON","newBounds","dim","mergeDimensions","getAllLabelBounds","TrackResizeContainer","dimensionStyle"],"mappings":"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"}